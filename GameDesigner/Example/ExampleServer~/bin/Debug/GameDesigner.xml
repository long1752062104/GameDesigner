<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GameDesigner</name>
    </assembly>
    <members>
        <member name="T:GameDesigner.Blueprint">
            <summary>
            蓝图基类,想要自定义蓝图可继承此类
            </summary>
        </member>
        <member name="M:GameDesigner.Blueprint.CreateBlueprintInstance(System.String)">
            创建状态机实例
        </member>
        <member name="T:GameDesigner.BlueprintEditorManager">
            <summary>
            蓝图编辑器运行类，使用此类可快速设置编辑器的功能
            </summary>
        </member>
        <member name="T:GameDesigner.IBlueprint">
            <summary>
            行为基类
            </summary>
        </member>
        <member name="M:GameDesigner.IBlueprint.CheckUpdate">
            <summary>
            编辑器检查更新蓝图编辑器
            </summary>
        </member>
        <member name="T:GameDesigner.BlueprintManager">
            <summary>
            蓝图管理器,默认蓝图添加此组件
            </summary>
        </member>
        <member name="T:GameDesigner.Constructor">
            <summary>
            构造器
            </summary>
        </member>
        <member name="M:GameDesigner.Constructor.GetConstructors(System.String)">
            <summary>
            获得所有方法信息 ( typeName 要获得的类名 )
            </summary>
        </member>
        <member name="M:GameDesigner.Constructor.GetConstructors(System.Type)">
            <summary>
            获得所有方法信息 ( typeName 要获得的类名 )
            </summary>
        </member>
        <member name="M:GameDesigner.Constructor.CreateInstance(GameDesigner.Constructor)">
            <summary>
            创建对象实例 ( typeName 类的完全限定名 , 构造存储器 ) )
            </summary>
        </member>
        <member name="M:GameDesigner.Constructor.CreateInstance(System.String,GameDesigner.Constructor)">
            <summary>
            创建对象实例 ( typeName 类的完全限定名 , 构造存储器 ) )
            </summary>
        </member>
        <member name="M:GameDesigner.Constructor.Invoke(GameDesigner.Constructor)">
            <summary>
            调用唯一一个方法 , 使最优化，使尽可能有效 ( target 实体对象  , method 方法管理器与参数管理器 , varInfo[] 只有使用变量值时调用 )
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.Branch.IF(System.Object,Contition,System.Object)">
            <summary>
            如果控制语句函数---v2017.12.17
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.Branch.IF(System.Boolean,GameDesigner.Node)">
            <summary>
            如果控制语句函数---v2017.12.17
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.Branch.IF(System.Boolean,GameDesigner.Node,GameDesigner.Node)">
            <summary>
            如果控制语句函数---v2017.12.17
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.Branch.IF(System.Object,Contition,System.Object,GameDesigner.Node)">
            <summary>
            如果控制语句函数---v2017.12.17
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.Branch.IF(System.Object,Contition,System.Object,GameDesigner.Node,GameDesigner.Node)">
            <summary>
            如果控制语句函数---v2017.12.17
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.Branch.Condition(System.Object,Contition,System.Object)">
            <summary>
            判断参数值---v2017.7.15
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.ForLoop.For(System.Array,GameDesigner.Node,GameDesigner.Node)">
            <summary>
            循环语句,array数组,元素索引:把元素对象发送给elementValue对象,runtime用来判断当前元素的逻辑
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.ForLoop.For1(System.Array,GameDesigner.Node,GameDesigner.Node)">
            <summary>
            循环语句,array数组,元素索引:把索引发送给elementIndex对象,这个对象必须为int类型,runtime用来判断当前元素的逻辑
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.ForLoop.For(System.Array,GameDesigner.Node,GameDesigner.Node,Contition,GameDesigner.Node,GameDesigner.Node)">
            <summary>
            循环语句,array数组,元素对象:把元素对象发送给elementValue对象,
            元素索引:把索引发送给elementIndex对象
            判断a和b的条件,当条件成立设置元素值为elementValue
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.ForLoop.For(System.Array,GameDesigner.Node,GameDesigner.Node,System.Object,Contition,System.Object,GameDesigner.Node)">
            <summary>
            循环语句,array数组,元素对象:把元素对象发送给elementValue对象,
            元素索引:把索引发送给elementIndex对象,这个对象必须为int类型,
            判断a和b的条件,当条件成立进入True参数
            </summary>
        </member>
        <member name="M:GameDesigner.FlowControls.ForLoop.For(System.Array,GameDesigner.Node,GameDesigner.Node,System.Object,Contition,System.Object,GameDesigner.Node,GameDesigner.Node)">
            <summary>
            循环语句,array数组,元素对象:把元素对象发送给elementValue对象,
            元素索引:把索引发送给elementIndex对象,这个对象必须为int类型,
            判断a和b的条件,当条件成立进入True参数,假则加入False
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.Adds(System.Byte,System.Byte)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.Subtracts(System.Byte,System.Byte)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.Multiplies(System.Byte,System.Byte)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.Divides(System.Byte,System.Byte)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.BaiFeiBi100(System.Byte,System.Byte)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.QiuYu(System.Byte,System.Byte)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Byte.BinQie(System.Byte,System.Byte)" -->
        <member name="M:GameDesigner.MathOperations.Byte.Equals(System.Byte,System.Byte)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.NotEquals(System.Byte,System.Byte)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.MaxEquals(System.Byte,System.Byte)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Byte.MinEquals(System.Byte,System.Byte)" -->
        <member name="M:GameDesigner.MathOperations.Byte.Max(System.Byte,System.Byte)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Byte.Min(System.Byte,System.Byte)" -->
        <member name="M:GameDesigner.MathOperations.Byte.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.AddEquals(System.Byte)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.SubtractEquals(System.Byte)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.MultiplieEquals(System.Byte)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.DivideEquals(System.Byte)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.BaiFeiBi100Equals(System.Byte)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Byte.QiuYuEquals(System.Byte)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.Adds(System.Double,System.Double)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.Subtracts(System.Double,System.Double)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.Multiplies(System.Double,System.Double)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.Divides(System.Double,System.Double)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.BaiFeiBi100(System.Double,System.Double)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.Equals(System.Double,System.Double)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.NotEquals(System.Double,System.Double)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.MaxEquals(System.Double,System.Double)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Double.MinEquals(System.Double,System.Double)" -->
        <member name="M:GameDesigner.MathOperations.Double.Max(System.Double,System.Double)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Double.Min(System.Double,System.Double)" -->
        <member name="M:GameDesigner.MathOperations.Double.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.AddEquals(System.Double)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.SubtractEquals(System.Double)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.MultiplieEquals(System.Double)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.DivideEquals(System.Double)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Double.BaiFeiBi100Equals(System.Double)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.Adds(System.Single,System.Single)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.Subtracts(System.Single,System.Single)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.Multiplies(System.Single,System.Single)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.Divides(System.Single,System.Single)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.BaiFeiBi100(System.Single,System.Single)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.Equals(System.Single,System.Single)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.NotEquals(System.Single,System.Single)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.MaxEquals(System.Single,System.Single)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Float.MinEquals(System.Single,System.Single)" -->
        <member name="M:GameDesigner.MathOperations.Float.Max(System.Single,System.Single)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Float.Min(System.Single,System.Single)" -->
        <member name="M:GameDesigner.MathOperations.Float.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.AddEquals(System.Single)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.AddEquals(System.Single,System.Boolean)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.AddEquals(System.Single,System.Single,System.Boolean)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.SubtractEquals(System.Single)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.MultiplieEquals(System.Single)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.DivideEquals(System.Single)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Float.BaiFeiBi100Equals(System.Single)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.Adds(System.Int16,System.Int16)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.Subtracts(System.Int16,System.Int16)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.Multiplies(System.Int16,System.Int16)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.Divides(System.Int16,System.Int16)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.BaiFeiBi100(System.Int16,System.Int16)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.QiuYu(System.Int16,System.Int16)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int16.BinQie(System.Int16,System.Int16)" -->
        <member name="M:GameDesigner.MathOperations.Int16.Equals(System.Int16,System.Int16)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.NotEquals(System.Int16,System.Int16)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.MaxEquals(System.Int16,System.Int16)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int16.MinEquals(System.Int16,System.Int16)" -->
        <member name="M:GameDesigner.MathOperations.Int16.Max(System.Int16,System.Int16)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int16.Min(System.Int16,System.Int16)" -->
        <member name="M:GameDesigner.MathOperations.Int16.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.AddEquals(System.Int16)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.SubtractEquals(System.Int16)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.MultiplieEquals(System.Int16)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.DivideEquals(System.Int16)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.BaiFeiBi100Equals(System.Int16)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int16.QiuYuEquals(System.Int16)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.Adds(System.Int32,System.Int32)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.Subtracts(System.Int32,System.Int32)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.Multiplies(System.Int32,System.Int32)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.Divides(System.Int32,System.Int32)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.BaiFeiBi100(System.Int32,System.Int32)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.QiuYu(System.Int32,System.Int32)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int32.BinQie(System.Int32,System.Int32)" -->
        <member name="M:GameDesigner.MathOperations.Int32.Equals(System.Int32,System.Int32)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.NotEquals(System.Int32,System.Int32)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.MaxEquals(System.Int32,System.Int32)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int32.MinEquals(System.Int32,System.Int32)" -->
        <member name="M:GameDesigner.MathOperations.Int32.Max(System.Int32,System.Int32)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int32.Min(System.Int32,System.Int32)" -->
        <member name="M:GameDesigner.MathOperations.Int32.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.AddEquals(System.Int32)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.SubtractEquals(System.Int32)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.MultiplieEquals(System.Int32)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.DivideEquals(System.Int32)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.BaiFeiBi100Equals(System.Int32)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int32.QiuYuEquals(System.Int32)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.Adds(System.Int64,System.Int64)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.Subtracts(System.Int64,System.Int64)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.Multiplies(System.Int64,System.Int64)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.Divides(System.Int64,System.Int64)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.BaiFeiBi100(System.Int64,System.Int64)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.QiuYu(System.Int64,System.Int64)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int64.BinQie(System.Int64,System.Int64)" -->
        <member name="M:GameDesigner.MathOperations.Int64.Equals(System.Int64,System.Int64)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.NotEquals(System.Int64,System.Int64)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.MaxEquals(System.Int64,System.Int64)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int64.MinEquals(System.Int64,System.Int64)" -->
        <member name="M:GameDesigner.MathOperations.Int64.Max(System.Int64,System.Int64)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.Int64.Min(System.Int64,System.Int64)" -->
        <member name="M:GameDesigner.MathOperations.Int64.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.AddEquals(System.Int64)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.SubtractEquals(System.Int64)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.MultiplieEquals(System.Int64)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.DivideEquals(System.Int64)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.BaiFeiBi100Equals(System.Int64)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.Int64.QiuYuEquals(System.Int64)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.Adds(System.SByte,System.SByte)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.Subtracts(System.SByte,System.SByte)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.Multiplies(System.SByte,System.SByte)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.Divides(System.SByte,System.SByte)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.BaiFeiBi100(System.SByte,System.SByte)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.QiuYu(System.SByte,System.SByte)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.SByte.BinQie(System.SByte,System.SByte)" -->
        <member name="M:GameDesigner.MathOperations.SByte.Equals(System.SByte,System.SByte)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.NotEquals(System.SByte,System.SByte)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.MaxEquals(System.SByte,System.SByte)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.SByte.MinEquals(System.SByte,System.SByte)" -->
        <member name="M:GameDesigner.MathOperations.SByte.Max(System.SByte,System.SByte)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.SByte.Min(System.SByte,System.SByte)" -->
        <member name="M:GameDesigner.MathOperations.SByte.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.AddEquals(System.SByte)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.SubtractEquals(System.SByte)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.MultiplieEquals(System.SByte)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.DivideEquals(System.SByte)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.BaiFeiBi100Equals(System.SByte)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.SByte.QiuYuEquals(System.SByte)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.String.Adds(System.String,System.String)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.Adds(System.UInt16,System.UInt16)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.Subtracts(System.UInt16,System.UInt16)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.Multiplies(System.UInt16,System.UInt16)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.Divides(System.UInt16,System.UInt16)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.BaiFeiBi100(System.UInt16,System.UInt16)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.QiuYu(System.UInt16,System.UInt16)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt16.BinQie(System.UInt16,System.UInt16)" -->
        <member name="M:GameDesigner.MathOperations.UInt16.Equals(System.UInt16,System.UInt16)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.NotEquals(System.UInt16,System.UInt16)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.MaxEquals(System.UInt16,System.UInt16)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt16.MinEquals(System.UInt16,System.UInt16)" -->
        <member name="M:GameDesigner.MathOperations.UInt16.Max(System.UInt16,System.UInt16)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt16.Min(System.UInt16,System.UInt16)" -->
        <member name="M:GameDesigner.MathOperations.UInt16.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.AddEquals(System.UInt16)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.SubtractEquals(System.UInt16)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.MultiplieEquals(System.UInt16)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.DivideEquals(System.UInt16)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.BaiFeiBi100Equals(System.UInt16)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt16.QiuYuEquals(System.UInt16)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.Adds(System.UInt32,System.UInt32)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.Subtracts(System.UInt32,System.UInt32)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.Multiplies(System.UInt32,System.UInt32)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.Divides(System.UInt32,System.UInt32)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.BaiFeiBi100(System.UInt32,System.UInt32)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.QiuYu(System.UInt32,System.UInt32)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt32.BinQie(System.UInt32,System.UInt32)" -->
        <member name="M:GameDesigner.MathOperations.UInt32.Equals(System.UInt32,System.UInt32)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.NotEquals(System.UInt32,System.UInt32)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.MaxEquals(System.UInt32,System.UInt32)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt32.MinEquals(System.UInt32,System.UInt32)" -->
        <member name="M:GameDesigner.MathOperations.UInt32.Max(System.UInt32,System.UInt32)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt32.Min(System.UInt32,System.UInt32)" -->
        <member name="M:GameDesigner.MathOperations.UInt32.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.AddEquals(System.UInt32)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.SubtractEquals(System.UInt32)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.MultiplieEquals(System.UInt32)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.DivideEquals(System.UInt32)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.BaiFeiBi100Equals(System.UInt32)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt32.QiuYuEquals(System.UInt32)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.Adds(System.UInt64,System.UInt64)">
            <summary>
            返回a+b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.Subtracts(System.UInt64,System.UInt64)">
            <summary>
            返回a-b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.Multiplies(System.UInt64,System.UInt64)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.Divides(System.UInt64,System.UInt64)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.BaiFeiBi100(System.UInt64,System.UInt64)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.QiuYu(System.UInt64,System.UInt64)">
            <summary>
            返回a^b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt64.BinQie(System.UInt64,System.UInt64)" -->
        <member name="M:GameDesigner.MathOperations.UInt64.Equals(System.UInt64,System.UInt64)">
            <summary>
            返回a==b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.NotEquals(System.UInt64,System.UInt64)">
            <summary>
            返回a!=b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.MaxEquals(System.UInt64,System.UInt64)">
            <summary>
            返回a>=b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt64.MinEquals(System.UInt64,System.UInt64)" -->
        <member name="M:GameDesigner.MathOperations.UInt64.Max(System.UInt64,System.UInt64)">
            <summary>
            返回a>b
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:GameDesigner.MathOperations.UInt64.Min(System.UInt64,System.UInt64)" -->
        <member name="M:GameDesigner.MathOperations.UInt64.AddAdds">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.AddEquals(System.UInt64)">
            <summary>
            返回a++
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.SubtractSubtracts">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.SubtractEquals(System.UInt64)">
            <summary>
            返回a--
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.MultiplieEquals(System.UInt64)">
            <summary>
            返回a*b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.DivideEquals(System.UInt64)">
            <summary>
            返回a/b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.BaiFeiBi100Equals(System.UInt64)">
            <summary>
            返回a%b
            </summary>
        </member>
        <member name="M:GameDesigner.MathOperations.UInt64.QiuYuEquals(System.UInt64)">
            <summary>
            返回a^b
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.ReplaceEndToOne(System.String,System.String,System.String)">
            <summary>
            解释 : 获得str字符串中的所有字符,当出现与oldValue相同的字符时更换为newValue的字符,(当出现与oldValue相同或有n个,只更换最后一个为newValue的字符)
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.ReplaceEndToOne(System.String,System.String)">
            <summary>
            解释 : 获得str字符串中的所有字符,当出现与oldValue相同的字符时进行拆分,拆分的字符只返回后面的字符
            解释1 : 获得str字符串中的所有字符,当str字符中出现与oldValue字符相同的字符时进行拆分,拆分后返回后面的字符(遇到与oldValue的字符作废)
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.StringSplit(System.String,System.Char)">
            <summary>
            拆分str字符 ， 当str的字符内容中包含了split的字符则进行拆分进数组 ， 此方法只返回数组[0]的字符 (只有一行代码 return str.Split( split )[0];) ( str 要读取的全部字符串 , split 拆分符号或其他，当遇到这个字符即返回从开始到此字符的字段 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.StringSplitEndOne(System.String,System.Char)">
            <summary>
            拆分str字符 ， 当str的字符内容中包含了split的字符则进行拆分进数组 ， 此方法只返回数组[0]的字符 (只有一行代码 return str.Split( split )[array.Length-1];) ( str 要读取的全部字符串 , split 拆分符号或其他，当遇到这个字符即返回从开始到此字符的字段 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.StringSplitEndToOne(System.String,System.Char)">
            <summary>
            拆分字符串从0字符段开始读到出现split拆分字符后结束并返回当前段的字符 ( str 要读取的全部字符串 , split 拆分符号或其他，当遇到这个字符即返回从开始到此字符的字段 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.ToVector2_3_4(System.String,System.String)">
            <summary>
            字符转三维向量值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.ToRect(System.String,System.String)">
            <summary>
            字符转矩形值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.ToColor(System.String,System.String)">
            <summary>
            字符转颜色值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.ToQuaternion(System.String,System.String)">
            <summary>
            字符转欧拉角值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.To_Vector234_Rect_Quaternion_Color(System.String,System.String)">
            <summary>
            转换字符为Vector2 或 Vector3 或 Vector4 或 Rect 或 Quaternion 的值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.Vector2_3_4ToString(System.Object)">
            <summary>
            三维向量转完整字符 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.RectToString(System.Object)">
            <summary>
            字符转矩形值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.ColorToString(System.Object)">
            <summary>
            字符转颜色值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.QuaternionToString(System.Object)">
            <summary>
            字符转欧拉角值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.ConvertUtility.Vector234_Rect_Quaternion_ColorToString(System.Object)">
            <summary>
            将Vector2 或 Vector3 或 Vector4 或 Rect 或 Quaternion 的值转换成变量声明的完整字符 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:GameDesigner.CreateUtility.CreateInstance(System.String)">
            <summary>
            创建类对象实例
            </summary>
        </member>
        <member name="M:GameDesigner.CreateUtility.CreateInstance(System.Type)">
            <summary>
            创建类对象实例
            </summary>
        </member>
        <member name="M:GameDesigner.CreateUtility.CreateInstance(System.Type,System.Object[])">
            <summary>
            创建类对象实例
            </summary>
        </member>
        <member name="T:GameDesigner.Field">
            <summary>
            字段信息处理器
            </summary>
        </member>
        <member name="M:GameDesigner.Field.GetFields(System.Object)">
            <summary>
            获得所有字段信息 ( target 对象 )
            </summary>
        </member>
        <member name="M:GameDesigner.Field.GetFields(System.Type)">
            <summary>
            获得所有字段信息 ( type类名 )
            </summary>
        </member>
        <member name="M:GameDesigner.Field.Invoke(System.Object,GameDesigner.Field)">
            <summary>
            调用变量进行赋值 ( target 实体对象  , ifield 字段信息管理 )
            </summary>
        </member>
        <member name="M:GameDesigner.Field.InvokeField(System.Object,GameDesigner.Field)">
            <summary>
            调用变量进行赋值 ( target 实体对象  , ifield 字段信息管理 )
            </summary>
        </member>
        <member name="T:GameDesigner.FunBlockNode">
            <summary>
            蓝图功能块节点
            </summary>
        </member>
        <member name="T:GameDesigner.Method">
            <summary>
            方法信息处理器
            </summary>
        </member>
        <member name="F:GameDesigner.Method.typeName">
            编辑器扩展选择Types类型数组中的唯一一个数组索引
        </member>
        <member name="F:GameDesigner.Method._parameters">
            优化方法参数存储等待使用
        </member>
        <member name="F:GameDesigner.Method._parameterobjs">
            优化方法参数赋值存储等待使用
        </member>
        <member name="T:GameDesigner.Method.ValueModel">
            设置值或获得值模式--Invoke和Set是一样的,只是名称看起来哪个好些,Return和Get也是一样的
        </member>
        <member name="F:GameDesigner.Method.valueModel">
            设置值或获得值模式--Invoke和Set是一样的,只是名称看起来哪个好些,Return和Get也是一样的
        </member>
        <member name="M:GameDesigner.Method.GetMethods(System.Type)">
            <summary>
            获得所有方法信息 ( type 类型 )
            </summary>
        </member>
        <member name="M:GameDesigner.Method.Invoke(GameDesigner.Method)">
            <summary>
            方法自调 ( method 方法信息存储器--必须是完整的方法(包含对象,方法,参数) )
            </summary>
        </member>
        <member name="M:GameDesigner.Method.Invoke(System.Object,GameDesigner.Method)">
            <summary>
            调用唯一一个方法 , 使最优化，使尽可能有效 ( target 对象 , method 方法信息存储器--必须是完整的方法(方法,参数) )
            </summary>
        </member>
        <member name="M:GameDesigner.Method.Invoke(System.Object,GameDesigner.Method,System.Collections.Generic.List{GameDesigner.Parameter})">
            <summary>
            调用唯一一个方法 , 使最优化，使尽可能有效 ( target 实体对象  , method 方法信息存储器 , parameters 参数信息存储器 )
            </summary>
        </member>
        <member name="T:GameDesigner.Node">
            <summary>
            蓝图节点组件
            </summary>
        </member>
        <member name="M:GameDesigner.Node.CreateFunctionBody(GameDesigner.Blueprint,System.Type,System.String,System.String,System.String)">
            <summary>
            创建蓝图方法入口节点(简称节点入口)
            Designer 蓝图管理器,用来管理节点之间的连接
            Type 要获取的类型
            Fun name "获得类的方法名"，必须声明函数为公有才能获取成功
            Inherited name "继承类型名" ， 可以忽略，代码生成所用
            Node name 自定义节点介绍名称
            </summary>
        </member>
        <member name="M:GameDesigner.Node.Invoke">
            <summary>
            调用入口
            </summary>
        </member>
        <member name="T:GameDesigner.Parameter">
            <summary>
            参数管理类
            </summary>
        </member>
        <member name="T:GameDesigner.Property">
            <summary>
            属性信息处理器 -- 方法属性信息处理类，类似方法信息类
            </summary>
        </member>
        <member name="M:GameDesigner.Property.GetPropertys(System.Object)">
            <summary>
            获得所有方法信息,这个方法有可能是属性的定义Unity的Object类 ( target 对象 , not 查找方法时遇到的字符 , con 包含为真时，当方法出现与not字符相同时将才获取 )  当前为包含，包含就是遇到与not字符相同才获取
            </summary>
        </member>
        <member name="M:GameDesigner.Property.GetPropertys(System.Type)">
            <summary>
            获得所有方法信息 ( target 对象 , not 查找方法时遇到的字符 , con 包含为真时，当方法出现与not字符相同时才获取 )  当前为包含，包含就是遇到与not字符相同才获取
            </summary>
        </member>
        <member name="M:GameDesigner.Property.Invoke(System.Object,GameDesigner.Property)">
            <summary>
            调用变量进行赋值 ( target 实体对象  , ifield 字段信息管理 )
            </summary>
        </member>
        <member name="M:GameDesigner.Property.InvokeProperty(System.Object,GameDesigner.Property)">
            <summary>
            调用变量进行赋值 ( target 实体对象  , ifield 字段信息管理 )
            </summary>
        </member>
        <member name="T:GameDesigner.SystemType">
            <summary>
            插件系统类管理
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.GetType(System.String)">
            <summary>
            解释 : 获得应用程序当前已加载的所有程序集中查找typeName的类型
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.GetTypes(System.Action{System.Type[]})">
            <summary>
            获取所有在unity所引用的dll文件的类型，并通过types委托调用，types不是一次获取完所有dll文件的类型，而是一个dll文件获取完（所有类型）就执行一次委托
            </summary>
            <param name="types">单个dll文件的所有类型委托到types的参数中</param>
        </member>
        <member name="M:GameDesigner.SystemType.IsSubclassOf(System.Type,System.Type)">
            <summary>
            解释 : 判断type的基类是否是Typeof类型,是返回真,不是返回假
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.IsSubclassOfs(System.Type,System.Type)">
            <summary>
            解释 : 判断type所继承的类(基类)是否是Typeof类 和 Typeof所继承的类型(基类)是否是type类 , 是返回真,不是返回假
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.IsSubclassOf``1(System.Type)">
            <summary>
            解释 : 判断type的基类是否是Typeof类型,是返回真,不是返回假
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.StringToValue(System.String,System.String)">
            <summary>
            在监视面板显示类的值并且可视化修改 ( type 给定类型名称 , value 转换这个字符串为type类型的值 )
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.Instance``1(System.Object)">
            <summary>
            克隆对象, 脱离引用对象的地址
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:GameDesigner.SystemType.SetFieldValue(System.Object,System.Object)">
            <summary>
            设置类的变量值,解决派生类的值控制父类的变量值 ( 被赋值变量对象 , 赋值变量对象 ) [尽可能的使用此方法,此方法产生GC]
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.SetPropertyValue(System.Object,System.Object)">
            <summary>
            设置类的变量值,解决派生类的值控制父类的变量值 ( 被赋值变量对象 , 赋值变量对象 ) [尽可能的使用此方法,此方法产生GC]
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.SetFieldValue(System.Object,System.Object,System.String[],GameDesigner.SetValueModel)">
            <summary>
            设置类的变量值,解决派生类的值控制父类的变量值 ( 被赋值变量对象 , 赋值变量对象 , 不赋值的变量名数组 ) [尽可能的使用此方法,此方法产生GC]
            </summary>
        </member>
        <member name="M:GameDesigner.SystemType.SetFieldValue(System.Object,System.Object,System.Boolean)">
            <summary>
            设置类的变量值,解决派生类的值控制父类的变量值 ( 被赋值变量对象 , 赋值变量对象 ) [尽可能的使用此方法,此方法产生GC]
            </summary>
        </member>
        <member name="T:GameDesigner.TypeInfo">
            <summary>
            类信息处理器
            </summary>
        </member>
        <member name="M:GameDesigner.TypeInfo.UpdateCheckTypeInfo(GameDesigner.TypeInfo)">
            <summary>
            检查编辑器异动后进行更新类信息
            </summary>
        </member>
        <member name="M:GameDesigner.TypeInfo.InitTypeData(GameDesigner.TypeInfo)">
            <summary>
            初始化类的信息,此静态方法可以在Update运行
            </summary>
        </member>
        <member name="M:GameDesigner.TypeInfo.InitTypeInfo(GameDesigner.TypeInfo)">
            <summary>
            初始化类的信息
            </summary>
        </member>
        <member name="M:GameDesigner.TypeInfo.CreateInstance(GameDesigner.TypeInfo)">
            <summary>
            当对象为空时,创建new的对象
            </summary>
        </member>
        <member name="T:GameDesigner.ValueType">
            <summary>
            值存储管理类
            </summary>
        </member>
        <member name="P:GameDesigner.ValueType.TypeParameter.type">
            当参数类型为System.Type时使用
        </member>
        <member name="F:GameDesigner.ValueType.typeName">
            编辑器扩展选择Types类型数组中的唯一一个数组索引
        </member>
        <member name="T:GameDesigner.ActionBehaviour">
            <summary>
            动作行为--用户添加的组件 v2017/12/6
            </summary>
        </member>
        <member name="M:GameDesigner.ActionBehaviour.OnEnter(GameDesigner.StateAction)">
            <summary>
            当进入状态
            </summary>
            <param name="action">当前动作</param>
        </member>
        <member name="M:GameDesigner.ActionBehaviour.OnUpdate(GameDesigner.StateAction)">
            <summary>
            当更新状态
            </summary>
            <param name="action">当前动作</param>
        </member>
        <member name="M:GameDesigner.ActionBehaviour.OnExit(GameDesigner.StateAction)">
            <summary>
            当退出状态
            </summary>
            <param name="action">当前动作</param>
        </member>
        <member name="M:GameDesigner.ActionBehaviour.OnStop(GameDesigner.StateAction)">
            <summary>
            当停止动作 : 当动作不使用动画循环时, 动画时间到达100%后调用
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:GameDesigner.ActionBehaviour.OnAnimationEvent(GameDesigner.StateAction,System.Single)">
            <summary>
            当进入动画事件
            </summary>
            <param name="action">当前动作</param>
            <param name="animEventTime">动画事件时间</param>
        </member>
        <member name="M:GameDesigner.ActionBehaviour.OnInstantiateSpwan(GameDesigner.StateAction,UnityEngine.GameObject)">
            <summary>
            当实例化技能物体
            </summary>
            <param name="action">当前动作</param>
            <param name="spwan">技能物体</param>
        </member>
        <member name="T:GameDesigner.AudioManager">
            <summary>
            音效管理
            </summary>
        </member>
        <member name="P:GameDesigner.AudioManager.Instance">
            <summary>
            音效实例
            </summary>
        </member>
        <member name="M:GameDesigner.AudioManager.Play(UnityEngine.AudioClip)">
            <summary>
            播放音效剪辑
            参数clip : 放入你要播放的音源
            </summary>
        </member>
        <member name="M:GameDesigner.AudioManager.Play(UnityEngine.AudioClip,System.Single)">
            <summary>
            播放音效剪辑
            参数clip : 放入你要播放的音源
            参数volume : 声音大小调节
            </summary>
        </member>
        <member name="M:GameDesigner.AudioManager.Play(UnityEngine.AudioClip,System.Single,System.Boolean)">
            <summary>
            播放音效剪辑
            参数clip : 放入你要播放的音源
            参数volume : 声音大小调节
            </summary>
        </member>
        <member name="M:GameDesigner.AudioManager.OnPlayingDestroy(UnityEngine.AudioClip)">
            <summary>
            当音效播放完成销毁AudioSource组件
            参数clip : 放入你要播放的音源
            </summary>
        </member>
        <member name="M:GameDesigner.AudioManager.OnPlayingDestroy(UnityEngine.AudioClip,System.Single)">
            <summary>
            当音效播放完成销毁AudioSource组件
            参数clip : 放入你要播放的音源
            参数volume : 声音大小调节
            </summary>
        </member>
        <member name="M:GameDesigner.AudioManager.OnPlayingDestroy(UnityEngine.AudioSource,UnityEngine.AudioClip)">
            <summary>
            当音效播放完成销毁AudioSource组件
            参数clip : 放入你要播放的音源
            参数source : 音频源组件
            </summary>
        </member>
        <member name="T:GameDesigner.IBehaviour">
            <summary>
            状态行为基类 2019.3.3
            </summary>
        </member>
        <member name="F:GameDesigner.IBehaviour.show">
            <summary>
            展开编辑器检视面板
            </summary>
        </member>
        <member name="F:GameDesigner.IBehaviour.Active">
            <summary>
            脚本是否启用?
            </summary>
        </member>
        <member name="P:GameDesigner.IBehaviour.state">
            <summary>
            当前状态
            </summary>
        </member>
        <member name="P:GameDesigner.IBehaviour.transform">
            <summary>
            状态管理器转换组建
            </summary>
        </member>
        <member name="M:GameDesigner.IBehaviour.OnInit">
            <summary>
            当初始化调用
            </summary>
        </member>
        <member name="M:GameDesigner.IBehaviour.OnDestroyComponent">
            <summary>
            当组件被删除调用一次
            </summary>
        </member>
        <member name="M:GameDesigner.IBehaviour.OnInspectorGUI(GameDesigner.State)">
            <summary>
            当绘制编辑器检视面板 (重要提示!你想自定义编辑器检视面板则返回真,否则显示默认编辑器检视面板)
            </summary>
            <param name="state">当前状态</param>
            <returns></returns>
        </member>
        <member name="M:GameDesigner.IBehaviour.EnterState(System.Int32)">
            <summary>
            进入下一个状态, 如果状态正在播放就不做任何处理, 如果想让动作立即播放可以使用 OnEnterNextState 方法
            </summary>
            <param name="stateID"></param>
        </member>
        <member name="M:GameDesigner.IBehaviour.OnEnterNextState(System.Int32)">
            <summary>
            当进入下一个状态, 你也可以立即进入当前播放的状态, 如果不想进入当前播放的状态, 使用StatusEntry方法
            </summary>
            <param name="stateID">下一个状态的ID</param>
        </member>
        <member name="T:GameDesigner.IState">
            <summary>
            状态基类
            </summary>
        </member>
        <member name="F:GameDesigner.IState.findBehaviours">
            <summary>
            查找行为组件
            </summary>
        </member>
        <member name="F:GameDesigner.IState.makeTransition">
            <summary>
            绘制状态连接线条
            </summary>
        </member>
        <member name="F:GameDesigner.IState.makeGetValueTransition">
            <summary>
            绘制蓝图获得值线条
            </summary>
        </member>
        <member name="F:GameDesigner.IState.makeRuntimeTransition">
            <summary>
            绘制蓝图运行下一个节点线条
            </summary>
        </member>
        <member name="F:GameDesigner.IState.makeOutRuntimeTransition">
            <summary>
            绘制蓝图运行线条
            </summary>
        </member>
        <member name="F:GameDesigner.IState.createScriptName">
            <summary>
            创建脚本名称
            </summary>
        </member>
        <member name="F:GameDesigner.IState.StateActionScriptPath">
            <summary>
            创建脚本路径
            </summary>
        </member>
        <member name="F:GameDesigner.IState.StateBehaviourScriptPath">
            <summary>
            创建脚本路径
            </summary>
        </member>
        <member name="F:GameDesigner.IState.TransitionScriptPath">
            <summary>
            创建脚本路径
            </summary>
        </member>
        <member name="F:GameDesigner.IState.foldout">
            <summary>
            展开编辑器 和 添加脚本编译状态
            </summary>
        </member>
        <member name="F:GameDesigner.IState.compiling">
            <summary>
            展开编辑器 和 添加脚本编译状态
            </summary>
        </member>
        <member name="F:GameDesigner.IState.behaviourMenuIndex">
            <summary>
            右键行为脚本存储行为的索引 和 动作菜单索引
            </summary>
        </member>
        <member name="F:GameDesigner.IState.actionMenuIndex">
            <summary>
            右键行为脚本存储行为的索引 和 动作菜单索引
            </summary>
        </member>
        <member name="F:GameDesigner.IState.rect">
            <summary>
            蓝图 和 状态 的编辑器矩形
            </summary>
        </member>
        <member name="T:GameDesigner.AnimationMode">
            <summary>
            动画模式
            </summary>
        </member>
        <member name="F:GameDesigner.AnimationMode.Animation">
            <summary>
            旧版动画
            </summary>
        </member>
        <member name="F:GameDesigner.AnimationMode.Animator">
            <summary>
            新版动画
            </summary>
        </member>
        <member name="T:GameDesigner.State">
            <summary>
            状态 -- v2017/12/6
            </summary>
        </member>
        <member name="F:GameDesigner.State.transitions">
            <summary>
            状态连接集合
            </summary>
        </member>
        <member name="F:GameDesigner.State.behaviours">
            <summary>
            状态行为集合
            </summary>
        </member>
        <member name="F:GameDesigner.State.actionSystem">
            <summary>
            动作系统 使用为真 , 不使用为假
            </summary>
        </member>
        <member name="F:GameDesigner.State.animLoop">
            <summary>
            动画循环?
            </summary>
        </member>
        <member name="F:GameDesigner.State.animPlayMode">
            <summary>
            动画模式
            </summary>
        </member>
        <member name="F:GameDesigner.State.actionIndex">
            <summary>
            动作索引
            </summary>
        </member>
        <member name="F:GameDesigner.State.audioIndex">
            <summary>
            音效索引
            </summary>
        </member>
        <member name="F:GameDesigner.State.animSpeed">
            <summary>
            动画速度
            </summary>
        </member>
        <member name="F:GameDesigner.State.isExitState">
            <summary>
            动画结束是否进入下一个状态
            </summary>
        </member>
        <member name="F:GameDesigner.State.DstStateID">
            <summary>
            动画结束进入下一个状态的ID
            </summary>
        </member>
        <member name="F:GameDesigner.State.actions">
            <summary>
            状态动作集合
            </summary>
        </member>
        <member name="M:GameDesigner.State.CreateStateInstance(GameDesigner.StateMachine,System.String,UnityEngine.Vector2)">
            <summary>
            创建状态
            </summary>
        </member>
        <member name="M:GameDesigner.State.#ctor(GameDesigner.StateMachine)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:GameDesigner.State.Action">
            <summary>
            当前状态动作
            </summary>
        </member>
        <member name="M:GameDesigner.State.OnEnterState">
            <summary>
            进入状态
            </summary>
        </member>
        <member name="M:GameDesigner.State.OnUpdateState">
            <summary>
            状态每一帧
            </summary>
        </member>
        <member name="M:GameDesigner.State.SetPosition(GameDesigner.StateManager,UnityEngine.GameObject)">
            <summary>
            设置技能位置
            </summary>
        </member>
        <member name="M:GameDesigner.State.InstantiateSpwan(GameDesigner.StateManager)">
            <summary>
            技能实例化
            </summary>
        </member>
        <member name="M:GameDesigner.State.OnExitState">
            <summary>
            当退出状态
            </summary>
        </member>
        <member name="M:GameDesigner.State.OnActionExit">
            <summary>
            当子动作处于循环播放模式时, 子动作每次播放完成动画都会调用一次
            </summary>
        </member>
        <member name="M:GameDesigner.State.OnStop">
            <summary>
            当动作停止
            </summary>
        </member>
        <member name="T:GameDesigner.AnimPlayMode">
            <summary>
            动画播放模式
            </summary>
        </member>
        <member name="F:GameDesigner.AnimPlayMode.Random">
            <summary>
            随机播放动画
            </summary>
        </member>
        <member name="F:GameDesigner.AnimPlayMode.Sequence">
            <summary>
            顺序播放动画
            </summary>
        </member>
        <member name="T:GameDesigner.AudioMode">
            <summary>
            音效模式
            </summary>
        </member>
        <member name="F:GameDesigner.AudioMode.EnterPlay">
            <summary>
            进入状态播放音效
            </summary>
        </member>
        <member name="F:GameDesigner.AudioMode.AnimEvent">
            <summary>
            动画事件播放音效
            </summary>
        </member>
        <member name="F:GameDesigner.AudioMode.ExitPlay">
            <summary>
            退出状态播放音效
            </summary>
        </member>
        <member name="T:GameDesigner.ActiveMode">
            <summary>
            技能生成模式
            </summary>
        </member>
        <member name="F:GameDesigner.ActiveMode.Instantiate">
            <summary>
            实例化
            </summary>
        </member>
        <member name="F:GameDesigner.ActiveMode.ObjectPool">
            <summary>
            对象池
            </summary>
        </member>
        <member name="T:GameDesigner.SpwanMode">
            <summary>
            技能物体设置模式
            </summary>
        </member>
        <member name="F:GameDesigner.SpwanMode.localPosition">
            <summary>
            设置技能物体在自身位置
            </summary>
        </member>
        <member name="F:GameDesigner.SpwanMode.SetParent">
            <summary>
            设置技能物体在父对象位置和成为父对象的子物体
            </summary>
        </member>
        <member name="F:GameDesigner.SpwanMode.SetInTargetPosition">
            <summary>
            设置技能物体在父对象位置
            </summary>
        </member>
        <member name="T:GameDesigner.StateAction">
            <summary>
            ARPG状态动作
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.clipName">
            <summary>
            动画剪辑名称
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.clipIndex">
            <summary>
            动画剪辑索引
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.animTime">
            <summary>
            当前动画时间
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.animEventTime">
            <summary>
            动画事件时间
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.animTimeMax">
            <summary>
            动画结束时间
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.eventEnter">
            <summary>
            是否已到达事件时间或超过事件时间，到为true，没到为flase
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.effectSpwan">
            <summary>
            技能粒子物体
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.activeMode">
            <summary>
            粒子物体生成模式
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.spwanTime">
            <summary>
            粒子物体销毁或关闭时间
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.activeObjs">
            <summary>
            粒子物体对象池
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.spwanmode">
            <summary>
            粒子位置设置
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.parent">
            <summary>
            作为粒子挂载的父对象 或 作为粒子生成在此parent对象的位置
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.effectPostion">
            <summary>
            粒子出生位置
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.effectEulerAngles">
            <summary>
            粒子角度
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.isPlayAudio">
            <summary>
            是否播放音效
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.audioModel">
            <summary>
            音效触发模式
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.audioClips">
            <summary>
            音效剪辑
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.behaviours">
            <summary>
            ARPG动作行为
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.foldout">
            <summary>
            编辑器脚本是否展开 编辑器音效是否展开 查找行为组件
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.audiofoldout">
            <summary>
            编辑器脚本是否展开 编辑器音效是否展开 查找行为组件
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.findBehaviours">
            <summary>
            编辑器脚本是否展开 编辑器音效是否展开 查找行为组件
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.desAudioIndex">
            <summary>
            删除音效索引 行为脚本菜单索引
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.behaviourMenuIndex">
            <summary>
            删除音效索引 行为脚本菜单索引
            </summary>
        </member>
        <member name="F:GameDesigner.StateAction.createScriptName">
            <summary>
            创建脚本名称
            </summary>
        </member>
        <member name="P:GameDesigner.StateAction.IsComplete">
            <summary>
            动作是否完成?, 当动画播放结束后为True, 否则为false
            </summary>
        </member>
        <member name="M:GameDesigner.StateAction.#ctor">
            <summary>
            构造状态动作
            </summary>
        </member>
        <member name="T:GameDesigner.StateBehaviour">
            <summary>
            状态行为脚本 v2017/12/6 - 2020.6.7
            </summary>
        </member>
        <member name="M:GameDesigner.StateBehaviour.OnEnter">
            <summary>
            当状态进入时
            </summary>
        </member>
        <member name="M:GameDesigner.StateBehaviour.OnUpdate">
            <summary>
            当状态每一帧
            </summary>
        </member>
        <member name="M:GameDesigner.StateBehaviour.OnExit">
            <summary>
            当状态退出后
            </summary>
        </member>
        <member name="M:GameDesigner.StateBehaviour.OnStop">
            <summary>
            当停止动作 : 当动作不使用动画循环时, 动画时间到达100%后调用
            </summary>
        </member>
        <member name="M:GameDesigner.StateBehaviour.OnActionExit">
            <summary>
            当动作处于循环模式时, 子动作动画每次结束都会调用一次
            </summary>
            <param name="state"></param>
        </member>
        <member name="T:GameDesigner.StateMachine">
            <summary>
            状态机 v2017/12/6
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.defaulID">
            <summary>
            默认状态ID
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.stateID">
            <summary>
            当前运行的状态索引
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.states">
            <summary>
            所有状态
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.selectStates">
            <summary>
            选中的状态,可以多选
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.animMode">
            <summary>
            动画选择模式
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.animation">
            <summary>
            旧版动画组件
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.animator">
            <summary>
            新版动画组件
            </summary>
        </member>
        <member name="F:GameDesigner.StateMachine.clipNames">
            <summary>
            动画剪辑
            </summary>
        </member>
        <member name="P:GameDesigner.StateMachine.Item(System.Int32)">
            <summary>
            以状态ID取出状态对象
            </summary>
            <param name="stateID"></param>
            <returns></returns>
        </member>
        <member name="P:GameDesigner.StateMachine.defaultState">
            <summary>
            获取 或 设置 默认状态
            </summary>
        </member>
        <member name="P:GameDesigner.StateMachine.currState">
            <summary>
            当前状态
            </summary>
        </member>
        <member name="P:GameDesigner.StateMachine.selectState">
            <summary>
            选择的状态
            </summary>
        </member>
        <member name="P:GameDesigner.StateMachine.stateManager">
            <summary>
            状态管理
            </summary>
        </member>
        <member name="M:GameDesigner.StateMachine.CreateStateMachineInstance(System.String)">
            <summary>
            创建状态机实例
            </summary>
            <param name="name">状态机名称</param>
            <returns></returns>
        </member>
        <member name="T:GameDesigner.StateManager">
            <summary>
            状态执行管理类
            V2017.12.6
            版本修改V2019.8.27
            </summary>
        </member>
        <member name="F:GameDesigner.StateManager.stateMachine">
            <summary>
            状态机
            </summary>
        </member>
        <member name="M:GameDesigner.StateManager.OnState(GameDesigner.State)">
            <summary>
            处理状态各种行为与事件方法
            </summary>
            <param name="state">要执行的状态</param>
        </member>
        <member name="M:GameDesigner.StateManager.OnTransition(GameDesigner.Transition)">
            <summary>
            处理连接行为线条方法
            </summary>
            <param name="transition">要执行的连接线条</param>
        </member>
        <member name="M:GameDesigner.StateManager.OnStateTransitionExit(GameDesigner.State)">
            <summary>
            当退出状态时处理连接事件
            </summary>
            <param name="state">要退出的状态</param>
        </member>
        <member name="M:GameDesigner.StateManager.EnterNextState(GameDesigner.State,GameDesigner.State)">
            <summary>
            当进入下一个状态
            </summary>
            <param name="currState">当前状态</param>
            <param name="enterState">要进入的状态</param>
        </member>
        <member name="M:GameDesigner.StateManager.EnterNextState(System.Int32)">
            <summary>
            当进入下一个状态, 你也可以立即进入当前播放的状态, 如果不想进入当前播放的状态, 使用StatusEntry方法
            </summary>
            <param name="nextStateIndex">下一个状态的ID</param>
        </member>
        <member name="M:GameDesigner.StateManager.StatusEntry(System.Int32)">
            <summary>
            进入下一个状态, 如果状态正在播放就不做任何处理, 如果想让动作立即播放可以使用 OnEnterNextState 方法
            </summary>
            <param name="stateID"></param>
        </member>
        <member name="T:GameDesigner.StateSystem">
            <summary>
            状态机系统
            </summary>
        </member>
        <member name="F:GameDesigner.StateSystem.CopyComponent">
            <summary>
            状态机复制组件
            </summary>
        </member>
        <member name="F:GameDesigner.StateSystem.Component">
            <summary>
            状态机新型复制组件
            </summary>
        </member>
        <member name="T:GameDesigner.Transition">
            <summary>
            状态连接组件 2017年12月6日
            版本修改2019.8.27
            </summary>
        </member>
        <member name="P:GameDesigner.Transition.currState">
            <summary>
            当前状态
            </summary>
        </member>
        <member name="P:GameDesigner.Transition.nextState">
            <summary>
            下一个状态
            </summary>
        </member>
        <member name="F:GameDesigner.Transition.model">
            <summary>
            连接控制模式
            </summary>
        </member>
        <member name="F:GameDesigner.Transition.time">
            <summary>
            当前时间
            </summary>
        </member>
        <member name="F:GameDesigner.Transition.exitTime">
            <summary>
            结束时间
            </summary>
        </member>
        <member name="F:GameDesigner.Transition.behaviours">
            <summary>
            连接行为
            </summary>
        </member>
        <member name="F:GameDesigner.Transition.isEnterNextState">
            <summary>
            是否进入下一个状态?
            </summary>
        </member>
        <member name="M:GameDesigner.Transition.CreateTransitionInstance(GameDesigner.State,GameDesigner.State,System.String)">
            <summary>
            创建连接实例
            </summary>
            <param name="state">连接的开始状态</param>
            <param name="nextState">连接的结束状态</param>
            <param name="transitionName">连接名称</param>
            <returns></returns>
        </member>
        <member name="T:GameDesigner.TransitionBehaviour">
            <summary>
            连接行为--用户可以继承此类添加组件 2017年12月6日(星期三)
            </summary>
        </member>
        <member name="T:GameDesigner.TransitionModel">
            <summary>
            状态过渡事件选项模式
            </summary>
        </member>
        <member name="F:GameDesigner.TransitionModel.ExitTime">
            <summary>
            用时间来跳转状态
            </summary>
        </member>
        <member name="F:GameDesigner.TransitionModel.ScriptControl">
            <summary>
            代码控制条件跳转
            </summary>
        </member>
        <member name="F:Operator.Adds">
            加法运算符%
        </member>
        <member name="F:Operator.Subtracts">
            减法运算符%
        </member>
        <member name="F:Operator.Multiplies">
            乘法运算符%
        </member>
        <member name="F:Operator.Divides">
            除法运算符%
        </member>
        <member name="F:Operator.BaiFeiBi100">
            百分比运算符%
        </member>
        <member name="F:Operator.QiuYu">
            求余运算符^
        </member>
        <!-- Badly formed XML comment ignored for member "F:Operator.BinQie" -->
        <member name="T:Net.AOI.Grid">
            <summary>
            格子类
            </summary>
        </member>
        <member name="M:Net.AOI.Grid.GetGridBodiesAll">
            <summary>
            获取九宫格的所有物体
            </summary>
            <returns></returns>
        </member>
        <member name="T:Net.AOI.GridManager">
            <summary>
            九宫格网络同步管理器
            </summary>
        </member>
        <member name="M:Net.AOI.GridManager.Init(System.Single,System.Single,System.UInt32,System.UInt32,System.Int32,System.Int32)">
            <summary>
            初始化九宫格
            </summary>
            <param name="xPos">x开始位置</param>
            <param name="zPos">z开始位置</param>
            <param name="xMax">x列最大值</param>
            <param name="zMax">z列最大值</param>
            <param name="width">格子长度</param>
            <param name="height">格子高度</param>
        </member>
        <member name="M:Net.AOI.GridManager.Insert(Net.AOI.IGridBody)">
            <summary>
            插入物体到九宫格感兴趣区域
            </summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:Net.AOI.GridManager.TryGetGrid(Net.AOI.IGridBody)">
            <summary>
            获取物体的感兴趣九宫格区域
            </summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:Net.AOI.GridManager.Remove(Net.AOI.IGridBody)">
            <summary>
            移除感兴趣物体
            </summary>
            <param name="body"></param>
        </member>
        <member name="M:Net.AOI.GridManager.UpdateHandler">
            <summary>
            更新感兴趣的移除和添加物体
            </summary>
        </member>
        <member name="T:Net.AOI.IGridBody">
            <summary>
            九宫格格子物体接口
            </summary>
        </member>
        <member name="M:Net.AOI.IGridBody.OnEnter(Net.AOI.IGridBody)">
            <summary>
            当物体进入感兴趣区域
            </summary>
        </member>
        <member name="M:Net.AOI.IGridBody.OnExit(Net.AOI.IGridBody)">
            <summary>
            当物体退出感兴趣区域
            </summary>
        </member>
        <member name="T:Net.Clone">
            <summary>
            克隆工具类
            </summary>
        </member>
        <member name="M:Net.Clone.Instance``1(System.Object)">
            <summary>
            克隆对象, 脱离引用对象的地址
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Clone.Copy``1(System.Object)">
            <summary>
            贱复制
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Clone.DeepCopy``1(System.Object)">
            <summary>
            深复制
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Clone.DeepCopy(System.Object)">
            <summary>
            深复制
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Clone.DeepCopy(System.Type,System.Object)">
            <summary>
            深复制
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Component.Command">
            <summary>
            网络操作指令
            </summary>
        </member>
        <member name="F:Net.Component.Command.SyncOperations">
            <summary>
            帧同步操作命令
            </summary>
        </member>
        <member name="F:Net.Component.Command.Input">
            <summary>
            客户端输入操作指令
            </summary>
        </member>
        <member name="F:Net.Component.Command.Movement">
            <summary>
            玩家运动命令
            </summary>
        </member>
        <member name="F:Net.Component.Command.CreatePlayer">
            <summary>
            创建玩家命令
            </summary>
        </member>
        <member name="F:Net.Component.Command.Attack">
            <summary>
            玩家攻击命令
            </summary>
        </member>
        <member name="F:Net.Component.Command.SyncHealth">
            <summary>
            同步生命值
            </summary>
        </member>
        <member name="F:Net.Component.Command.Damage">
            <summary>
            玩家攻击到敌人
            </summary>
        </member>
        <member name="F:Net.Component.Command.EnemySync">
            <summary>
            敌人怪物AI同步指令
            </summary>
        </member>
        <member name="F:Net.Component.Command.SwitchState">
            <summary>
            玩家切换状态
            </summary>
        </member>
        <member name="F:Net.Component.Command.EnemySwitchState">
            <summary>
            怪物切换状态
            </summary>
        </member>
        <member name="F:Net.Component.Command.Transform">
            <summary>
            TransformComponent组件测试指令
            </summary>
        </member>
        <member name="F:Net.Component.Command.Destroy">
            <summary>
            TransformComponent组件被销毁指令
            </summary>
        </member>
        <member name="F:Net.Component.Command.Animator">
            <summary>
            新版动画同步命令
            </summary>
        </member>
        <member name="F:Net.Component.Command.AnimatorParameter">
            <summary>
            新版动画参数同步命令
            </summary>
        </member>
        <member name="F:Net.Component.Command.Animation">
            <summary>
            旧版动画同步命令
            </summary>
        </member>
        <member name="T:Net.Component.NTransform">
            <summary>
            游戏物体转换实体组建
            作者:彼岸流年  QQ:317392507
            后期修改:龙兄 QQ:1752062104
            </summary>
        </member>
        <member name="T:Net.Component.RoomData">
            <summary>
            房间数据信息
            </summary>
        </member>
        <member name="F:Net.Component.RoomData.name">
            <summary>
            房间名称
            </summary>
        </member>
        <member name="F:Net.Component.RoomData.num">
            <summary>
            房间可以组队人数
            </summary>
        </member>
        <member name="F:Net.Component.RoomData.currNum">
            <summary>
            当前加入房间人数
            </summary>
        </member>
        <member name="F:Net.Component.RoomData.state">
            <summary>
            房间的状态
            </summary>
        </member>
        <member name="F:Net.Component.RoomData.mode">
            <summary>
            竞技模式 1:个人 2:团队
            </summary>
        </member>
        <member name="T:Net.Adapter.CallSiteRpcAdapter`1">
            <summary>
            服务器远程过程调用适配器
            </summary>
            <typeparam name="Player"></typeparam>
        </member>
        <member name="T:Net.Adapter.CallSiteRpcAdapter">
            <summary>
            客户端远程过程调用适配器
            </summary>
        </member>
        <member name="T:Net.Adapter.ListenerAdapter">
            <summary>
            网络事件监听适配器
            </summary>
        </member>
        <member name="T:Net.Adapter.SerializeFastAdapter">
            <summary>
            通用升级版适配器
            </summary>
        </member>
        <member name="T:Net.Adapter.SerializeAdapter">
            <summary>
            快速序列化适配器
            </summary>
        </member>
        <member name="T:Net.Adapter.SerializeAdapter2">
            <summary>
            快速序列化2适配器
            </summary>
        </member>
        <member name="T:Net.Adapter.SerializeAdapter3">
            <summary>
            极速序列化3适配器
            </summary>
        </member>
        <member name="T:Net.Client.ClientBase">
            <summary>
            网络客户端核心基类 2019.3.3
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.Client">
            <summary>
            UDP客户端套接字
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.host">
            <summary>
            IP地址
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.port">
            <summary>
            端口号
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.rPCModels">
            <summary>
            发送缓存器
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.rtRPCModels">
            <summary>
            可靠传输缓冲器
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.revdBuffers">
            <summary>
            接收缓存器
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.Rpcs">
            <summary>
            网络委托函数 主要用于 unity 面板查看
            </summary>
            <returns></returns>
        </member>
        <member name="F:Net.Client.ClientBase.RpcsDic">
            <summary>
            远程方法优化字典
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.RpcMaskDic">
            <summary>
            远程方法遮罩
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.threadDic">
            <summary>
            线程字典
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.NetworkState">
            <summary>
            网络连接状态
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.Connected">
            <summary>
            服务器与客户端是否是连接状态
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.Instance">
            <summary>
            网络客户端实例
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.ThrowException">
            <summary>
            输出调用RPC错误级别,红色警告 (仅限编辑器调式使用!)
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.UseUnityThread">
            <summary>
            是否使用unity主线程进行每一帧更新？  
            True：使用unity的Update等方法进行更新，unity的组建可以在Rpc函数内进行调用。
            False：使用多线程进行网络更新，使用多线程更新后unity的组件将不能在rpc函数内进行赋值设置等操作，否则会出现错误问题!
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.networkState">
            <summary>
            当前客户端网络状态
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.currFrequency">
            <summary>
            当前尝试重连次数
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.sendCount">
            <summary>
            每秒发送数据长度
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.sendAmount">
            <summary>
            每秒发送数据次数
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.resolveAmount">
            <summary>
            每秒解析rpc函数次数
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.receiveAmount">
            <summary>
            每秒接收网络数据次数
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.receiveCount">
            <summary>
            每秒接收网络数据大小
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.sendLoopNum">
            <summary>
            发送线程循环次数
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.revdLoopNum">
            <summary>
            接收线程循环次数 只有ENetServer
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.heart">
            <summary>
            心跳次数
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.openClient">
            <summary>
            当前客户端是否打开(运行)
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.LogRpc">
            <summary>
            输出调用网络函数
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.Log">
            <summary>
            输出日志, 这里是输出全部日志(提示,警告,错误等信息). 如果想只输出指定的日志, 请使用NDebug类进行输出
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnConnectedHandle">
            <summary>
            当连接服务器成功事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnConnectFailedHandle">
            <summary>
            当连接失败事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnTryToConnectHandle">
            <summary>
            当尝试连接服务器事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnConnectLostHandle">
            <summary>
            当连接中断 (异常) 事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnDisconnectHandle">
            <summary>
            当断开连接事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnRevdBufferHandle">
            <summary>
            当接收到自定义的cmd指令时调用事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnReconnectHandle">
            <summary>
            当断线重连成功触发事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnCloseConnectHandle">
            <summary>
            当关闭连接事件
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnNetworkDataTraffic">
            <summary>
            当统计网络流量时触发
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnExceededNumberHandle">
            <summary>
            当服务器连接人数溢出(未知客户端连接总数), 服务器忽略当前客户端的所有Rpc请求时调用
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnBlockConnectionHandle">
            <summary>
            当服务器在线人数爆满, 服务器忽略当前客户端的所有Rpc请求时调用
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnOperationSync">
            <summary>
            当使用服务器的NetScene.AddOperation方法时调用， 场景内的所有演员行为同步
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnRevdRTProgress">
            <summary>
            当服务器发送的大数据时, 可监听此事件显示进度值
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnSendRTProgress">
            <summary>
            当客户端发送可靠数据时, 可监听此事件显示进度值 (NetworkClient,TcpClient类无效)
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.OnAddRpcHandle">
            <summary>
            当添加远程过程调用方法时调用， 参数1：要收集rpc特性的对象， 参数2：如果客户端的rpc列表中已经有了这个对象，还可以添加进去？
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.OnRemoveRpc">
            <summary>
            当移除远程过程调用对象， 参数1：移除此对象的所有rpc方法
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.OnRPCExecute">
            <summary>
            当执行调用远程过程方法时触发
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnCheckRpcUpdate">
            <summary>
            检查rpc对象，如果对象被释放则自动移除
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnSerializeRPC">
            <summary>
            当内核序列化远程函数时调用, 如果想改变内核rpc的序列化方式, 可重写定义序列化协议 (只允许一个委托, 例子:OnSerializeRpcHandle = (model)=>{return new byte[0];};)
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnDeserializeRPC">
            <summary>
            当内核解析远程过程函数时调用, 如果想改变内核rpc的序列化方式, 可重写定义解析协议 (只允许一个委托, 例子:OnDeserializeRpcHandle = (buffer)=>{return new FuncData();};)
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnSerializeOPT">
            <summary>
            当内部序列化帧操作列表时调用, 即将发送数据  !!!!!!!只允许一个委托
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnDeserializeOPT">
            <summary>
            当内部解析帧操作列表时调用  !!!!!只允许一个委托
            </summary>
        </member>
        <member name="E:Net.Client.ClientBase.OnPingCallback">
            <summary>
            ping服务器回调 参数double为延迟毫秒单位 当RTOMode属性为可变重传时, 内核将会每秒自动ping一次
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnSendErrorHandle">
            <summary>
            当socket发送失败调用. 参数1:发送的字节数组, 参数2:发送标志(可靠和不可靠)  ->可通过SendByteData方法重新发送
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnP2PCallback">
            <summary>
            当从服务器获取的客户端地址点对点
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.OnSwitchPortHandle">
            <summary>
            当网关服务器指定这个客户端连接到一个游戏服务器时调用,回调有游戏服务器的ip和端口
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.sendRTList">
            <summary>
            发送可靠传输缓冲
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.revdRTList">
            <summary>
            接收可靠传输缓冲
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.sendRTListCount">
            <summary>
            可靠传输最大值
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.fileStreamName">
            <summary>
            可靠传输流文件名称
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.revdRTStream">
            <summary>
            可靠传输文件流对象
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.frame">
            <summary>
            帧尾或叫数据长度(4) + 2CRC协议 = 6
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.HeartInterval">
            <summary>
            心跳时间间隔, 默认每1秒检查一次玩家是否离线, 玩家心跳确认为5次, 如果超出5次 则移除玩家客户端. 确认玩家离线总用时5秒, 
            如果设置的值越小, 确认的速度也会越快. 值太小有可能出现直接中断问题, 设置的最小值在100以上
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.HeartLimit">
            <summary>
            <para>心跳检测次数, 默认为5次检测, 如果5次发送心跳给客户端或服务器, 没有收到回应的心跳包, 则进入断开连接处理</para>
            <para>当一直有数据往来时是不会发送心跳数据的, 只有当没有数据往来了, 才会进入发送心跳数据</para>
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.Identify">
            <summary>
            客户端唯一标识, 当登录游戏后, 服务器下发下来的唯一标识, 这个标识就是你的玩家名称, 是NetPlayer.playerID值
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.UID">
            <summary>
            用户唯一标识, 对应服务器的NetPlayer.UID
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.SyncFrequency">
            <summary>
            网络数据发送频率, 大概每秒发送1000个数据
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.Context">
            <summary>
            在多线程调用unity主线程的上下文对象
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.StackBufferSize">
            <summary>
            允许叠包缓冲器最大值 默认可发送5242880(5M)的数据包
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.StackNumberMax">
            <summary>
            允许叠包最大次数，如果数据包太大，接收数据的次数超出StackNumberMax值，则会清除叠包缓存器 默认可叠包50次
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.stack">
            <summary>
            TCP叠包值， 0:正常 >1:叠包次数 > StackNumberMax :清空叠包缓存流
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.StackStream">
            <summary>
            TCP叠包临时缓存流
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.OperationSyncInThread">
            <summary>
            在多线程中调用OperationSync事件?
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.SendOperationReliable">
            <summary>
            玩家操作是以可靠传输进行发送的?     
            服务器的对应属性SendOperationReliable在 NetScene类里面
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.operations">
            <summary>
            待发送的操作列表
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.MTU">
            <summary>
            <para>（Maxium Transmission Unit）最大传输单元, 最大传输单元为1500字节, 这里默认为50000, 如果数据超过50000,则是该框架进行分片. 传输层则需要分片为50000/1472=34个数据片</para>
            <para>------ 局域网可以设置为50000, 公网需要设置为1300 或 1400, 如果设置为1400还是发送失败, 则需要设置为1300或以下进行测试 ------</para>
            <para>1.链路层：以太网的数据帧的长度为(64+18)~(1500+18)字节，其中18是数据帧的帧头和帧尾，所以数据帧的内容最大为1500字节（不包括帧头和帧尾），即MUT为1500字节</para>
            <para>2.网络层：IP包的首部要占用20字节，所以这里的MTU＝1500－20＝1480字节</para>
            <para>3.传输层：UDP包的首部要占有8字节，所以这里的MTU＝1480－8＝1472字节</para>
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.RTO">
            <summary>
            （Retransmission TimeOut）重传超时时间。 默认为20毫秒重传一次
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.RTOMode">
            <summary>
            超时重传模式 默认为可变重传
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.MTPS">
            <summary>
            (Maximum traffic per second) 每秒允许传输最大流量, 默认最大每秒可以传输1m大小
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.localPort">
            <summary>
            客户端端口
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.sendReliableFrame">
            <summary>
            当前可靠帧, 比如服务器发送两帧可靠数据帧给客户端, 客户端只需要收到一个帧数据即可 (发送帧)
            </summary>
        </member>
        <member name="F:Net.Client.ClientBase.revdReliableFrame">
            <summary>
            当前可靠帧, 比如服务器发送两帧可靠数据帧给客户端, 客户端只需要收到一个帧数据即可 (接收帧)
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.ByteCompression">
            <summary>
            使用字节压缩吗? 如果使用, 每次发送字节大于1000个后进行压缩处理
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.Seqencing">
            <summary>
            可靠传输是排队模式? 排队模式下, 可靠包是一个一个处理. 不排队模式: 可靠传输数据组成多列并发 ---> 默认是无排队模式
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.IsEthernet">
            <summary>
            是以太网? 此属性控制组包发送时,执行一次能把n个数据包组合在一起, 然后一次发送, 全由数据包大小决定. 如果此属性是以太网(true), 则根据mut来判断, 否则是局域网, 固定值50000字节
            </summary>
        </member>
        <member name="P:Net.Client.ClientBase.PackageLength">
            <summary>
            组包数量，如果是一些小数据包，最多可以组合多少个？ 默认是组合1000个后发送
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.#ctor(System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="useUnityThread">
            是否使用unity主线程进行每一帧更新？  
            True：使用unity的Update等方法进行更新，unity的组建可以在Rpc函数内进行调用。
            False：使用多线程进行网络更新，使用多线程更新后unity的组件将不能在rpc函数内进行赋值设置等操作，否则会无效
            </param>
        </member>
        <member name="M:Net.Client.ClientBase.AddRpcHandle(System.Object)">
            <summary>
            添加网络Rpc
            </summary>
            <param name="target">注册的对象实例</param>
        </member>
        <member name="M:Net.Client.ClientBase.AddRpcHandle(System.Object,System.Boolean)">
            <summary>
            添加网络Rpc
            </summary>
            <param name="target">注册的对象实例</param>
            <param name="append">一个Rpc方法是否可以多次添加到Rpcs里面？</param>
        </member>
        <member name="M:Net.Client.ClientBase.RemoveRpc(System.Object)">
            <summary>
            移除子客户端的RPCFun函数
            </summary>
            <param name="target">将此对象的所有带有RPCFun特性的函数移除</param>
        </member>
        <member name="M:Net.Client.ClientBase.BindRpc(System.Object)">
            <summary>
            绑定Rpc函数
            </summary>
            <param name="target">注册的对象实例</param>
        </member>
        <member name="M:Net.Client.ClientBase.BindLogHandle(Net.Share.IDebugHandle)">
            <summary>
            绑定网络调式信息处理接口
            </summary>
            <param name="debug"></param>
        </member>
        <member name="M:Net.Client.ClientBase.BindNetworkHandle(Net.Share.INetworkHandle)">
            <summary>
            绑定网络状态处理接口
            </summary>
            <param name="network"></param>
        </member>
        <member name="M:Net.Client.ClientBase.RemoveNetworkHandle(Net.Share.INetworkHandle)">
            <summary>
            移除网络状态处理接口
            </summary>
            <param name="network"></param>
        </member>
        <member name="M:Net.Client.ClientBase.AddRpcBuffer(Net.Share.RPCModel)">
            <summary>
            添加网络函数数据,添加后自动在rpc中调用
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Net.Client.ClientBase.StartHeartHandle">
            <summary>
            开启心跳线程
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.StartThread(System.String,System.Threading.ThreadStart)">
            <summary>
            开启线程
            </summary>
            <param name="threadKey">线程名称</param>
            <param name="start">线程函数</param>
        </member>
        <member name="M:Net.Client.ClientBase.AbortedThread(System.String)">
            <summary>
            结束指定的线程
            </summary>
            <param name="threadKey">线程名称键值</param>
        </member>
        <member name="M:Net.Client.ClientBase.AbortedThread">
            <summary>
            结束所有线程
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.UpdateHandle">
            <summary>
            每一帧执行线程
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.FixedUpdate">
            <summary>
            网络数据更新
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.OnInvokeRpc(Net.Share.RevdBuffer)">
            <summary>
            当调用Rpc函数时调用, 如果想提高性能, 可重写此方法自行判断需要调用哪个方法
            </summary>
            <param name="rpc">远程过程函数对象</param>
        </member>
        <member name="M:Net.Client.ClientBase.Connect">
            <summary>
            连接服务器
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.Connect(System.Action{System.Boolean})">
            <summary>
            连接服务器
            </summary>
            <param name="result">连接结果</param>
            <returns></returns>
        </member>
        <member name="M:Net.Client.ClientBase.Connect(System.String,System.Int32)">
            <summary>
            连接服务器
            </summary>
            <param name="host">IP地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:Net.Client.ClientBase.Connect(System.String,System.Int32,System.Action{System.Boolean})">
            <summary>
            连接服务器
            </summary>
            <param name="host">IP地址</param>
            <param name="port">端口号</param>
            <param name="result">连接结果</param>
        </member>
        <member name="M:Net.Client.ClientBase.Connect(System.String,System.Int32,System.Int32,System.Action{System.Boolean})">
            <summary>
            连接服务器
            </summary>
            <param name="host">IP地址</param>
            <param name="port">端口号</param>
            <param name="localPort">设置自身端口号,如果不设置自身端口则值为-1</param>
            <param name="result">连接结果</param>
        </member>
        <member name="M:Net.Client.ClientBase.ConnectResult(System.String,System.Int32,System.Int32,System.Action{System.Boolean})">
            <summary>
            连接服务器
            </summary>
            <param name="host">连接的服务器主机IP地址</param>
            <param name="port">连接的服务器主机端口号</param>
            <param name="localPort">设置自身端口号,如果不设置自身端口则值为-1</param>
            <param name="result">连接结果</param>
        </member>
        <member name="M:Net.Client.ClientBase.Broadcast(System.Action{System.Boolean,System.String})">
            <summary>
            局域网广播寻找服务器主机, 如果找到则通过 result 参数调用, 如果成功获取到主机, 那么result的第一个参数为true, 并且result的第二个参数为服务器IP
            </summary>
            <param name="result">连接结果</param>
        </member>
        <member name="M:Net.Client.ClientBase.Broadcast(System.Int32,System.Action{System.Boolean,System.String})">
            <summary>
            局域网广播寻找服务器主机, 如果找到则通过 result 参数调用, 如果成功获取到主机, 那么result的第一个参数为true, 并且result的第二个参数为服务器IP
            </summary>
            <param name="port">广播到服务器的端口号</param>
            <param name="result">连接结果</param>
        </member>
        <member name="M:Net.Client.ClientBase.StartupThread">
            <summary>
            连接成功处理
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.OnConnected(System.Boolean)">
            <summary>
            连接结果处理
            </summary>
            <param name="result">结果</param>
        </member>
        <member name="M:Net.Client.ClientBase.Disconnect(System.Boolean)">
            <summary>
            断开连接
            </summary>
            <param name="reuseSocket">断开连接后还能重新使用？</param>
        </member>
        <member name="M:Net.Client.ClientBase.NetworkFlowHandle">
            <summary>
            调式输出网络流量信息
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.CheckRpcHandle">
            <summary>
            rpc检查处理线程
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.SendDataHandle">
            <summary>
            发包线程
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.OnOptPacket(System.Int32)">
            <summary>
            当游戏操作行为封包数据时调用
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Net.Client.ClientBase.SendDirect">
            <summary>
            立刻发送, 不需要等待帧时间 (当你要强制把客户端下线时,你还希望客户端先发送完数据后,再强制客户端退出游戏用到)
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.SendOperations">
            <summary>
            打包操作同步马上要发送了
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.SendDataHandle(Net.Share.QueueSafe{Net.Share.RPCModel},System.Boolean)">
            <summary>
            发送处理
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.OnSerializeRpcInternal(Net.Share.RPCModel)">
            <summary>
            当内核序列化远程函数时调用, 如果想改变内核rpc的序列化方式, 可重写定义序列化协议
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Client.ClientBase.OnDeserializeRpcInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当内核解析远程过程函数时调用, 如果想改变内核rpc的序列化方式, 可重写定义解析协议
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="F:Net.Client.ClientBase.CRCCode">
            <summary>
            CRC校验代码表, 用户可自行改变CRC校验码, 直接改源代码, 客户端和服务器检验码必须一致, 否则识别失败
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.OnCRC(System.Int32,System.Byte)">
            <summary>
            当处理CRC校验
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Client.ClientBase.ReceiveHandle">
            <summary>
            后台线程接收数据
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.ReceiveUpdate(Net.Share.Segment)">
            <summary>
            接收数据和更新处理
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Net.Client.ClientBase.NetworkException(System.Exception)">
            <summary>
            网络异常处理
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:Net.Client.ClientBase.ResolveBuffer(Net.Share.Segment,System.Int32,System.Int32,System.Boolean)">
            <summary>
            解析网络数据包
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.AddOperation(System.String,System.Object[])">
            <summary>
            添加操作, 跟Send方法类似，区别在于AddOperation方法是将所有要发送的数据收集成一堆数据后，等待时间间隔进行发送。
            而Send则是直接发送
            </summary>
            <param name="func"></param>
            <param name="pars"></param>
        </member>
        <member name="M:Net.Client.ClientBase.AddOperation(System.Byte,System.String,System.Object[])">
            <summary>
            添加操作, 跟Send方法类似，区别在于AddOperation方法是将所有要发送的数据收集成一堆数据后，等待时间间隔进行发送。
            而Send则是直接发送
            </summary>
            <param name="cmd"></param>
            <param name="func"></param>
            <param name="pars"></param>
        </member>
        <member name="M:Net.Client.ClientBase.AddOperation(Net.Share.Operation)">
            <summary>
            添加操作, 跟Send方法类似，区别在于AddOperation方法是将所有要发送的数据收集成一堆数据后，等待时间间隔进行发送。
            而Send则是直接发送
            </summary>
            <param name="opt"></param>
        </member>
        <member name="M:Net.Client.ClientBase.AddOperations(System.Collections.Generic.List{Net.Share.Operation})">
            <summary>
            添加操作, 跟Send方法类似，区别在于AddOperation方法是将所有要发送的数据收集成一堆数据后，等待时间间隔进行发送。
            而Send则是直接发送
            </summary>
            <param name="opts"></param>
        </member>
        <member name="M:Net.Client.ClientBase.HeartHandle">
            <summary>
            后台线程发送心跳包
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.PingServer(System.String)">
            <summary>
            测试服务器网络情况
            </summary>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Client.ClientBase.Reconnection(System.Int32)">
            <summary>
            断线重新连接
            </summary>
            <param name="maxFrequency">重连最大次数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Close(System.Boolean,System.Int32)">
            <summary>
            关闭连接,释放线程以及所占资源
            </summary>
            <param name="await">true:等待内部1秒结束所有线程再关闭? false:直接关闭</param>
            <param name="millisecondsTimeout">等待毫秒数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.Byte,System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="cmd">网络命令</param>
            <param name="buffer">发送字节数组缓冲区</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.String,System.Object[])">
            <summary>
            远程调用函数, 调用服务器的方法名为func的函数
            </summary>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.Byte,System.String,System.Object[])">
            <summary>
            远程调用函数, 调用服务器的方法名为func的函数
            </summary>
            <param name="cmd">网络命令</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.String,System.String,System.Delegate,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.String,System.String,System.Delegate,System.Int32,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Send(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Threading.SynchronizationContext,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="context">调用上下文线程对象</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Call(System.String,System.String,System.Object[])">
            <summary>
            远程同步调用
            </summary>
            <param name="func"></param>
            <param name="callbackFunc">服务器返回后调用的函数名</param>
            <param name="pars"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Client.ClientBase.Call(System.String,System.String,System.Int32,System.Object[])">
            <summary>
            远程同步调用
            </summary>
            <param name="func"></param>
            <param name="callbackFunc">服务器返回后调用的函数名</param>
            <param name="millisecondsDelay">需要等待的时间,毫秒单位</param>
            <param name="pars"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Client.ClientBase.Call(System.Byte,System.String,System.String,System.Int32,System.Object[])">
            <summary>
            远程同步调用
            </summary>
            <param name="cmd"></param>
            <param name="func"></param>
            <param name="callbackFunc">服务器返回后调用的函数名</param>
            <param name="millisecondsDelay">需要等待的时间,毫秒单位</param>
            <param name="pars"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.String,System.Object[])">
            <summary>
            发送网络可靠传输数据, 可以发送大型文件数据
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.Byte,System.String,System.Object[])">
            <summary>
            发送可靠网络传输, 可以发送大型文件数据
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="cmd">网络命令</param>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.String,System.String,System.Delegate,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.String,System.String,System.Delegate,System.Int32,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Threading.SynchronizationContext,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="context">调用上下文线程</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.UInt16,System.UInt16,System.Delegate,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.UInt16,System.UInt16,System.Delegate,System.Int32,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.UInt16,System.UInt16,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.Byte,System.UInt16,System.UInt16,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.Byte[])">
            <summary>
            发送可靠网络传输, 可发送大数据流
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Client.ClientBase.SendRT(System.Byte,System.Byte[])">
            <summary>
            发送可靠网络传输, 可发送大数据流
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="cmd">网络命令</param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Client.ClientBase.CallRpc(System.String,System.Object[])">
            <summary>
            远程过程调用 同Send方法
            </summary>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Client.ClientBase.CallRpc(System.Byte,System.String,System.Object[])">
            <summary>
            远程过程调用 同Send方法
            </summary>
            <param name="cmd">网络命令，请看NetCmd类定义</param>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Request(System.String,System.Object[])">
            <summary>
            网络请求 同Send方法
            </summary>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Client.ClientBase.Request(System.Byte,System.String,System.Object[])">
            <summary>
            网络请求 同Send方法
            </summary>
            <param name="cmd">网络命令，请看NetCmd类定义</param>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Client.ClientBase.InvokeOnOperationSync(Net.Share.OperationList)">
            <summary>
            
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Net.Client.ClientBase.InvokeOnRevdBufferHandle(Net.Share.RPCModel)">
            <summary>
            
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Net.Client.ClientBase.SetHeartTime(System.Byte,System.Int32)">
            <summary>
            设置心跳时间
            </summary>
            <param name="timeoutLimit">心跳检测次数, 默认检测5次</param>
            <param name="interval">心跳时间间隔, 每interval毫秒会检测一次</param>
        </member>
        <member name="M:Net.Client.ClientBase.Ping">
            <summary>
            ping测试网络延迟, 通过<see cref="E:Net.Client.ClientBase.OnPingCallback"/>事件回调
            </summary>
        </member>
        <member name="M:Net.Client.ClientBase.Ping(System.Action{System.Double})">
            <summary>
            ping测试网络延迟, 此方法帮你监听<see cref="E:Net.Client.ClientBase.OnPingCallback"/>事件, 如果不使用的时候必须保证能移除委托, 建议不要用框名函数, 那样会无法移除委托
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:Net.Client.ClientBase.AddAdapter(Net.Share.IAdapter)">
            <summary>
            添加适配器
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:Net.Client.ClientBase.AddAdapter(Net.Share.AdapterType,Net.Share.IAdapter)">
            <summary>
            添加适配器
            </summary>
            <param name="type"></param>
            <param name="adapter"></param>
        </member>
        <member name="M:Net.Client.ClientBase.AddStateHandler(Net.Share.NetworkState,System.Action)">
            <summary>
            添加网络状态事件处理
            </summary>
            <param name="listen">要监听的网络状态</param>
            <param name="action">监听网络状态的回调方法</param>
        </member>
        <member name="M:Net.Client.ClientBase.VarSyncHandler">
            <summary>
            字段,属性同步处理线程
            </summary>
        </member>
        <member name="T:Net.Client.NetBehaviour">
            <summary>
            网络行为，此类负责网络增删Rpc远程过程调用函数，使用到网络通讯功能，需要继承此类
            </summary>
        </member>
        <member name="P:Net.Client.NetBehaviour.Handle">
            <summary>
            客户端发送接口
            </summary>
        </member>
        <member name="M:Net.Client.NetBehaviour.AddRpc(System.Object,System.Boolean)">
            <summary>
            添加远程过程调用函数的委托
            </summary>
            <param name="target">远程过程调用指定的对象</param>
            <param name="append">一个Rpc方法是否可以多次添加到Rpcs里面？</param>
        </member>
        <member name="M:Net.Client.NetBehaviour.AddRpc(Net.Client.ClientBase,System.Object,System.Boolean)">
            <summary>
            添加远程过程调用函数的委托
            </summary>
            <param name="client">添加RPC到此客户端</param>
            <param name="target">远程过程调用指定的对象</param>
            <param name="append">一个Rpc方法是否可以多次添加到Rpcs里面？</param>
        </member>
        <member name="M:Net.Client.NetBehaviour.RemoveRpc(System.Object)">
            <summary>
            移除RPCFun函数
            </summary>
            <param name="target">将此对象的所有带有RPCFun特性的函数移除</param>
        </member>
        <member name="M:Net.Client.NetBehaviour.RemoveRpc(Net.Client.ClientBase,System.Object)">
            <summary>
            移除子客户端的RPCFun函数
            </summary>
            <param name="client">子客户端对象</param>
            <param name="target">将此对象的所有带有RPCFun特性的函数移除</param>
        </member>
        <member name="M:Net.Client.NetBehaviour.Awake">
            <summary>
            <para>当游戏开始初始化此对象时，搜索继承此类的方法中带有RPCFun或Rpc特性的方法，并添加到远程过程调用委托集合变量里</para>
            <para>如果重写此方法必须base.Awake();</para>
            </summary>
        </member>
        <member name="T:Net.Client.NetEvent">
            <summary>
            网络事件
            </summary>
        </member>
        <member name="F:Net.Client.NetEvent.Context">
            <summary>
            unity同步线程
            </summary>
        </member>
        <member name="M:Net.Client.NetEvent.AddContextEvent(System.Int32,System.Action)">
            <summary>
            添加unity主线程同步事件, action回调在unity主程序被调用
            </summary>
            <param name="millisecondsTimeout"></param>
            <param name="action"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddContextEvent(System.Int32,System.Action{System.Object},System.Object)">
            <summary>
            添加unity主线程同步事件, action回调在unity主程序被调用
            </summary>
            <param name="millisecondsTimeout"></param>
            <param name="action"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddCoroutineEvent(UnityEngine.MonoBehaviour,System.Int32,System.Action)">
            <summary>
            添加携程事件
            </summary>
            <param name="mono"></param>
            <param name="milliseconds"></param>
            <param name="updateAct"></param>
            <param name="endAct"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddCoroutineEvent(UnityEngine.MonoBehaviour,System.Int32,System.Action,System.Action)">
            <summary>
            添加携程事件
            </summary>
            <param name="mono"></param>
            <param name="milliseconds"></param>
            <param name="updateAct"></param>
            <param name="endAct"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddCoroutineEvent(UnityEngine.MonoBehaviour,System.Single,System.Int32,System.Action{System.Object},System.Object)">
            <summary>
            添加携程事件, 每time秒调用一次, 调用invokeNum次
            </summary>
            <param name="mono"></param>
            <param name="time"></param>
            <param name="invokeNum"></param>
            <param name="updateAct"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddCoroutineEvent``1(UnityEngine.MonoBehaviour,System.Single,System.Int32,System.Action{``0},``0)">
            <summary>
            添加携程事件, 每time秒调用一次, 调用invokeNum次
            </summary>
            <param name="mono"></param>
            <param name="time"></param>
            <param name="invokeNum"></param>
            <param name="updateAct"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddCoroutineEvent(UnityEngine.MonoBehaviour,System.Func{System.Boolean})">
            <summary>
            添加携程事件
            </summary>
            <param name="mono"></param>
            <param name="milliseconds"></param>
            <param name="updateAct"></param>
            <param name="endAct"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddCoroutineEvent(UnityEngine.MonoBehaviour,System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            添加携程事件
            </summary>
            <param name="mono"></param>
            <param name="milliseconds"></param>
            <param name="updateAct"></param>
            <param name="endAct"></param>
        </member>
        <member name="M:Net.Client.NetEvent.AddCoroutineEvent``1(UnityEngine.MonoBehaviour,System.Func{``0,System.Boolean},``0)">
            <summary>
            添加携程事件
            </summary>
            <param name="mono"></param>
            <param name="milliseconds"></param>
            <param name="updateAct"></param>
            <param name="endAct"></param>
        </member>
        <member name="T:Net.Client.NetworkCondition">
            <summary>
            检测网络状况
            </summary>
        </member>
        <member name="F:Net.Client.NetworkCondition.delayTime">
            <summary>
            延时毫秒时间
            </summary>
        </member>
        <member name="F:Net.Client.NetworkCondition.ShowFPS">
            <summary>
            显示FPS和网络延迟 参数1:FPS和延迟字符串 参数2:帧率 参数2:网络延迟
            </summary>
        </member>
        <member name="T:Net.Client.DotNettyClient">
            <summary>
            dotNetty客户端
            </summary>
        </member>
        <member name="M:Net.Client.DotNettyClient.Testing(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            dotnetty压力测试
            </summary>
            <param name="ip">服务器ip</param>
            <param name="port">服务器端口</param>
            <param name="clientLen">测试客户端数量</param>
            <param name="dataLen">每个客户端数据大小</param>
        </member>
        <member name="T:Net.Client.ENetClient">
            <summary>
            ENet客户端类型 
            第三版本 2020.9.14
            </summary>
        </member>
        <member name="M:Net.Client.ENetClient.#ctor">
            <summary>
            构造客户端
            </summary>
        </member>
        <member name="M:Net.Client.ENetClient.#ctor(System.Boolean)">
            <summary>
            构造客户端
            </summary>
            <param name="useUnityThread">使用unity多线程?</param>
        </member>
        <member name="M:Net.Client.ENetClient.Testing(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            udp压力测试
            </summary>
            <param name="ip">服务器ip</param>
            <param name="port">服务器端口</param>
            <param name="clientLen">测试客户端数量</param>
            <param name="dataLen">每个客户端数据大小</param>
        </member>
        <member name="T:Net.Client.NetworkClient">
            <summary>
            双通讯(tcp, udp)客户端 当使用Send发送数据时, 使用udp协议发送. 当使用SendRT发送数据时, 使用tcp协议发送
            当Send发送数据大于50000字节后内部自动转换为tcp协议发送
            </summary>
        </member>
        <member name="F:Net.Client.NetworkClient.frame">
            <summary>
            帧尾或叫数据长度(4) + CRC检验索引(1) + CRC校验码(1) + 玩家id(4) = 10
            </summary>
        </member>
        <member name="M:Net.Client.NetworkClient.#ctor">
            <summary>
            构造双协议(tcp,udp)客户端
            </summary>
        </member>
        <member name="M:Net.Client.NetworkClient.#ctor(System.Boolean)">
            <summary>
            构造双协议(tcp,udp)客户端
            </summary>
            <param name="useUnityThread">使用unity多线程?</param>
        </member>
        <member name="M:Net.Client.NetworkClient.Testing(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            udp压力测试
            </summary>
            <param name="ip">服务器ip</param>
            <param name="port">服务器端口</param>
            <param name="clientLen">测试客户端数量</param>
            <param name="dataLen">每个客户端数据大小</param>
        </member>
        <member name="T:Net.Client.TcpClient">
            <summary>
            TCP客户端类型 
            第三版本 2020.9.14
            </summary>
        </member>
        <member name="M:Net.Client.TcpClient.#ctor">
            <summary>
            构造不可靠传输客户端
            </summary>
        </member>
        <member name="M:Net.Client.TcpClient.#ctor(System.Boolean)">
            <summary>
            构造不可靠传输客户端
            </summary>
            <param name="useUnityThread">使用unity多线程?</param>
        </member>
        <member name="M:Net.Client.TcpClient.Testing(System.String,System.Int32,System.Int32,System.Int32,System.Action{Net.Client.TcpClient.TcpClientTest},System.Action{System.Collections.Generic.List{Net.Client.TcpClient.TcpClientTest}})">
            <summary>
            tcp压力测试
            </summary>
            <param name="ip">服务器ip</param>
            <param name="port">服务器端口</param>
            <param name="clientLen">测试客户端数量</param>
            <param name="dataLen">每个客户端数据大小</param>
        </member>
        <member name="T:Net.Client.UdpClient">
            <summary>
            Udp网络客户端
            在安卓端必须设置可以后台运行, 如果不设置,当你按下home键后,app的所有线程将会被暂停,这会影响网络心跳检测线程,导致网络中断
            解决方法 : 在android项目AndroidManifest.xml文件中的activity中添加如下内容：
            android:configChanges="fontScale|keyboard|keyboardHidden|locale|mnc|mcc|navigation|orientation|screenLayout|screenSize|smallestScreenSize|uiMode|touchscreen" 
            详情请看此博文:https://www.cnblogs.com/nanwei/p/9125316.html
            或这个博文: http://www.voidcn.com/article/p-yakpcmce-bpk.html
            </summary>
        </member>
        <member name="M:Net.Client.UdpClient.#ctor">
            <summary>
            构造udp可靠客户端
            </summary>
        </member>
        <member name="M:Net.Client.UdpClient.#ctor(System.Boolean)">
            <summary>
            构造udp可靠客户端
            </summary>
            <param name="useUnityThread">使用unity多线程?</param>
        </member>
        <member name="M:Net.Client.UdpClient.GetP2P(System.Int32)">
            <summary>
            获取p2p IP和端口, 通过client.OnP2PCallback事件回调
            </summary>
            <param name="uid"></param>
        </member>
        <member name="M:Net.Client.UdpClient.Testing(System.String,System.Int32,System.Int32,System.Int32,System.Action{Net.Client.UdpClientTest},System.Action{System.Collections.Generic.List{Net.Client.UdpClientTest}},Net.Share.IAdapter)">
            <summary>
            udp压力测试
            </summary>
            <param name="ip">服务器ip</param>
            <param name="port">服务器端口</param>
            <param name="clientLen">测试客户端数量</param>
            <param name="dataLen">每个客户端数据大小</param>
        </member>
        <member name="M:Net.Client.UdpClientTest.Update">
            <summary>
            单线程更新，需要开发者自动调用更新
            </summary>
        </member>
        <member name="T:Net.Client.P2PClient">
            <summary>
            NAT穿透最详细介绍: https://www.cnblogs.com/ssyfj/p/14791064.html#三：p2p网络中的nat穿透问题---nat的原理和类型
            </summary>
        </member>
        <member name="T:Net.Client.KcpClient">
            <summary>
            kcp客户端
            </summary>
        </member>
        <member name="M:Net.Client.KcpClient.Testing(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            udp压力测试
            </summary>
            <param name="ip">服务器ip</param>
            <param name="port">服务器端口</param>
            <param name="clientLen">测试客户端数量</param>
            <param name="dataLen">每个客户端数据大小</param>
        </member>
        <member name="T:Net.Client.UdxClient">
            <summary>
            udx客户端类型 -> 只能300人以下连接, 如果想要300个客户端以上, 请进入udx网址:www.goodudx.com 联系作者下载专业版FastUdxApi.dll, 然后更换下框架内的FastUdxApi.dll即可
            第三版本 2020.9.14
            </summary>
        </member>
        <member name="M:Net.Client.UdxClient.#ctor">
            <summary>
            构造可靠传输客户端
            </summary>
        </member>
        <member name="M:Net.Client.UdxClient.#ctor(System.Boolean)">
            <summary>
            构造可靠传输客户端
            </summary>
            <param name="useUnityThread">使用unity多线程?</param>
        </member>
        <member name="M:Net.Client.UdxClient.Testing(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            udx压力测试
            </summary>
            <param name="ip">服务器ip</param>
            <param name="port">服务器端口</param>
            <param name="clientLen">测试客户端数量</param>
            <param name="dataLen">每个客户端数据大小</param>
        </member>
        <member name="T:Net.Event.EventSystem">
            <summary>
            事件处理静态类, 此类可以用于计时调用事件
            </summary>
        </member>
        <member name="M:Net.Event.EventSystem.AddEvent(System.Int32,System.Action)">
            <summary>
            延迟处理，millisecondsTimeout毫秒后执行action方法
            </summary>
            <param name="millisecondsTimeout"></param>
            <param name="action"></param>
            <returns>返回id标识</returns>
        </member>
        <member name="M:Net.Event.EventSystem.AddEvent(System.DateTime,System.Action)">
            <summary>
            添加计时器事件, 当系统时间大于或等于(time)时间后调用(action)事件
            </summary>
            <param name="time"></param>
            <param name="action"></param>
        </member>
        <member name="M:Net.Event.EventSystem.AddEvent(System.DateTime,System.Action{System.Object},System.Object)">
            <summary>
            添加计时器事件, 当系统时间大于或等于(time)时间后调用(action)事件
            </summary>
            <param name="time"></param>
            <param name="action"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Event.EventSystem.AddEvent(System.Int32,System.Action{System.Object},System.Object)">
            <summary>
            添加计时器事件, 当系统时间大于或等于(time)时间后调用(action)事件
            </summary>
            <param name="time"></param>
            <param name="action"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Event.EventSystem.AddEvent(System.Int32,System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            添加计时器事件, 当系统时间大于或等于(time)时间后调用(action)事件, 当action返回true后事件结束, 则每time时间调用一次
            </summary>
            <param name="time">毫秒单位</param>
            <param name="action"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Event.EventSystem.AddEvent(System.DateTime,System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            添加计时器事件, 当系统时间大于或等于(time)时间后调用(action)事件, 当action返回true后事件结束, 则每time时间调用一次
            </summary>
            <param name="time"></param>
            <param name="action"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Event.EventSystem.RemoveEvent(System.Int32)">
            <summary>
            移除事件
            </summary>
            <param name="actionId"></param>
        </member>
        <member name="T:Net.Event.NDebug">
            <summary>
            消息输入输出处理类
            </summary>
        </member>
        <member name="E:Net.Event.NDebug.LogHandle">
            <summary>
            输出调式消息
            </summary>
        </member>
        <member name="E:Net.Event.NDebug.LogErrorHandle">
            <summary>
            输出调式错误消息
            </summary>
        </member>
        <member name="E:Net.Event.NDebug.LogWarningHandle">
            <summary>
            输出调式警告消息
            </summary>
        </member>
        <member name="P:Net.Event.NDebug.LogMax">
            <summary>
            输出日志最多容纳条数
            </summary>
        </member>
        <member name="P:Net.Event.NDebug.LogErrorMax">
            <summary>
            输出错误日志最多容纳条数
            </summary>
        </member>
        <member name="P:Net.Event.NDebug.LogWarningMax">
            <summary>
            输出警告日志最多容纳条数
            </summary>
        </member>
        <member name="M:Net.Event.NDebug.Log(System.Object)">
            <summary>
            输出调式消息
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Net.Event.NDebug.LogError(System.Object)">
            <summary>
            输出错误消息
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Net.Event.NDebug.LogWarning(System.Object)">
            <summary>
            输出警告消息
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Net.Server.ISerializableData">
            <summary>
            序列化数据接口, 需要序列化的主类要继承此接口
            </summary>
        </member>
        <member name="P:Net.Server.ISerializableData.UIDKey">
            <summary>
            用户标识, 记录玩家键值对, 可以以账号来记录或玩家名称来记录等等
            </summary>
        </member>
        <member name="P:Net.Server.ISerializableData.StreamPosition">
            <summary>
            记录数据存储在文件内部的位置索引 (内部自动赋值,不要修改其值)
            </summary>
        </member>
        <member name="P:Net.Server.ISerializableData.Row">
            <summary>
            每个玩家的数据在mysql,sqlserver数据库的数据行
            </summary>
        </member>
        <member name="T:Net.Server.DataBase`1">
            <summary>
            服务器运行时数据库 19.10.4
            可以重写此类的一些Save和AddPlayer方法转接到mySql数据库
            </summary>
        </member>
        <member name="T:Net.Server.DataBase`2">
            <summary>
            服务器运行时数据库 19.10.4
            可以重写此类的一些Save和AddPlayer方法转接到mySql数据库
            </summary>
        </member>
        <member name="F:Net.Server.DataBase`2.Instance">
            <summary>
            数据库单例
            </summary>
        </member>
        <member name="P:Net.Server.DataBase`2.DataSize">
            <summary>
            单个玩家可以存储的数据大小
            </summary>
        </member>
        <member name="P:Net.Server.DataBase`2.StreamPosition">
            <summary>
            当前的流位置
            </summary>
        </member>
        <member name="F:Net.Server.DataBase`2.rootPath">
            <summary>
            当前程序工作路径, 数据库保存路径
            </summary>
        </member>
        <member name="F:Net.Server.DataBase`2.DataPath">
            <summary>
            玩家数据保存路径
            </summary>
        </member>
        <member name="F:Net.Server.DataBase`2.PlayerInfos">
            <summary>
            所有玩家信息
            </summary>
        </member>
        <member name="F:Net.Server.DataBase`2.Table">
            <summary>
            数据表, 接入mysql, sqlserver数据库后可以批量处理数据库
            </summary>
        </member>
        <member name="P:Net.Server.DataBase`2.Item(System.String)">
            <summary>
            直接读取数据库玩家对象
            </summary>
            <param name="playerID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.DataBase`2.Players">
            <summary>
            获得所有玩家帐号数据
            </summary>
        </member>
        <member name="M:Net.Server.DataBase`2.Load">
            <summary>
            加载数据库信息
            </summary>
        </member>
        <member name="M:Net.Server.DataBase`2.Load(System.Action{`1})">
            <summary>
            加载数据库信息
            </summary>
            <param name="lastHandle">需要做最后的处理的, Player.playerID必须指定 </param>
        </member>
        <member name="M:Net.Server.DataBase`2.LoadAsync(System.Action{`1})">
            <summary>
            异步加载数据库信息
            </summary>
            <param name="lastHandle">需要做最后的处理的, Player.playerID必须指定 </param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.DataBase`2.OnSerialize(`1)">
            <summary>
            当序列化数据, 即将写入磁盘文件时调用
            </summary>
            <param name="player"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.DataBase`2.OnLoad">
            <summary>
            当加载持久文件数据时调用, 加载的数据在PlayerInfos属性里面
            </summary>
        </member>
        <member name="M:Net.Server.DataBase`2.SaveAll">
            <summary>
            存储全部玩家数据到文件里
            </summary>
        </member>
        <member name="M:Net.Server.DataBase`2.Save(`1)">
            <summary>
            存储单个玩家的数据到文件里
            </summary>
        </member>
        <member name="M:Net.Server.DataBase`2.Delete(`1)">
            <summary>
            删除磁盘里面的单个用户的全部数据
            </summary>
        </member>
        <member name="M:Net.Server.DataBase`2.AddPlayer(`1)">
            <summary>
            添加网络玩家到数据库
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.DataBase`2.AddPlayer(System.String,`1)">
            <summary>
            添加网络玩家到数据库
            </summary>
            <param name="playerID"></param>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.DataBase`2.AddPlayerAndSave(`1)">
            <summary>
            添加玩家数据并保存到文件
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.DataBase`2.OnAddPlayer(System.String,`1)">
            <summary>
            当添加玩家注册的账号数据到数据库时调用
            </summary>
            <param name="playerID"></param>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.DataBase`2.Contains(System.String)">
            <summary>
            是否包含玩家ID
            </summary>
            <param name="playerID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.DataBase`2.HasAccout(System.String)">
            <summary>
            数据库是否已经有这个playerID账号?
            </summary>
            <param name="playerID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.DataBase`2.Remove(`1)">
            <summary>
            尝试移除网络玩家
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.DataBase`2.Remove(System.String)">
            <summary>
            尝试移除网络玩家
            </summary>
            <param name="playerID"></param>
        </member>
        <member name="M:Net.Server.DataBase`2.OnDelete(`1)">
            <summary>
            当从数据库删除playerID的账号时调用
            </summary>
            <param Player="player"></param>
        </member>
        <member name="T:Net.Server.NetBehaviour`2">
            <summary>
            服务器网络行为
            </summary>
        </member>
        <member name="M:Net.Server.NetBehaviour`2.#ctor">
            <summary>
            构造网络行为函数
            </summary>
        </member>
        <member name="M:Net.Server.NetBehaviour`2.AddRpcs(System.Object)">
            <summary>
            添加所有带有RPCFun特性的方法
            </summary>
            <param name="target">要收集RPCFun特性的对象</param>
        </member>
        <member name="M:Net.Server.NetBehaviour`2.AddRpcs(Net.Server.ServerBase{`0,`1},System.Object,System.Boolean)">
            <summary>
            添加所有带有RPCFun特性的方法
            </summary>
            <param name="server"></param>
            <param name="target"></param>
            <param name="append">追加rpc，如果target类型已经存在还可以追加到rpcs？</param>
        </member>
        <member name="M:Net.Server.NetBehaviour`2.GetRpcs(System.Object)">
            <summary>
            获取带有RPCFun特性的所有方法
            </summary>
            <param name="target">要获取RPCFun特性的对象</param>
            <returns>返回获取到带有RPCFun特性的所有公开方法</returns>
        </member>
        <member name="M:Net.Server.NetBehaviour`2.RemoveRpc(Net.Server.ServerBase{`0,`1},System.Object)">
            <summary>
            移除网络远程过程调用函数
            </summary>
            <param name="server">指定的服务器rpcs</param>
            <param name="target">移除的rpc对象</param>
        </member>
        <member name="T:Net.Server.NetPlayer">
            <summary>
            网络玩家 - 当客户端连接服务器后都会为每个客户端生成一个网络玩家对象，(玩家对象由服务器管理) 2019.9.9
            <code>注意:不要试图new player出来, new出来后是没有作用的!</code>
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.Client">
            <summary>
            Tcp套接字
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.RemotePoint">
            <summary>
            存储UDP客户端终端
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.sceneID">
            <summary>
            此玩家所在的场景ID
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.playerID">
            <summary>
            客户端玩家的标识
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.Scene">
            <summary>
            玩家所在的场景实体
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.Rpcs">
            <summary>
            玩家rpc
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.RpcMaskDic">
            <summary>
            远程方法遮罩
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.LastTime">
            <summary>
            临时客户端持续时间: (内核使用):
            未知客户端连接服务器, 长时间未登录账号, 未知客户端临时内存对此客户端回收, 并强行断开此客户端连接
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.heart">
            <summary>
            跳动的心
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.sendRTList">
            <summary>
            发送可靠数据缓冲
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.revdRTList">
            <summary>
            接收可靠数据缓冲
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.stack">
            <summary>
            TCP叠包值， 0:正常 >1:叠包次数 >25:清空叠包缓存流
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.stackStream">
            <summary>
            TCP叠包临时缓存流
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.UserID">
            <summary>
            用户唯一身份标识
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.sendReliableFrame">
            <summary>
            当前可靠帧, 比如服务器发送两帧可靠数据帧给客户端, 客户端只需要收到一个帧数据即可 (发送帧)
            </summary>
        </member>
        <member name="F:Net.Server.NetPlayer.revdReliableFrame">
            <summary>
            当前可靠帧, 比如服务器发送两帧可靠数据帧给客户端, 客户端只需要收到一个帧数据即可 (接收帧)
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.CloseSend">
            <summary>
            关闭发送数据, 当关闭发送数据后, 数据将会停止发送, (允许接收客户端数据,但不能发送!)
            </summary>
        </member>
        <member name="P:Net.Server.NetPlayer.TcpRemoteEndPoint">
            <summary>
            tcp远程端口, 由于socket被关闭后无法访问RemoteEndPoint的问题
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.#ctor">
            <summary>
            构造网络客户端
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.#ctor(System.Net.Sockets.Socket)">
            <summary>
            构造网络客户端，Tcp
            </summary>
            <param name="client">客户端套接字</param>
        </member>
        <member name="M:Net.Server.NetPlayer.#ctor(System.Net.EndPoint)">
            <summary>
            构造网络客户端
            </summary>
            <param name="remotePoint"></param>
        </member>
        <member name="M:Net.Server.NetPlayer.Finalize">
            <summary>
            析构网络客户端
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.AddRpc(System.Boolean)">
            <summary>
            添加远程过程调用函数,从对象进行收集
            </summary>
            <param name="append">可以重复添加rpc?</param>
        </member>
        <member name="M:Net.Server.NetPlayer.AddRpc(System.Object,System.Boolean)">
            <summary>
            添加远程过程调用函数,从对象进行收集
            </summary>
            <param name="target"></param>
            <param name="append">可以重复添加rpc?</param>
        </member>
        <member name="M:Net.Server.NetPlayer.RemoveRpc(System.Object)">
            <summary>
            移除网络远程过程调用函数
            </summary>
            <param name="target">移除的rpc对象</param>
        </member>
        <member name="M:Net.Server.NetPlayer.OnUnClientRequest(Net.Share.RPCModel)">
            <summary>
            当未知客户端发送数据请求，返回<see langword="false"/>，不做任何事，返回<see langword="true"/>，添加到<see cref="P:Net.Server.ServerBase`2.Players"/>中
            客户端玩家的入口点，在这里可以控制客户端是否可以进入服务器与其他客户端进行网络交互
            在这里可以用来判断客户端登录和注册等等进站许可
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.NetPlayer.OnWSUnClientRequest(Net.Share.MessageModel)">
            <summary>
            当web服务器未知客户端发送数据请求，返回<see langword="false"/>，不做任何事，返回<see langword="true"/>，添加到<see cref="P:Net.Server.ServerBase`2.Players"/>中
            客户端玩家的入口点，在这里可以控制客户端是否可以进入服务器与其他客户端进行网络交互
            在这里可以用来判断客户端登录和注册等等进站许可
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.NetPlayer.OnRevdBufferHandle(Net.Share.RPCModel)">
            <summary>
            当接收到客户端自定义数据请求,在这里可以使用你自己的网络命令，系列化方式等进行解析网络数据。（你可以在这里使用ProtoBuf或Json来解析网络数据）
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Net.Server.NetPlayer.OnWSRevdBuffer(Net.Share.MessageModel)">
            <summary>
            当接收到webSocket客户端自定义数据请求,在这里可以使用你自己的网络命令，系列化方式等进行解析网络数据。（你可以在这里使用ProtoBuf或Json来解析网络数据）
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Net.Server.NetPlayer.OnRemoveClient">
            <summary>
            当服务器判定客户端为断线或连接异常时，移除客户端时调用
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.OnRpcExecute(Net.Share.RPCModel)">
            <summary>
            当执行Rpc(远程过程调用函数)时, 提高性能可重写此方法进行指定要调用的函数
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Net.Server.NetPlayer.OnStart">
            <summary>
            当玩家登录成功初始化调用
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.OnUpdate">
            <summary>
            当玩家更新操作
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.OnEnter">
            <summary>
            当玩家进入场景 ->场景对象在Scene属性
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.OnExit">
            <summary>
            当玩家退出场景 ->场景对象在Scene属性
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.OnRemove">
            <summary>
            当场景被移除 ->场景对象在Scene属性
            </summary>
        </member>
        <member name="M:Net.Server.NetPlayer.OnOperationSync(Net.Share.OperationList)">
            <summary>
            当接收到客户端使用<see cref="M:Net.Client.ClientBase.AddOperation(Net.Share.Operation)"/>方法发送的请求时调用. 如果重写此方法, 
            <code>返回false, 则服务器对象类会重新把操作列表加入到场景中, 你可以重写服务器的<see cref="M:Net.Server.ServerBase`2.OnOperationSync(`0,Net.Share.OperationList)"/>方法让此方法失效</code>
            <code>返回true, 服务器不再把数据加入到场景列表, 认为你已经在此处把数据处理了</code>
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.NetPlayer.AddRpcHandle(System.Object)">
            <summary>
            添加一个对象的所有Rpc方法
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Net.Server.NetPlayer.Close">
            <summary>
            此方法需要自己实现, 实现内容如下: <see langword="xxServer.Instance.RemoveClient(this);"/>
            </summary>
        </member>
        <member name="T:Net.Server.NetPort">
            <summary>
            网络端口检测类
            </summary>
        </member>
        <member name="M:Net.Server.NetPort.GetFirstAvailablePort(System.Int32,System.Int32)">
            <summary>
            获取第一个可用的端口号
            </summary>
            <param name="startPort">起始端口号</param>
            <param name="MaxPort">结束端口号</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.NetPort.PortIsUsed">
            <summary>
            获取操作系统已用的端口号
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Server.NetPort.PortIsAvailable(System.Int32)">
            <summary>
            检查指定端口是否已用
            </summary>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.NetPort.GetIP">
            <summary>
            获取本机ip地址
            </summary>
            <returns></returns>
        </member>
        <member name="T:Net.Server.NetScene`1">
            <summary>
            网络场景
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.Name">
            <summary>
            场景名称
            </summary>
        </member>
        <member name="F:Net.Server.NetScene`1.sceneCapacity">
            <summary>
            场景容纳人数
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.Players">
            <summary>
            当前网络场景的玩家
            </summary>
        </member>
        <member name="F:Net.Server.NetScene`1.state">
            <summary>
            当前网络场景状态
            </summary>
        </member>
        <member name="F:Net.Server.NetScene`1.frame">
            <summary>
            当前帧
            </summary>
        </member>
        <member name="F:Net.Server.NetScene`1.operations">
            <summary>
            备用操作, 当玩家被移除后速度比update更新要快而没有地方收集操作指令, 所以在玩家即将被移除时, 可以访问这个变量进行添加操作同步数据
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.SendOperationReliable">
            <summary>
            玩家操作是以可靠传输进行发送的?
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.SceneNumber">
            <summary>
            获取场景当前人数
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.CurrNum">
            <summary>
            获取场景当前人数
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.Count">
            <summary>
            获取场景容纳人数
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.IsFull">
            <summary>
            场景(房间)人数是否已满？
            </summary>
        </member>
        <member name="P:Net.Server.NetScene`1.Split">
            <summary>
            操作列表分段值, 当operations.Count的长度大于Split值时, 就会裁剪为多段数据发送 默认为500长度分段
            </summary>
        </member>
        <member name="F:Net.Server.NetScene`1.Event">
            <summary>
            场景事件
            </summary>
        </member>
        <member name="M:Net.Server.NetScene`1.#ctor">
            <summary>
            构造网络场景
            </summary>
        </member>
        <member name="M:Net.Server.NetScene`1.#ctor(System.Int32)">
            <summary>
            添加网络主场景并增加主场景最大容纳人数
            </summary>
            <param name="number">主场景最大容纳人数</param>
        </member>
        <member name="M:Net.Server.NetScene`1.#ctor(`0,System.Int32)">
            <summary>
            添加网络场景并增加当前场景人数
            </summary>
            <param name="client">网络玩家</param>
            <param name="number">创建场景容纳人数</param>
        </member>
        <member name="M:Net.Server.NetScene`1.GetPlayers">
            <summary>
            获取场景内的玩家到一维集合里
            </summary>
            <returns></returns>
        </member>
        <member name="P:Net.Server.NetScene`1.Clients">
            <summary>
            获取场景的所有客户端玩家
            </summary>
        </member>
        <member name="M:Net.Server.NetScene`1.AddPlayer(`0)">
            <summary>
            添加玩家
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.OnEnter(`0)">
            <summary>
            当进入场景的玩家
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.OnExit(`0)">
            <summary>
            当退出场景的玩家
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.OnRemove(`0)">
            <summary>
            当场景被移除
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.OnOperationSync(`0,Net.Share.OperationList)">
            <summary>
            当接收到客户端使用Client.AddOperation方法发送的请求时调用
            </summary>
        </member>
        <member name="M:Net.Server.NetScene`1.AddPlayerRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            添加玩家
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.Update(Net.Share.IServerSendHandle{`0},System.Byte)">
            <summary>
            网络帧同步, 状态同步更新, 帧时间根据服务器主类的SyncSceneTime属性来调整速率
            </summary>
        </member>
        <member name="M:Net.Server.NetScene`1.OnPacket(Net.Share.IServerSendHandle{`0},System.Byte,System.Int32)">
            <summary>
            当封包数据时调用
            </summary>
            <param name="handle"></param>
            <param name="cmd"></param>
            <param name="count"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.OnRecovery(Net.Share.Operation[])">
            <summary>
            当操作对象即将被回收, 可重写此方法, 用对象池回收复用 注意, 如果回收复用的, 创建也要使用对象池创建
            <code>创建代码: var opt = ObjectPool&lt;Operation&gt;.Take();</code>
            <code>回收代码: foreach(var opt in opts) ObjectPool&lt;Operation&gt;.Push(opt);</code>
            </summary>
        </member>
        <member name="M:Net.Server.NetScene`1.AddOperation(System.String,System.Object[])">
            <summary>
            添加操作帧, 等待帧时间同步发送
            </summary>
            <param name="func"></param>
            <param name="pars"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.AddOperation(System.Byte,System.String,System.Object[])">
            <summary>
            添加操作帧, 等待帧时间同步发送
            </summary>
            <param name="cmd"></param>
            <param name="func"></param>
            <param name="pars"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.AddOperation(Net.Share.Operation)">
            <summary>
            添加操作帧, 等待帧时间同步发送
            </summary>
            <param name="opt"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.AddOperations(System.Collections.Generic.List{Net.Share.Operation})">
            <summary>
            添加操作帧, 等待帧时间同步发送
            </summary>
            <param name="opts"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.AddOperations(Net.Share.Operation[])">
            <summary>
            添加操作帧, 等待帧时间同步发送
            </summary>
            <param name="opts"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.ToString">
            <summary>
            场景对象转字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Server.NetScene`1.Remove(`0)">
            <summary>
            移除玩家
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.NetScene`1.RemoveAll">
            <summary>
            移除所有玩家
            </summary>
        </member>
        <member name="M:Net.Server.NetScene`1.RemoveOperations">
            <summary>
            移除场景所有玩家操作
            </summary>
        </member>
        <member name="T:Net.Server.ServerBase`2">
            <summary>
            网络服务器核心基类 2019.11.22
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Name">
            <summary>
            (分布式)服务器名称
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.AreaName">
            <summary>
            分布式(集群)服务器区域名称
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Server">
            <summary>
            服务器套接字
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.SocketAsync">
            <summary>
            IOCP套接字
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Rpcs">
            <summary>
            远程过程调用委托
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.RpcsDic">
            <summary>
            远程函数优化字典
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.RpcMaskDic">
            <summary>
            远程方法遮罩
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Clients">
            <summary>
            所有在线的客户端
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Players">
            <summary>
            所有在线的客户端 与<see cref="P:Net.Server.ServerBase`2.UIDClients"/>为互助字典 所添加的键值为<see cref="F:Net.Server.NetPlayer.playerID"/>
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.UIDClients">
            <summary>
            所有在线的客户端 与<see cref="P:Net.Server.ServerBase`2.Players"/>为互助字典 所添加的键值为<see cref="P:Net.Server.NetPlayer.UserID"/>
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.UnClients">
            <summary>
            未知客户端连接 或 刚连接服务器还未登录账号的IP
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.AllClients">
            <summary>
            所有客户端列表
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Scenes">
            <summary>
            服务器场景，key是场景名或房间名，关卡名。 value是(场景或房间，关卡等)对象
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Instance">
            <summary>
            网络服务器单例
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnlinePlayers">
            <summary>
            当前玩家在线人数
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Port">
            <summary>
            服务器端口
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.IsRunServer">
            <summary>
            服务器是否处于运行状态, 如果服务器套接字已经被释放则返回False, 否则返回True. 当调用Close方法后将改变状态
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.SyncFrequency">
            <summary>
            网络发送频率, 正常情况是每秒60次 (FPS)
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.SyncSceneTime">
            <summary>
            网络场景同步时间(帧同步间隔), 默认每33毫秒同步一次, 一秒同步30次, 可自己设置
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.LineUp">
            <summary>
            获取或设置最大可排队人数， 如果未知客户端人数超出LineUp值将不处理超出排队的未知客户端数据请求 ， 默认排队1000人
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnlineLimit">
            <summary>
            允许玩家在线人数最大值（玩家在线上限）默认2000人同时在线
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.exceededNumber">
            <summary>
            超出的排队人数，不处理的人数
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.blockConnection">
            <summary>
            服务器爆满, 阻止连接人数 与OnlineLimit属性有关
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.MainSceneName">
            <summary>
            服务器主场景名称
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.sendCount">
            <summary>
            网络统计发送数据长度/秒
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.sendAmount">
            <summary>
            网络统计发送次数/秒
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.resolveAmount">
            <summary>
            网络统计解析次数/秒
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.receiveAmount">
            <summary>
            网络统计接收次数/秒
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.receiveCount">
            <summary>
            网络统计接收长度/秒
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.sendLoopNum">
            <summary>
            发送线程循环次数 并发数,类似fps
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.revdLoopNum">
            <summary>
            接收线程循环次数(FPS)
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.frame">
            <summary>
            帧尾或叫数据长度(4) + CRC检验索引(1) + CRC校验码(1) = 6
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.StackBufferSize">
            <summary>
            允许叠包缓冲器最大值 默认可发送5242880(5M)的数据包
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.StackNumberMax">
            <summary>
            允许叠包最大次数，如果数据包太大，接收数据的次数超出StackNumberMax值，则会清除叠包缓存器 默认可叠包50次
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.HeartInterval">
            <summary>
            心跳时间间隔, 默认每2秒检查一次玩家是否离线, 玩家心跳确认为5次, 如果超出5次 则移除玩家客户端. 确认玩家离线总用时10秒, 
            如果设置的值越小, 确认的速度也会越快. 但发送的数据也会增加. [开发调式时尽量把心跳值设置高点]
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.HeartLimit">
            <summary>
            <para>心跳检测次数, 默认为5次检测, 如果5次发送心跳给客户端或服务器, 没有收到回应的心跳包, 则进入断开连接处理</para>
            <para>当一直有数据往来时是不会发送心跳数据的, 只有当没有数据往来了, 才会进入发送心跳数据</para>
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.UserIDNumber">
            <summary>
            由于随机数失灵导致死循环, 所以用计数来标记用户标识 (从10000开始标记)
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.ByteCompression">
            <summary>
            使用字节压缩吗? 如果使用: 当buffer数据大于1000时, 启用压缩功能
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.MTU">
            <summary>
            <para>（Maxium Transmission Unit）最大传输单元, 最大传输单元为1500字节, 这里默认为50000, 如果数据超过50000,则是该框架进行分片. 传输层则需要分片为50000/1472=34个数据片</para>
            <para>1.链路层：以太网的数据帧的长度为(64+18)~(1500+18)字节，其中18是数据帧的帧头和帧尾，所以数据帧的内容最大为1500字节（不包括帧头和帧尾），即MUT为1500字节</para>
            <para>2.网络层：IP包的首部要占用20字节，所以这里的MTU＝1500－20＝1480字节</para>
            <para>3.传输层：UDP包的首部要占有8字节，所以这里的MTU＝1480－8＝1472字节</para>
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.RTO">
            <summary>
            （Retransmission TimeOut）重传超时时间。 默认为50毫秒重传一次
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.RTOMode">
            <summary>
            超时重传模式 默认为可变重传
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.MTPS">
            <summary>
            (Maximum traffic per second) 每秒允许传输最大流量, 默认最大每秒可以传输1m大小
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.UnClientNumber">
            <summary>
            未知客户端人数, 即在线不登录账号的客户端
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.MaxThread">
            <summary>
            并发线程数量, 发送线程和接收处理线程数量
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.onlineNumber">
            <summary>
            在线客户端数量
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.IsEthernet">
            <summary>
            是以太网? 此属性控制组包发送时,执行一次能把n个数据包组合在一起, 然后一次发送, 全由数据包大小决定. 如果此属性是以太网(true), 则根据mut来判断, 否则是局域网, 固定值50000字节
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.PackageLength">
            <summary>
            组包数量，如果是一些小数据包，最多可以组合多少个？ 默认是组合1000个后发送
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.rootPath">
            <summary>
            程序根路径, 网络数据缓存读写路径
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnStartingHandle">
            <summary>
            开始运行服务器事件
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnStartupCompletedHandle">
            <summary>
            服务器启动成功事件
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnHasConnectHandle">
            <summary>
            当前有客户端连接触发事件
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnAddClientHandle">
            <summary>
            当添加客户端到所有在线的玩家集合中触发的事件
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnRevdBufferHandle">
            <summary>
            当接收到自定义的网络指令时处理事件
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnRemoveClientHandle">
            <summary>
            当移除客户端时触发事件
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnNetworkDataTraffic">
            <summary>
            当统计网络流量时触发
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnOperationSyncHandle">
            <summary>
            当客户端在时间帧发送的操作数据， 当使用客户端的<see cref="M:Net.Client.ClientBase.AddOperation(Net.Share.Operation)"/>方法时调用
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnRevdRTProgressHandle">
            <summary>
            当客户端发送的大数据时, 可监听此事件显示进度值
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnSendRTProgressHandle">
            <summary>
            当服务器发送可靠数据时, 可监听此事件显示进度值 (NetworkServer,TcpServer类无效)
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Log">
            <summary>
            输出日志, 这里是输出全部日志(提示,警告,错误等信息). 如果想只输出指定的日志, 请使用NDebug类进行监听
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.OnPingCallback">
            <summary>
            ping服务器回调 参数double为延迟毫秒单位 当<see cref="P:Net.Server.ServerBase`2.RTOMode"/>=<see cref="F:Net.Share.RTOMode.Variable"/>可变重传时, 内核将会每秒自动ping一次
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.OnSendErrorHandle">
            <summary>
            当socket发送失败调用.参数1:玩家对象, 参数2:发送的字节数组, 参数3:发送标志(可靠和不可靠)  ->可通过<see cref="M:Net.Server.ServerBase`2.SendByteData(`0,System.Byte[],System.Boolean)"/>方法重新发送
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnAddRpcHandle">
            <summary>
            当添加远程过程调用方法时调用， 参数1：要收集rpc特性的对象， 参数2：如果服务器的rpc中已经有了这个对象，还可以添加进去？
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnRemoveRpc">
            <summary>
            当移除远程过程调用对象， 参数1：移除此对象的所有rpc方法
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnRPCExecute">
            <summary>
            当执行调用远程过程方法时触发
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnSerializeRPC">
            <summary>
            当序列化远程过程调用方法
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnDeserializeRPC">
            <summary>
            当反序列化远程过程调用方法
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnSerializeOPT">
            <summary>
            当序列化远程过程调用操作
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.OnDeserializeOPT">
            <summary>
            当反序列化远程过程调用操作
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Seqencing">
            <summary>
            可靠传输是排队模式? 排队模式下, 可靠包是一个一个处理. 不排队模式: 可靠传输数据组成多列并发 ---> 默认是无排队模式
            </summary>
        </member>
        <member name="F:Net.Server.ServerBase`2.threads">
            <summary>
            服务器线程管理
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.#ctor">
            <summary>
            构造网络服务器函数
            </summary>
        </member>
        <member name="P:Net.Server.ServerBase`2.Item(System.Net.EndPoint)">
            <summary>
            玩家索引
            </summary>
            <param name="remotePoint"></param>
            <returns></returns>
        </member>
        <member name="P:Net.Server.ServerBase`2.Item(System.Int32)">
            <summary>
            uid索引
            </summary>
            <param name="uid"></param>
            <returns></returns>
        </member>
        <member name="P:Net.Server.ServerBase`2.Item(System.String)">
            <summary>
            场景索引
            </summary>
            <param name="sceneID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.GetClients">
            <summary>
            获得所有在线的客户端对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.GetScenes">
            <summary>
            获得所有服务器场景
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnUnClientRequest(`0,Net.Share.RPCModel)">
            <summary>
            当未知客户端发送数据请求，返回<see langword="false"/>，不允许<see langword="unClient"/>进入服务器!，如果返回的是<see langword="true"/>，则允许<see langword="unClient"/>客户端进入服务器
            同时会将<see langword="unClient"/>添加到<see cref="P:Net.Server.ServerBase`2.Players"/>和<see cref="P:Net.Server.ServerBase`2.UIDClients"/>在线字典中.
            <code>客户端玩家的入口点，在这里可以控制客户端是否可以进入服务器与其他客户端进行网络交互</code>
            在这里可以用来判断客户端登录和注册等等进站许可 (默认是允许进入服务器)
            </summary>
            <param name="unClient">尚未登录的客户端对象</param>
            <param name="model">数据模型</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnStarting">
            <summary>
            当开始启动服务器
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnStartupCompleted">
            <summary>
            当服务器启动完毕
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnAddDefaultScene">
            <summary>
            当添加默认网络场景，服务器初始化后会默认创建一个主场景，供所有玩家刚登陆成功分配的临时场景，默认初始化场景人数为1000人
            </summary>
            <returns>返回值string：网络玩家所在的场景名称 , 返回值NetScene：网络玩家的场景对象</returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnAddPlayerToScene(`0)">
            <summary>
            当添加玩家到默认场景， 如果不想添加刚登录游戏成功的玩家进入主场景，可重写此方法让其失效
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnHasConnect(`0)">
            <summary>
            当有客户端连接
            </summary>
            <param name="client">客户端套接字</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnRemoveClient(`0)">
            <summary>
            当服务器判定客户端为断线或连接异常时，移除客户端时调用
            </summary>
            <param name="client">要移除的客户端</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnInvokeRpc(`0)">
            <summary>
            当开始调用服务器RPC函数 或 开始调用自定义网络命令时 可设置请求客户端的client为全局字段，方便在服务器RPC函数内引用!!!
            在多线程时有1%不安全，当出现client赋值到其他玩家对象时，可在网络方法加<see langword="[Rpc(NetCmd.SafeCall)]"/>特性
            </summary>
            <param name="client">发送请求数据的客户端</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnReceiveBuffer(`0,Net.Share.RPCModel)">
            <summary>
            当接收到客户端自定义数据请求,在这里可以使用你自己的网络命令，系列化方式等进行解析网络数据。（你可以在这里使用ProtoBuf或Json来解析网络数据）
            </summary>
            <param name="client">当前客户端</param>
            <param name="model"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnOperationSync(`0,Net.Share.OperationList)">
            <summary>
            当接收到客户端使用<see cref="M:Net.Client.ClientBase.AddOperation(Net.Share.Operation)"/>方法发送的请求时调用
            </summary>
            <param name="client">当前客户端</param>
            <param name="list">操作列表</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnRevdRTProgress(`0,Net.Share.RTProgress)">
            <summary>
            当客户端发送的大数据时, 可监听此事件显示进度值
            </summary>
            <param name="client"></param>
            <param name="progress"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnSendRTProgress(`0,Net.Share.RTProgress)">
            <summary>
            当服务器发送的大数据时, 可监听此事件显示进度值
            </summary>
            <param name="client"></param>
            <param name="progress"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnSerializeRpc(Net.Share.RPCModel)">
            <summary>
            当内核序列化远程函数时调用, 如果想改变内核rpc的序列化方式, 可重写定义序列化协议
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnDeserializeRpc(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当内核解析远程过程函数时调用, 如果想改变内核rpc的序列化方式, 可重写定义解析协议
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.Run(System.UInt16)">
            <summary>
            运行服务器
            </summary>
            <param name="port">服务器端口号</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Start(System.UInt16)">
            <summary>
            启动服务器
            </summary>
            <param name="port">端口</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SceneUpdateHandle">
            <summary>
            网络场景推动玩家同步更新处理线程, 如果想自己处理场景同步, 可重写此方法让同步失效
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.DataTrafficThread">
            <summary>
            流量统计线程
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.UdpStartReceive">
            <summary>
            Udp开始接收数据
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.LoginHandle(`0)">
            <summary>
            主动登录服务器, 类似OnUnClientRequest重写方法的返回值为true
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnExceededNumber(System.Net.EndPoint)">
            <summary>
            当服务器连接人数溢出时调用
            </summary>
            <param name="remotePoint"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnBlockConnection(System.Net.EndPoint)">
            <summary>
            当服务器爆满时调用
            </summary>
            <param name="remotePoint"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SendDirect(`0)">
            <summary>
            立刻发送, 不需要等待帧时间 (当你要强制把客户端下线时,你还希望客户端先发送完数据后,再强制客户端退出游戏用到)
            </summary>
            <param name="client"></param>
        </member>
        <member name="F:Net.Server.ServerBase`2.CRCCode">
            <summary>
            CRC校验代码表, 使用者可自行改变CRC校验码, 直接改源代码，重要提示：客户端的CRC表必须和这里的CRC表保持一致
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnCRC(System.Int32,System.Byte)">
            <summary>
            当处理CRC校验
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.OnRpcExecute(`0,Net.Share.RPCModel)">
            <summary>
            当执行Rpc(远程过程调用函数)时, 如果想提供服务器效率, 可以重写此方法, 指定要调用的方法, 可以提高服务器性能 (默认反射调用)
            </summary>
            <param name="client">客户端</param>
            <param name="model">数据模型</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.CheckHeartHandle">
            <summary>
            心跳检测处理线程
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.HeartHandle">
            <summary>
            心跳处理
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.CreateScene(`0,System.String)">
            <summary>
            创建网络场景, 退出当前场景,进入所创建的场景 - 创建场景成功返回场景对象， 创建失败返回null
            </summary>
            <param name="player">创建网络场景的玩家实体</param>
            <param name="sceneID">要创建的场景号或场景名称</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.CreateScene(`0,`1,System.Action{`1})">
            <summary>
            创建网络场景, 退出当前场景并加入所创建的场景 - 创建场景成功返回场景对象， 创建失败返回null
            </summary>
            <param name="player">创建网络场景的玩家实体</param>
            <param name="scene">创建场景的实体</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.CreateScene(`0,System.String,`1,System.Action{`1})">
            <summary>
            创建网络场景, 退出当前场景并加入所创建的场景 - 创建场景成功返回场景对象， 创建失败返回null
            </summary>
            <param name="player">创建网络场景的玩家实体</param>
            <param name="sceneID">要创建的场景号或场景名称</param>
            <param name="scene">创建场景的实体</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.CreateScene(System.String)">
            <summary>
            创建一个场景, 成功则返回场景对象, 创建失败则返回null
            </summary>
            <param name="sceneID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.CreateScene(System.String,`1)">
            <summary>
            创建一个场景, 成功则返回场景对象, 创建失败则返回null
            </summary>
            <param name="sceneID"></param>
            <param name="scene"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.JoinScene(`0,System.String,System.Action{`1})">
            <summary>
            退出当前场景,加入指定的场景 - 成功进入返回场景对象，进入失败返回null
            </summary>
            <param name="player">要进入sceneID场景的玩家实体</param>
            <param name="sceneID">场景ID，要切换到的场景号或场景名称</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.EnterScene(`0,System.String,System.Action{`1})">
            <summary>
            进入场景 - 成功进入返回true，进入失败返回false
            </summary>
            <param name="player">要进入sceneID场景的玩家实体</param>
            <param name="sceneID">场景ID，要切换到的场景号或场景名称</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.SwitchScene(`0,System.String,System.Action{`1})">
            <summary>
            退出当前场景,切换到指定的场景 - 成功进入返回true，进入失败返回false
            </summary>
            <param name="player">要进入sceneID场景的玩家实体</param>
            <param name="sceneID">场景ID，要切换到的场景号或场景名称</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.ExitScene(`0,System.Boolean,System.Action{`1})">
            <summary>
            退出场景 exitCurrentSceneCall回调时已经不包含player对象
            </summary>
            <param name="player"></param>
            <param name="isEntMain">退出当前场景是否进入主场景: 默认进入主场景</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.RemoveScene(System.String,System.Boolean,System.Action{`1})">
            <summary>
            移除服务器场景. 从服务器总场景字典中移除指定的场景: 当你移除指定场景后,如果场景内有其他玩家在内, 则把其他玩家添加到主场景内
            </summary>
            <param name="sceneID">要移除的场景id</param>
            <param name="addToMainScene">允许即将移除的场景内的玩家添加到主场景?</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.RemoveScenePlayer(`0,System.Boolean,System.Action{`1})">
            <summary>
            将玩家从当前所在的场景移除掉， 移除之后此客户端将会进入默认主场景 call回调时已经不包含player对象
            </summary>
            <param name="player">要执行的玩家实体</param>
            <param name="isEntMain">退出当前场景是否进入主场景: 默认进入主场景</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.DeletePlayer(`0)">
            <summary>
            从所有在线玩家字典中删除(移除)玩家实体
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.RemovePlayer(`0)">
            <summary>
            从所有在线玩家字典中移除玩家实体
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.RemoveClient(`0)">
            <summary>
            从客户端字典中移除客户端
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.IsHasScene(System.String)">
            <summary>
            场景是否存在?
            </summary>
            <param name="sceneID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.Close">
            <summary>
            关闭服务器
            </summary>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Byte[])">
            <summary>
            发送网络数据
            </summary>
            <param name="client">发送数据到的客户端</param>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Byte,System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="client">发送到客户端</param>
            <param name="cmd">网络命令</param>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Boolean,System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="client">发送到客户端</param>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Byte,System.Boolean,System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="client">发送到客户端</param>
            <param name="cmd">网络命令</param>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.String,System.Object[])">
            <summary>
            发送网络数据
            </summary>
            <param name="client">发送数据到的客户端</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Byte,System.String,System.Object[])">
            <summary>
            发送网络数据
            </summary>
            <param name="client">发送到的客户端</param>
            <param name="cmd">网络命令</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Boolean,System.String,System.Object[])">
            <summary>
            发送网络数据
            </summary>
            <param name="client">发送到的客户端</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Byte,System.Boolean,System.String,System.Object[])">
            <summary>
            发送网络数据
            </summary>
            <param name="client">发送到的客户端</param>
            <param name="cmd">网络命令</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Send(`0,System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            发送灵活数据包
            </summary>
            <param name="client">客户端集合</param>
            <param name="cmd"></param>
            <param name="buffer">要包装的数据,你自己来定</param>
            <param name="kernel">内核? 你包装的数据在客户端是否被内核NetConvert序列化?</param>
            <param name="serialize">序列化? 你包装的数据是否在服务器即将发送时NetConvert序列化?</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SendRT(`0,System.String,System.Object[])">
            <summary>
            发送网络可靠传输数据, 可以发送大型文件数据
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SendRT(`0,System.Byte,System.String,System.Object[])">
            <summary>
            发送可靠网络传输, 可以发送大型文件数据
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="cmd">网络命令</param>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SendRT(`0,System.Byte[])">
            <summary>
            发送可靠网络传输, 可发送大数据流
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SendRT(`0,System.Byte,System.Byte[])">
            <summary>
            发送可靠网络传输, 可发送大数据流
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="cmd">网络命令</param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SendRT(`0,System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            发送灵活数据包
            </summary>
            <param name="client">客户端集合</param>
            <param name="cmd"></param>
            <param name="buffer">要包装的数据,你自己来定</param>
            <param name="kernel">内核? 你包装的数据在客户端是否被内核NetConvert序列化?</param>
            <param name="serialize">序列化? 你包装的数据是否在服务器即将发送时NetConvert序列化?</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Byte,System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="cmd"></param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable"></param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte,System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">使用可靠传输?</param>
            <param name="cmd">网络命令</param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            网络多播, 发送数据到clients集合的客户端 (灵活数据包)
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable"></param>
            <param name="cmd"></param>
            <param name="buffer">要包装的数据,你自己来定</param>
            <param name="kernel">内核? 你包装的数据在客户端是否被内核NetConvert序列化?</param>
            <param name="serialize">序列化? 你包装的数据是否在服务器即将发送时NetConvert序列化?</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">使用可靠传输?</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Byte,System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="cmd">网络命令</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte,System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">使用可靠传输?</param>
            <param name="cmd">网络命令</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.AddRpcHandle(System.Object)">
            <summary>
            添加网络Rpc(注册远程方法)
            </summary>
            <param name="target">注册的对象实例</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.AddRpcHandle(System.Object,System.Boolean)">
            <summary>
            添加网络Rpc(注册远程方法)
            </summary>
            <param name="target">注册的对象实例</param>
            <param name="append">一个Rpc方法是否可以多次添加到Rpcs里面？</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.RemoveRpc(System.Object)">
            <summary>
            移除对象的Rpc注册
            </summary>
            <param name="target">将此对象的所有带有RPCFun特性的函数移除</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.IsOnline(System.String)">
            <summary>
            playerID玩家是否在线?
            </summary>
            <param name="playerID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.IsOnline(System.String,`0@)">
            <summary>
            playerID玩家是否在线? 并且如果在线则out 在线玩家的对象
            </summary>
            <param name="playerID"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.ServerBase`2.OfflineHandle(`0)">
            <summary>
            强制下线处理, 将client客户端从在线字段<see cref="P:Net.Server.ServerBase`2.Players"/>和<see cref="P:Net.Server.ServerBase`2.UIDClients"/>和<see cref="P:Net.Server.ServerBase`2.AllClients"/>字段中移除
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SignOut(`0)">
            <summary>
            退出登录, 将client客户端从在线字段<see cref="P:Net.Server.ServerBase`2.Players"/>和<see cref="P:Net.Server.ServerBase`2.UIDClients"/>字段中移除
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.SetHeartTime(System.Byte,System.Int32)">
            <summary>
            设置心跳时间
            </summary>
            <param name="timeoutLimit">心跳检测次数, 默认检测5次</param>
            <param name="interval">心跳时间间隔, 每interval毫秒会检测一次</param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Ping(`0)">
            <summary>
            ping测试网络延迟, 通过<see cref="F:Net.Server.ServerBase`2.OnPingCallback"/>事件回调
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.Ping(`0,System.Action{`0,System.Double})">
            <summary>
            ping测试网络延迟, 此方法帮你监听<see cref="F:Net.Server.ServerBase`2.OnPingCallback"/>事件, 如果不使用的时候必须保证能移除委托, 建议不要用框名函数, 那样会无法移除委托
            </summary>
            <param name="client"></param>
            <param name="callback"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.AddAdapter(Net.Share.IAdapter)">
            <summary>
            添加适配器
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.AddAdapter(Net.Share.AdapterType,Net.Share.IAdapter)">
            <summary>
            添加适配器
            </summary>
            <param name="type"></param>
            <param name="adapter"></param>
        </member>
        <member name="M:Net.Server.ServerBase`2.VarSyncHandler">
            <summary>
            字段,属性同步线程
            </summary>
        </member>
        <member name="T:Net.Server.DNPlayer">
            <summary>
            dotNetty客户端玩家对象
            </summary>
        </member>
        <member name="F:Net.Server.DNPlayer.channel">
            <summary>
            此客户端的网络通道
            </summary>
        </member>
        <member name="T:Net.Server.DotNettyServer`2">
            <summary>
            dotNetty服务器类
            </summary>
            <typeparam name="Player"></typeparam>
            <typeparam name="Scene"></typeparam>
        </member>
        <member name="T:Net.Server.ENetServer`2">
            <summary>
            ENet服务器类型
            第三版本 2020.9.14
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="F:Net.Server.ENetServer`2.Server">
            <summary>
            enet服务器对象
            </summary>
        </member>
        <member name="T:Net.Server.NetPeer">
            <summary>
            enet客户端对象
            </summary>
        </member>
        <member name="P:Net.Server.NetPeer.EClient">
            <summary>
            ENet客户端对象
            </summary>
        </member>
        <member name="P:Net.Server.NetPeer.ChannelID">
            <summary>
            ENet网络通道ID
            </summary>
        </member>
        <member name="T:Net.Server.NetworkServer`2">
            <summary>
            双通讯(tcp, udp)服务器 当使用Send发送数据时, 使用udp协议发送. 当使用SendRT发送数据时, 使用tcp协议发送
            当Send发送数据大于50000字节后内部自动转换为tcp协议发送
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
            <typeparam name="Player"></typeparam>
            <typeparam name="Scene"></typeparam>
        </member>
        <member name="P:Net.Server.NetworkServer`2.UdpSocketAsync">
            <summary>
            UDP的IOCP套接字
            </summary>
        </member>
        <member name="F:Net.Server.NetworkServer`2.frame">
            <summary>
            帧尾或叫数据长度(4) + CRC检验索引(1) + CRC校验码(1) + 玩家id(4) = 10
            </summary>
        </member>
        <member name="P:Net.Server.NetworkServer`2.TcpServer">
            <summary>
            tcp服务器套接字
            </summary>
        </member>
        <member name="T:Net.Server.RawServer`2">
            <summary>
            原始Udp服务器, 内部处理了IP头部
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="M:Net.Server.RawServer`2.Start(System.UInt16)">
            <summary>
            启动服务器
            </summary>
            <param name="port">端口</param>
        </member>
        <member name="T:Net.Server.TcpServer`2">
            <summary>
            TCP服务器类型
            第三版本 2020.9.14
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="T:Net.Server.TcpServerIOCP`2">
            <summary>
            tcp 输入输出完成端口服务器
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="T:Net.Server.UdpServer`2">
            <summary>
            Udp网络服务器
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="M:Net.Server.UdpServer`2.Start(System.UInt16)">
            <summary>
            启动服务器
            </summary>
            <param name="port">端口</param>
        </member>
        <member name="T:Net.Server.UdpServerIOCP`2">
            <summary>
            udp 输入输出完成端口服务器
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
            <typeparam name="Player"></typeparam>
            <typeparam name="Scene"></typeparam>
        </member>
        <member name="T:Net.Server.KcpPlayer">
            <summary>
            kcp客户端对象
            </summary>
        </member>
        <member name="P:Net.Server.KcpPlayer.Kcp">
            <summary>
            kcp对象
            </summary>
        </member>
        <member name="T:Net.Server.KcpServer`2">
            <summary>
            kcp服务器
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
            <typeparam name="Player"></typeparam>
            <typeparam name="Scene"></typeparam>
        </member>
        <member name="T:Net.Server.UdxPlayer">
            <summary>
            udx客户端对象
            </summary>
        </member>
        <member name="T:Net.Server.UdxServer`2">
            <summary>
            udx服务器类型  只能300人以下连接, 如果想要300个客户端以上, 请进入udx网址:www.goodudx.com 联系作者下载专业版FastUdxApi.dll, 然后更换下框架内的FastUdxApi.dll即可
            第三版本 2020.9.14
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="F:Net.Server.UdxServer`2.Server">
            <summary>
            udx服务器对象
            </summary>
        </member>
        <member name="T:Net.Server.WebPlayer">
            <summary>
            web客户端对象
            </summary>
        </member>
        <member name="P:Net.Server.WebPlayer.WSClient">
            <summary>
            webSocket套接字
            </summary>
        </member>
        <member name="T:Net.Server.WebServer`2">
            <summary>
            web网络服务器 2020.8.25 七夕
            通过JavaScript脚本, httml网页进行连接. 和 WebClient连接
            客户端发送的数据请求请看Net.Share.MessageModel类定义
            <para>Player:当有客户端连接服务器就会创建一个Player对象出来, Player对象和XXXClient是对等端, 每当有数据处理都会通知Player对象. </para>
            <para>Scene:你可以定义自己的场景类型, 比如帧同步场景处理, mmorpg场景什么处理, 可以重写Scene的Update等等方法实现每个场景的更新和处理. </para>
            </summary>
        </member>
        <member name="P:Net.Server.WebServer`2.Server">
            <summary>
            webSocket服务器套接字
            </summary>
        </member>
        <member name="P:Net.Server.WebServer`2.OnWSRevdBufferHandle">
            <summary>
            当web服务器接收到网络数据处理事件
            </summary>
        </member>
        <member name="M:Net.Server.WebServer`2.OnWSReceiveBuffer(`0,Net.Share.MessageModel)">
            <summary>
            当web服务器接收到客户端其他指令的数据请求
            </summary>
            <param name="client">当前客户端</param>
            <param name="model"></param>
        </member>
        <member name="M:Net.Server.WebServer`2.OnWSUnClientRequest(`0,Net.Share.MessageModel)">
            <summary>
            当webScoket未知客户端发送数据请求，返回null，不允许unClient进入服务器!，返回对象，允许unClient客户端进入服务器
            客户端玩家的入口点，在这里可以控制客户端是否可以进入服务器与其他客户端进行网络交互
            在这里可以用来判断客户端登录和注册等等进站许可
            </summary>
            <param name="unClient">客户端终端</param>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Server.WebServer`2.Start(System.UInt16)">
            <summary>
            启动服务器
            </summary>
            <param name="port">端口</param>
        </member>
        <member name="M:Net.Server.WebServer`2.OnExceededNumber(Fleck.WebSocketConnection)">
            <summary>
            当服务器连接人数溢出时调用
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Net.Server.WebServer`2.OnBlockConnection(Fleck.WebSocketConnection)">
            <summary>
            当服务器爆满时调用
            </summary>
            <param name="client"></param>
        </member>
        <member name="T:Net.Share.NetworkState">
            <summary>
            网络状态
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.None">
            <summary>
            无状态
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.Connected">
            <summary>
            连接成功
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.ConnectFailed">
            <summary>
            连接失败
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.TryToConnect">
            <summary>
            尝试连接
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.Disconnect">
            <summary>
            断开连接
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.ConnectLost">
            <summary>
            连接中断 (连接异常)
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.ConnectClosed">
            <summary>
            连接已被关闭
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.Connection">
            <summary>
            正在连接服务器中...
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.Reconnect">
            <summary>
            断线重连成功
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.ExceededNumber">
            <summary>
            服务器连接人数溢出, 服务器忽略当前客户端的所有Rpc请求
            </summary>
        </member>
        <member name="F:Net.Share.NetworkState.BlockConnection">
            <summary>
            服务器爆满, 服务器忽略当前客户端的所有Rpc请求
            </summary>
        </member>
        <member name="T:Net.Share.Constituency">
            <summary>
            选区网络传输对象
            </summary>
        </member>
        <member name="F:Net.Share.Constituency.name">
            <summary>
            服务器区名
            </summary>
        </member>
        <member name="F:Net.Share.Constituency.online">
            <summary>
            当前在线人数
            </summary>
        </member>
        <member name="F:Net.Share.Constituency.status">
            <summary>
            当前服务器区域状态, 顺畅，拥挤，爆满
            </summary>
        </member>
        <member name="F:Net.Share.Constituency.ip">
            <summary>
            服务器区ip
            </summary>
        </member>
        <member name="F:Net.Share.Constituency.port">
            <summary>
            服务器区端口
            </summary>
        </member>
        <member name="T:Net.Share.EventHandle">
            <summary>
            事件处理结构
            </summary>
        </member>
        <member name="F:Net.Share.EventHandle.obj">
            <summary>
            事件对象
            </summary>
        </member>
        <member name="F:Net.Share.EventHandle.action">
            <summary>
            事件委托
            </summary>
        </member>
        <member name="M:Net.Share.EventHandle.#ctor(System.Action{System.Object},System.Object)">
            <summary>
            构造
            </summary>
            <param name="action"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Share.EventHandle.Invoke">
            <summary>
            处理事件
            </summary>
        </member>
        <member name="T:Net.Share.IAdapter">
            <summary>
            基础适配器接口
            </summary>
        </member>
        <member name="T:Net.Share.ISerializeAdapter">
            <summary>
            序列化适配器
            </summary>
        </member>
        <member name="T:Net.Share.IRPCAdapter">
            <summary>
            客户端RPC适配器
            </summary>
        </member>
        <member name="M:Net.Share.IRPCAdapter.CheckRpcUpdate">
            <summary>
            每50毫秒调用检查rpc是否被释放
            </summary>
        </member>
        <member name="T:Net.Share.IRPCAdapter`1">
            <summary>
            服务器RPC适配器
            </summary>
            <typeparam name="Player"></typeparam>
        </member>
        <member name="T:Net.Share.INetworkEvtAdapter">
            <summary>
            网络事件适配器
            </summary>
        </member>
        <member name="T:Net.Share.IDebugHandle">
            <summary>
            网络调式日志信息处理接口
            </summary>
        </member>
        <member name="M:Net.Share.IDebugHandle.Log(System.String)">
            <summary>
            当输出信息
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Net.Share.IDebugHandle.LogRpc(System.String)">
            <summary>
            当远程过程调用函数
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Net.Share.INetClient">
            <summary>
            网络客户端接口处理 2019.7.9
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnConnectedHandle">
            <summary>
            当连接服务器成功事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnConnectFailedHandle">
            <summary>
            当连接失败事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnTryToConnectHandle">
            <summary>
            当尝试连接服务器事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnConnectLostHandle">
            <summary>
            当连接中断 (异常) 事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnDisconnectHandle">
            <summary>
            当断开连接事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnRevdBufferHandle">
            <summary>
            当接收到网络数据处理事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnReconnectHandle">
            <summary>
            当断线重连成功触发事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnCloseConnectHandle">
            <summary>
            当关闭连接事件
            </summary>
        </member>
        <member name="E:Net.Share.INetClient.OnNetworkDataTraffic">
            <summary>
            当统计网络流量时触发
            </summary>
        </member>
        <member name="T:Net.Share.SerializeHandle">
            <summary>
            序列化处理程序
            </summary>
        </member>
        <member name="T:Net.Share.DeserializeHandle">
            <summary>
            反序列化处理程序
            </summary>
            <param name="buffer">数据缓冲区</param>
            <param name="index">当前解析数据的索引</param>
            <param name="type">解析的类型</param>
            <returns>返回解析后的对象实例</returns>
        </member>
        <member name="T:Net.Share.INetworkHandle">
            <summary>
            网络状态处理接口
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnConnected">
            <summary>
            当连接成功
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnConnectFailed">
            <summary>
            当连接失败
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnConnectLost">
            <summary>
            当连接中断
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnDisconnect">
            <summary>
            当主动断开连接
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnTryToConnect">
            <summary>
            当尝试重连
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnReconnect">
            <summary>
            当重连成功
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnCloseConnect">
            <summary>
            当关闭连接
            </summary>
        </member>
        <member name="M:Net.Share.INetworkHandle.OnBlockConnection">
            <summary>
            当服务器已爆满
            </summary>
        </member>
        <member name="T:Net.Share.INetworkSceneHandle`2">
            <summary>
            网络场景处理接口
            </summary>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.CreateScene(`0,System.String)">
            <summary>
            创建网络场景, 退出当前场景,进入所创建的场景 - 创建场景成功返回场景对象， 创建失败返回null
            </summary>
            <param name="player">创建网络场景的玩家实体</param>
            <param name="sceneID">要创建的场景号或场景名称</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.CreateScene(`0,System.String,`1,System.Action{`1})">
            <summary>
            创建网络场景, 退出当前场景并加入所创建的场景 - 创建场景成功返回场景对象， 创建失败返回null
            </summary>
            <param name="player">创建网络场景的玩家实体</param>
            <param name="sceneID">要创建的场景号或场景名称</param>
            <param name="scene">创建场景的实体</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.JoinScene(`0,System.String,System.Action{`1})">
            <summary>
            退出当前场景,加入指定的场景 - 成功进入返回场景对象，进入失败返回null
            </summary>
            <param name="player">要进入sceneID场景的玩家实体</param>
            <param name="sceneID">场景ID，要切换到的场景号或场景名称</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.EnterScene(`0,System.String,System.Action{`1})">
            <summary>
            进入场景 - 成功进入返回true，进入失败返回false
            </summary>
            <param name="player">要进入sceneID场景的玩家实体</param>
            <param name="sceneID">场景ID，要切换到的场景号或场景名称</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.SwitchScene(`0,System.String,System.Action{`1})">
            <summary>
            退出当前场景,切换到指定的场景 - 成功进入返回true，进入失败返回false
            </summary>
            <param name="player">要进入sceneID场景的玩家实体</param>
            <param name="sceneID">场景ID，要切换到的场景号或场景名称</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.ExitScene(`0,System.Boolean,System.Action{`1})">
            <summary>
            退出场景
            </summary>
            <param name="player"></param>
            <param name="addToMainScene">退出当前场景是否进入主场景: 默认进入主场景</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.RemoveScene(System.String,System.Boolean,System.Action{`1})">
            <summary>
            移除服务器场景. 从服务器总场景字典中移除指定的场景: 当你移除指定场景后,如果场景内有其他玩家在内, 则把其他玩家添加到主场景内
            </summary>
            <param name="sceneID">要移除的场景id</param>
            <param name="addToMainScene">允许即将移除的场景内的玩家添加到主场景?</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.RemoveScenePlayer(`0,System.Boolean,System.Action{`1})">
            <summary>
            将玩家从当前所在的场景移除掉， 移除之后此客户端将会进入默认主场景
            </summary>
            <param name="player">要执行的玩家实体</param>
            <param name="addToMainScene">退出当前场景是否进入主场景: 默认进入主场景</param>
            <param name="exitCurrentSceneCall">即将退出当前场景的处理委托函数: 如果你需要对即将退出的场景进行一些事后处理, 则在此委托函数执行! 如:退出当前场景通知当前场景内的其他客户端将你的玩家对象移除等功能</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.DeletePlayer(`0)">
            <summary>
            从所有在线玩家字典中删除(移除)玩家实体
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.RemovePlayer(`0)">
            <summary>
            从所有在线玩家字典中移除玩家实体
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:Net.Share.INetworkSceneHandle`2.RemoveClient(`0)">
            <summary>
            从客户端字典中移除客户端
            </summary>
            <param name="client"></param>
        </member>
        <member name="T:Net.Share.ISendHandle">
            <summary>
            发送处理程序接口 
            2019.9.23
            </summary>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.Byte,System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="cmd">网络命令</param>
            <param name="buffer">发送字节数组缓冲区</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.Byte,System.Object)">
            <summary>
            发送自定义协议类型, 使用protobuf序列化obj对象
            </summary>
            <param name="cmd">网络命令</param>
            <param name="obj">使用protobuf序列化的对象</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.String,System.Object[])">
            <summary>
            发送远程过程调用函数数据
            </summary>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.Byte,System.String,System.Object[])">
            <summary>
            发送带有网络命令的远程过程调用数据
            </summary>
            <param name="cmd">网络命令</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.CallRpc(System.String,System.Object[])">
            <summary>
            远程过程调用 同Send方法
            </summary>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.CallRpc(System.Byte,System.String,System.Object[])">
            <summary>
            远程过程调用 同Send方法
            </summary>
            <param name="cmd">网络命令，请看NetCmd类定义</param>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Request(System.String,System.Object[])">
            <summary>
            网络请求 同Send方法
            </summary>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Request(System.Byte,System.String,System.Object[])">
            <summary>
            网络请求 同Send方法
            </summary>
            <param name="cmd">网络命令，请看NetCmd类定义</param>
            <param name="func">Call名</param>
            <param name="pars">Call函数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.String,System.Object[])">
            <summary>
            发送网络可靠传输数据, 可以发送大型文件数据
            调用此方法通常情况下是一定把数据发送成功为止
            </summary>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.Byte,System.String,System.Object[])">
            <summary>
            发送可靠网络传输, 可以发送大型文件数据
            调用此方法通常情况下是一定把数据发送成功为止
            </summary>
            <param name="cmd">网络命令</param>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.Byte[])">
            <summary>
            发送可靠网络传输, 可发送大数据流
            调用此方法通常情况下是一定把数据发送成功为止
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.Byte,System.Byte[])">
            <summary>
            发送可靠网络传输, 可发送大数据流
            调用此方法通常情况下是一定把数据发送成功为止
            </summary>
            <param name="cmd">网络命令</param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.Byte,System.Object)">
            <summary>
            发送自定义协议类型, 使用protobuf序列化obj对象
            </summary>
            <param name="cmd">网络命令</param>
            <param name="obj">使用protobuf序列化的对象</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.String,System.String,System.Delegate,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.String,System.String,System.Delegate,System.Int32,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.Send(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Threading.SynchronizationContext,System.Object[])">
            <summary>
            发送请求, 异步回调
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="context">调用上下文线程对象</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.String,System.String,System.Delegate,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.String,System.String,System.Delegate,System.Int32,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="M:Net.Share.ISendHandle.SendRT(System.Byte,System.String,System.String,System.Delegate,System.Int32,System.Action,System.Threading.SynchronizationContext,System.Object[])">
            <summary>
            发送请求, 并且监听服务端的回调请求, 服务器回调请求要对应上发送时的回调匿名, 异步回调, 并且在millisecondsDelay时间内要响应, 否则调用outTimeAct
            </summary>
            <param name="cmd">指令</param>
            <param name="func">服务器函数名</param>
            <param name="funcCB">服务器回调函数名</param>
            <param name="callback">回调接收委托</param>
            <param name="millisecondsDelay">异步时间</param>
            <param name="outTimeAct">异步超时调用</param>
            <param name="context">调用上下文线程</param>
            <param name="pars">远程参数</param>
        </member>
        <member name="T:Net.Share.IServerEventHandle`1">
            <summary>
            网络服务器事件处理
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.OnStartingHandle">
            <summary>
            开始运行服务器事件
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.OnStartupCompletedHandle">
            <summary>
            服务器启动成功事件
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.OnHasConnectHandle">
            <summary>
            当前有客户端连接触发事件
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.OnAddClientHandle">
            <summary>
            当添加客户端到所有在线的玩家集合中触发的事件
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.OnRevdBufferHandle">
            <summary>
            当接收到网络数据处理事件
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.OnRemoveClientHandle">
            <summary>
            当移除客户端时触发事件
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.OnNetworkDataTraffic">
            <summary>
            当统计网络流量时触发
            </summary>
        </member>
        <member name="P:Net.Share.IServerEventHandle`1.Log">
            <summary>
            输出日志
            </summary>
        </member>
        <member name="T:Net.Share.IServerHandle`2">
            <summary>
            用户对接基类服务器
            </summary>
        </member>
        <member name="P:Net.Share.IServerHandle`2.Scenes">
            <summary>
            服务器场景，每个key都处于一个场景或房间，关卡，value是场景对象
            </summary>
        </member>
        <member name="P:Net.Share.IServerHandle`2.IsRunServer">
            <summary>
            服务器是否处于运行状态, 如果服务器套接字已经被释放则返回False, 否则返回True. 当调用Close方法后将改变状态
            </summary>
        </member>
        <member name="T:Net.Share.IServerSendHandle`1">
            <summary>
            服务器发送处理接口
            </summary>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Send(`0,System.Byte[])">
            <summary>
            发送网络数据 UDP发送方式
            </summary>
            <param name="client">发送数据到的客户端</param>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Send(`0,System.Byte,System.Byte[])">
            <summary>
            发送自定义网络数据
            </summary>
            <param name="client">发送到客户端</param>
            <param name="cmd">网络命令</param>
            <param name="buffer">数据缓冲区</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Send(`0,System.String,System.Object[])">
            <summary>
            发送网络数据
            </summary>
            <param name="client">发送数据到的客户端</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Send(`0,System.Byte,System.String,System.Object[])">
            <summary>
            发送网络数据
            </summary>
            <param name="client">发送到的客户端</param>
            <param name="cmd">网络命令</param>
            <param name="func">RPCFun函数</param>
            <param name="pars">RPCFun参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Send(`0,System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            发送灵活数据包
            </summary>
            <param name="client">客户端集合</param>
            <param name="cmd"></param>
            <param name="buffer">要包装的数据,你自己来定</param>
            <param name="kernel">内核? 你包装的数据在客户端是否被内核NetConvert序列化?</param>
            <param name="serialize">序列化? 你包装的数据是否在服务器即将发送时NetConvert序列化?</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Send(`0,System.Byte,System.Object)">
            <summary>
            发送自定义协议类型, 使用protobuf序列化obj对象
            </summary>
            <param name="client"></param>
            <param name="cmd"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.SendRT(`0,System.String,System.Object[])">
            <summary>
            发送网络可靠传输数据
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.SendRT(`0,System.Byte,System.String,System.Object[])">
            <summary>
            发送可靠网络传输
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="cmd">网络命令</param>
            <param name="func">函数名</param>
            <param name="pars">参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.SendRT(`0,System.Byte[])">
            <summary>
            发送可靠网络传输
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.SendRT(`0,System.Byte,System.Byte[])">
            <summary>
            发送可靠网络传输
            调用此方法通常情况下是一定把数据发送成功为止, 
            </summary>
            <param name="client"></param>
            <param name="cmd">网络命令</param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.SendRT(`0,System.Byte,System.Object)">
            <summary>
            发送可靠网络传输
            发送自定义协议类型, 使用protobuf序列化obj对象
            </summary>
            <param name="client"></param>
            <param name="cmd"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.SendRT(`0,System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            发送灵活数据包
            </summary>
            <param name="client">客户端集合</param>
            <param name="cmd"></param>
            <param name="buffer">要包装的数据,你自己来定</param>
            <param name="kernel">内核? 你包装的数据在客户端是否被内核NetConvert序列化?</param>
            <param name="serialize">序列化? 你包装的数据是否在服务器即将发送时NetConvert序列化?</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Byte,System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="cmd"></param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable"></param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte,System.Byte[])">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">使用可靠传输?</param>
            <param name="cmd">网络命令</param>
            <param name="buffer">自定义字节数组</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte,System.Object)">
            <summary>
            网络多播, 发送自定义数据到clients集合的客户端
            发送自定义协议类型, 使用protobuf序列化obj对象
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">使用可靠传输?</param>
            <param name="cmd">网络命令</param>
            <param name="obj">使用protobuf序列化的对象</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">使用可靠传输?</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Byte,System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="cmd">网络命令</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte,System.String,System.Object[])">
            <summary>
            网络多播, 发送数据到clients集合的客户端
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">使用可靠传输?</param>
            <param name="cmd">网络命令</param>
            <param name="func">本地客户端rpc函数</param>
            <param name="pars">本地客户端rpc参数</param>
        </member>
        <member name="M:Net.Share.IServerSendHandle`1.Multicast(System.Collections.Generic.IList{`0},System.Boolean,System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            网络多播, 发送数据到clients集合的客户端 (灵活数据包)
            </summary>
            <param name="clients">客户端集合</param>
            <param name="reliable">这个包是可靠的吗?</param>
            <param name="cmd">网络指令</param>
            <param name="buffer">要包装的数据,你自己来定</param>
            <param name="kernel">内核? 你包装的数据在客户端是否被内核NetConvert反序列化?</param>
            <param name="serialize">序列化? 你包装的数据是否在服务器即将发送时NetConvert序列化?</param>
        </member>
        <member name="T:Net.Share.Parameter">
            <summary>
            web服务器json参数类
            </summary>
        </member>
        <member name="F:Net.Share.Parameter.typeName">
            <summary>
            记录参数类型
            </summary>
        </member>
        <member name="F:Net.Share.Parameter.jsonStr">
            <summary>
            参数json解析字符串
            </summary>
        </member>
        <member name="M:Net.Share.Parameter.#ctor">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:Net.Share.Parameter.#ctor(System.String,System.String)">
            <summary>
            构造
            </summary>
            <param name="typeName"></param>
            <param name="jsonStr"></param>
        </member>
        <member name="T:Net.Share.MessageModelBase">
            <summary>
            webSocket服务器json数据模型基础类
            </summary>
        </member>
        <member name="F:Net.Share.MessageModelBase.cmd">
            <summary>
            操作指令
            </summary>
        </member>
        <member name="F:Net.Share.MessageModelBase.func">
            <summary>
            操作的远程函数
            </summary>
        </member>
        <member name="F:Net.Share.MessageModelBase.pars">
            <summary>
            操作的远程参数
            </summary>
        </member>
        <member name="M:Net.Share.MessageModelBase.GetPars">
            <summary>
            解析客户端的json数据, 获取参数 
            </summary>
            <returns></returns>
        </member>
        <member name="T:Net.Share.MessageModel">
            <summary>
            webSocket服务器json数据模型类
            </summary>
        </member>
        <member name="M:Net.Share.MessageModel.#ctor">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:Net.Share.MessageModel.#ctor(System.Byte,System.String,System.Object[])">
            <summary>
            构造
            </summary>
            <param name="cmd"></param>
            <param name="func"></param>
            <param name="pars"></param>
        </member>
        <member name="T:Net.Share.NetCmd">
            <summary>
            网络命令基类 - 可继承此类定义自己的网络命令 19.7.16
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.EntityRpc">
            <summary>
            面向实体类型调用远程函数
            使用此命令即可在NetPlayer的派生类中定义rpc函数进行调用
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.CallRpc">
            <summary>
            如果是客户端调用则在服务器执行 如果是服务器调用则在客户端执行.
            在服务器端,如果出现多线程抢夺资源调用Client错误时，可使用SafeCall命令来执行
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.SafeCall">
            <summary>
            安全调用服务器函数,当多线程并行时会有1%的几率发生线程抢夺资源，
            如果在RPC函数内部调用client的时候是其他客户端的client对象。出现这种情况时建议使用此命令，
            否则可以使用CallRpc命令，
            使用此命令时,函数第一个参数将会嵌入NetPlayer参数
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.Local">
            <summary>
            (自身转发)服务器只转发给发送方客户端
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.Scene">
            <summary>
            (场景转发)服务器负责转发给在同一房间或场景内的玩家
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.SceneRT">
            <summary>
            (场景转发,可靠指令)服务器负责转发给在同一房间或场景内的玩家
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.Notice">
            <summary>
            (公告指令)服务器负责转发给所有在线的玩家
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.NoticeRT">
            <summary>
            (公告指令,可靠传输)服务器负责转发给所有在线的玩家
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.SendHeartbeat">
            <summary>
            发送心跳包命令, 内部命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.RevdHeartbeat">
            <summary>
            回调心跳包命令, 内部命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.ThreadRpc">
            <summary>
            多线程远程过程调用函数 (RPC)
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.QuitGame">
            <summary>
            请求服务器移除此客户端
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.OtherCmd">
            <summary>
            其他命令或用户自定义命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.ExceededNumber">
            <summary>
            服务器连接人数溢出, 新的客户端将不允许连接服务器, 可设置服务器的LineUp值调整
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.BlockConnection">
            <summary>
            服务器爆满, 阻止客户端连接命令, 仅限服务器回调给客户端使用的命令, 客户端可监听OnBlockConnection事件处理， 内部命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.ReliableTransport">
            <summary>
            可靠传输接收指令. 内部命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.ReliableCallback">
            <summary>
            可靠传输数据确认回调, 内部命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.SwitchPort">
            <summary>
            当客户端连接主服务器(网关服)时, 主服务器检测分区服务器在线人数如果处于爆满状态, 
            服务器发送切换端口让客户端连接新的服务器IP和端口. 内部命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.Identify">
            <summary>
            标记客户端唯一标识, 内部命令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.OperationSync">
            <summary>
            操作同步，服务器使用NetScene.AddOperation方法，客户端UdpClient.AddOperation方法。 内部指令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.Broadcast">
            <summary>
            局域网寻找主机命令, 内部使用
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.Connect">
            <summary>
            连接指令 (内部)
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.ReliableCallbackClear">
            <summary>
            可靠传输被清洗, 原因是接收缓存流设置过小 内部指令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.LocalRT">
            <summary>
            自身转发, 可靠传输
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.Ping">
            <summary>
            ping测试网络延迟量
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.PingCallback">
            <summary>
            ping回调 内部指令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.TakeFrame">
            <summary>
            可靠传输取单帧 内部指令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.TakeFrameList">
            <summary>
            可靠传输取帧列表 内部指令
            </summary>
        </member>
        <member name="F:Net.Share.NetCmd.VarSync">
            <summary>
            字段或属性同步指令 内部指令
            </summary>
        </member>
        <member name="T:Net.Share.RPCMethod">
            <summary>
            远程过程调用方法
            </summary>
        </member>
        <member name="F:Net.Share.RPCMethod.Name">
            <summary>
            委托函数名
            </summary>
        </member>
        <member name="F:Net.Share.RPCMethod.target">
            <summary>
            委托对象
            </summary>
        </member>
        <member name="F:Net.Share.RPCMethod.method">
            <summary>
            委托方法
            </summary>
        </member>
        <member name="F:Net.Share.RPCMethod.cmd">
            <summary>
            网络命令
            </summary>
        </member>
        <member name="M:Net.Share.RPCMethod.#ctor(System.Action)">
            <summary>
            远程过程调用方法
            </summary>
        </member>
        <member name="M:Net.Share.RPCMethod.AddMethodEvent(System.Delegate)">
            <summary>
            网络委托
            </summary>
        </member>
        <member name="M:Net.Share.RPCMethod.#ctor(System.Object,System.Reflection.MethodInfo)">
            <summary>
            远程过程调用方法
            </summary>
        </member>
        <member name="M:Net.Share.RPCMethod.#ctor(System.Object,System.Reflection.MethodInfo,System.Byte)">
            <summary>
            远程过程调用方法
            </summary>
        </member>
        <member name="T:Net.Share.NetState">
            <summary>
            网络状态
            </summary>
        </member>
        <member name="F:Net.Share.NetState.Idle">
            <summary>
            待机状态
            </summary>
        </member>
        <member name="F:Net.Share.NetState.WaitTeam">
            <summary>
            等待其他玩家加入状态
            </summary>
        </member>
        <member name="F:Net.Share.NetState.Team">
            <summary>
            组队状态
            </summary>
        </member>
        <member name="F:Net.Share.NetState.InCombat">
            <summary>
            作战中，或在游戏中
            </summary>
        </member>
        <member name="F:Net.Share.NetState.Disconnected">
            <summary>
            玩家掉线
            </summary>
        </member>
        <member name="F:Net.Share.NetState.AwayStatus">
            <summary>
            离开状态
            </summary>
        </member>
        <member name="F:Net.Share.NetState.InGameHall">
            <summary>
            在游戏厅内，或在场景内
            </summary>
        </member>
        <member name="F:Net.Share.NetState.OutGameHall">
            <summary>
            在游戏厅外，或在场景外
            </summary>
        </member>
        <member name="T:Net.Share.NetSystem">
            <summary>
            网络系统设置类型
            </summary>
        </member>
        <member name="F:Net.Share.NetSystem.CreateScene">
            <summary>
            允许玩家创建场景
            </summary>
        </member>
        <member name="T:Net.Share.NetworkDataTraffic">
            <summary>
            网络流量数据统计
            </summary>
            <param name="sendNumber">一秒发送数据次数</param>
            <param name="sendCount">一秒发送字节长度</param>
            <param name="receiveNumber">一秒接收数据次数</param>
            <param name="receiveCount">一秒接收到的字节大小</param>
            <param name="resolveNumber">解析RPC函数次数</param>
            <param name="sendLoopNum">发送线程循环次数 并发数,类似fps</param>
            <param name="revdLoopNum">接收线程循环次数</param>
        </member>
        <member name="T:Net.Share.RevdBufferHandle`1">
            <summary>
            当处理缓冲区数据
            </summary>
            <param name="client">处理此客户端的数据请求</param>
            <param name="model"></param>
        </member>
        <member name="T:Net.Share.WSRevdBufferHandle`1">
            <summary>
            webSocket当处理缓冲区数据
            </summary>
            <param name="client">处理此客户端的数据请求</param>
            <param name="model"></param>
        </member>
        <member name="T:Net.Share.Operation">
            <summary>
            帧同步操作
            </summary>
        </member>
        <member name="F:Net.Share.Operation.cmd">
            <summary>
            操作指令
            </summary>
        </member>
        <member name="F:Net.Share.Operation.cmd1">
            <summary>
            其他指令
            </summary>
        </member>
        <member name="F:Net.Share.Operation.cmd2">
            <summary>
            其他指令
            </summary>
        </member>
        <member name="F:Net.Share.Operation.name">
            <summary>
            玩家名称
            </summary>
        </member>
        <member name="F:Net.Share.Operation.position">
            <summary>
            玩家位置信息
            </summary>
        </member>
        <member name="F:Net.Share.Operation.rotation">
            <summary>
            玩家旋转信息
            </summary>
        </member>
        <member name="F:Net.Share.Operation.direction">
            <summary>
            玩家输入方向
            </summary>
        </member>
        <member name="F:Net.Share.Operation.index">
            <summary>
            索引
            </summary>
        </member>
        <member name="F:Net.Share.Operation.index1">
            <summary>
            其他索引
            </summary>
        </member>
        <member name="F:Net.Share.Operation.index2">
            <summary>
            其他索引
            </summary>
        </member>
        <member name="F:Net.Share.Operation.buffer">
            <summary>
            数据数组, 备用
            </summary>
        </member>
        <member name="F:Net.Share.Operation.name1">
            <summary>
            备用字符串
            </summary>
        </member>
        <member name="F:Net.Share.Operation.name2">
            <summary>
            备用字符串
            </summary>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte)">
            <summary>
            玩家操作指令
            </summary>
            <param name="cmd"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.Byte[])">
            <summary>
            玩家操作指令
            </summary>
            <param name="cmd"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.String)">
            <summary>
            玩家操作指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.String,System.String)">
            <summary>
            玩家操作指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
            <param name="name1"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.String,Net.Vector3)">
            <summary>
            玩家输入方向指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.Int32,Net.Vector3)">
            <summary>
            玩家输入方向指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.String,System.Int32)">
            <summary>
            玩家其他操作指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
            <param name="index"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.String,Net.Vector3,Net.Quaternion)">
            <summary>
            玩家位置同步操作指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
            <param name="position"></param>
            <param name="rotation"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.Int32,Net.Vector3,Net.Quaternion)">
            <summary>
            玩家位置同步操作指令
            </summary>
            <param name="cmd"></param>
            <param name="identity"></param>
            <param name="position"></param>
            <param name="rotation"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.String,Net.Vector3,Net.Vector3,Net.Quaternion)">
            <summary>
            玩家位置同步操作指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
            <param name="direction"></param>
            <param name="position"></param>
            <param name="rotation"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.Int32,Net.Vector3,Net.Vector3,Net.Quaternion)">
            <summary>
            玩家位置同步操作指令
            </summary>
            <param name="cmd"></param>
            <param name="identity"></param>
            <param name="direction"></param>
            <param name="position"></param>
            <param name="rotation"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.String,Net.Vector3,Net.Quaternion,Net.Vector3)">
            <summary>
            玩家位置同步操作指令
            </summary>
            <param name="cmd"></param>
            <param name="name"></param>
            <param name="direction_is_localScale"></param>
            <param name="position"></param>
            <param name="rotation"></param>
        </member>
        <member name="M:Net.Share.Operation.#ctor(System.Byte,System.Int32,Net.Vector3,Net.Quaternion,Net.Vector3)">
            <summary>
            玩家位置同步操作指令
            </summary>
            <param name="cmd"></param>
            <param name="identity"></param>
            <param name="direction_is_localScale"></param>
            <param name="position"></param>
            <param name="rotation"></param>
        </member>
        <member name="M:Net.Share.Operation.ToString">
            <summary>
            重写字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:Net.Share.OperationList">
            <summary>
            帧同步列表
            </summary>
        </member>
        <member name="F:Net.Share.OperationList.frame">
            <summary>
            帧索引
            </summary>
        </member>
        <member name="F:Net.Share.OperationList.operations">
            <summary>
            帧操作列表
            </summary>
        </member>
        <member name="M:Net.Share.OperationList.#ctor(System.UInt32)">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:Net.Share.OperationList.#ctor(Net.Share.Operation[])">
            <summary>
            构造
            </summary>
            <param name="opts"></param>
        </member>
        <member name="M:Net.Share.OperationList.#ctor(System.UInt32,Net.Share.Operation[])">
            <summary>
            构造
            </summary>
            <param name="frame"></param>
            <param name="opts"></param>
        </member>
        <member name="T:Net.Share.RandomHelper">
            <summary>
            随机帮助类 (多线程安全)
            </summary>
        </member>
        <member name="M:Net.Share.RandomHelper.InitSeed(System.Int32)">
            <summary>
            初始化随机种子
            </summary>
            <param name="Seed"></param>
        </member>
        <member name="M:Net.Share.RandomHelper.Range(System.Int32,System.Int32)">
            <summary>
            随机范围
            </summary>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.RandomHelper.Range(System.Single,System.Single)">
            <summary>
            随机范围
            </summary>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.RandomHelper.Range1(System.Int32,System.Int32)">
            <summary>
            随机范围
            </summary>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.RandomHelper.Range1(System.Single,System.Single)">
            <summary>
            随机范围
            </summary>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.ReceiveBuffer">
            <summary>
            服务器接收数据缓存
            </summary>
        </member>
        <member name="F:Net.Share.ReceiveBuffer.buffer">
            <summary>
            数据缓冲区
            </summary>
        </member>
        <member name="F:Net.Share.ReceiveBuffer.count">
            <summary>
            数据长度
            </summary>
        </member>
        <member name="F:Net.Share.ReceiveBuffer.remotePoint">
            <summary>
            UDP终端
            </summary>
        </member>
        <member name="F:Net.Share.ReceiveBuffer.client">
            <summary>
            TCP客户端
            </summary>
        </member>
        <member name="M:Net.Share.ReceiveBuffer.#ctor(System.Byte[],System.Int32)">
            <summary>
            构造接收数据缓存器
            </summary>
            <param name="buffer"></param>
            <param name="count"></param>
        </member>
        <member name="M:Net.Share.ReceiveBuffer.#ctor(System.Byte[],System.Int32,System.Net.EndPoint)">
            <summary>
            构造接收数据缓存器
            </summary>
            <param name="buffer"></param>
            <param name="count"></param>
            <param name="remotePoint"></param>
        </member>
        <member name="M:Net.Share.ReceiveBuffer.#ctor(System.Byte[],System.Int32,Net.Server.NetPlayer)">
            <summary>
            构造接收数据缓存器
            </summary>
            <param name="buffer"></param>
            <param name="count"></param>
            <param name="client"></param>
        </member>
        <member name="T:Net.Share.RevdBuffer">
            <summary>
            网络接收缓存结构体
            </summary>
        </member>
        <member name="F:Net.Share.RevdBuffer.name">
            <summary>
            函数和参数的名称
            </summary>
        </member>
        <member name="F:Net.Share.RevdBuffer.target">
            <summary>
            存储封包反序列化出来的对象
            </summary>
        </member>
        <member name="F:Net.Share.RevdBuffer.method">
            <summary>
            存储反序列化的函数
            </summary>
        </member>
        <member name="F:Net.Share.RevdBuffer.pars">
            <summary>
            存储反序列化参数
            </summary>
        </member>
        <member name="M:Net.Share.RevdBuffer.#ctor(System.Object,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            构造函数
            </summary>
            <param name="target">远程调用对象</param>
            <param name="method">远程调用方法</param>
            <param name="pars">远程调用参数</param>
        </member>
        <member name="M:Net.Share.RevdBuffer.Invoke">
            <summary>
            调用方法
            </summary>
            <returns></returns>
        </member>
        <member name="T:Net.Share.RevdDataBuffer">
            <summary>
            一级数据接收缓存区
            </summary>
        </member>
        <member name="F:Net.Share.RevdDataBuffer.client">
            <summary>
            远程端口
            </summary>
        </member>
        <member name="F:Net.Share.RevdDataBuffer.buffer">
            <summary>
            缓存区
            </summary>
        </member>
        <member name="F:Net.Share.RevdDataBuffer.index">
            <summary>
            数据索引
            </summary>
        </member>
        <member name="F:Net.Share.RevdDataBuffer.count">
            <summary>
            数据长度
            </summary>
        </member>
        <member name="F:Net.Share.RevdDataBuffer.tcp_udp">
            <summary>
            数据协议
            </summary>
        </member>
        <member name="T:Net.Share.SendDataBuffer">
            <summary>
            一级数据发送缓存区
            </summary>
        </member>
        <member name="F:Net.Share.SendDataBuffer.client">
            <summary>
            客户端对象
            </summary>
        </member>
        <member name="F:Net.Share.SendDataBuffer.buffer">
            <summary>
            缓存区
            </summary>
        </member>
        <member name="T:Net.Share.RTState">
            <summary>
            可靠传输状态
            </summary>
        </member>
        <member name="F:Net.Share.RTState.Sending">
            <summary>
            发送中
            </summary>
        </member>
        <member name="F:Net.Share.RTState.Download">
            <summary>
            下载中
            </summary>
        </member>
        <member name="F:Net.Share.RTState.FailSend">
            <summary>
            发送失败
            </summary>
        </member>
        <member name="F:Net.Share.RTState.Complete">
            <summary>
            发送完成
            </summary>
        </member>
        <member name="F:Net.Share.RTState.Retransmission">
            <summary>
            尝试重传
            </summary>
        </member>
        <member name="T:Net.Share.SendRTProgress">
            <summary>
            可靠文件发送进度委托
            </summary>
            <param name="progress">当前进度</param>
            <param name="state">当前状态</param>
        </member>
        <member name="T:Net.Share.RTProgress">
            <summary>
            可靠传输进度值
            </summary>
        </member>
        <member name="F:Net.Share.RTProgress.progress">
            <summary>
            进度值
            </summary>
        </member>
        <member name="F:Net.Share.RTProgress.state">
            <summary>
            当前状态
            </summary>
        </member>
        <member name="M:Net.Share.RTProgress.#ctor(System.Single,Net.Share.RTState)">
            <summary>
            构造
            </summary>
            <param name="progress"></param>
            <param name="state"></param>
        </member>
        <member name="T:Net.Share.RPCFun">
            <summary>
            标注为远程过程调用函数
            </summary>
        </member>
        <member name="F:Net.Share.RPCFun.cmd">
            <summary>
            网络命令
            </summary>
        </member>
        <member name="F:Net.Share.RPCFun.mask">
            <summary>
            远程方法的掩饰
            </summary>
        </member>
        <member name="F:Net.Share.RPCFun.il2cpp">
            <summary>
            <code>如果在unity编译为il2cpp后端脚本并使用CallSiteRpcAdapter快速调用rpc适配器，则需要先声明类型出来，因为编译后，类型将无法在创建出来</code>
            例子: void Test(int num, string str); 则需要使用 [Rpc(il2cpp = typeof(RPCPTR&lt;int, string&gt;))]
            </summary>
        </member>
        <member name="M:Net.Share.RPCFun.#ctor">
            <summary>
            构造RPCFun函数特性
            </summary>
        </member>
        <member name="M:Net.Share.RPCFun.#ctor(System.Byte)">
            <summary>
            构造RPCFun函数特性
            </summary>
            <param name="cmd">自定义的网络命令</param>
        </member>
        <member name="T:Net.Share.Rpc">
            <summary>
            标注为远程过程调用函数 (简型)
            </summary>
        </member>
        <member name="M:Net.Share.Rpc.#ctor">
            <summary>
            构造Rpc函数特性
            </summary>
        </member>
        <member name="M:Net.Share.Rpc.#ctor(System.Byte)">
            <summary>
            构造Rpc函数特性
            </summary>
            <param name="cmd">自定义的网络命令</param>
        </member>
        <member name="T:Net.Share.rpc">
            <summary>
            标注为远程过程调用函数 (偷懒型) 安卓上有出现找不到问题, 出现此问题请使用 Rpc(第一个大写) 标签 
            </summary>
        </member>
        <member name="M:Net.Share.rpc.#ctor">
            <summary>
            构造rpc函数特性
            </summary>
        </member>
        <member name="M:Net.Share.rpc.#ctor(System.Byte)">
            <summary>
            构造rpc函数特性
            </summary>
            <param name="cmd">自定义的网络命令</param>
        </member>
        <member name="T:Net.Share.RPCModel">
            <summary>
            远程过程调用模型,此类负责网络通讯中数据解析临时存储的对象
            </summary>
        </member>
        <member name="F:Net.Share.RPCModel.kernel">
            <summary>
            内核? true:数据经过框架内部序列化 false:数据由开发者自己处理
            </summary>
        </member>
        <member name="F:Net.Share.RPCModel.cmd">
            <summary>
            网络指令
            </summary>
        </member>
        <member name="F:Net.Share.RPCModel.buffer">
            <summary>
            这是内存池数据，这个字段要配合index，count两字段使用，如果想得到实际数据，请使用Buffer属性
            </summary>
        </member>
        <member name="P:Net.Share.RPCModel.Buffer">
            <summary>
            数据缓冲器(正确的数据段)
            </summary>
        </member>
        <member name="F:Net.Share.RPCModel.func">
            <summary>
            远程函数名
            </summary>
        </member>
        <member name="F:Net.Share.RPCModel.methodMask">
            <summary>
            远程方法遮罩值
            </summary>
        </member>
        <member name="F:Net.Share.RPCModel.pars">
            <summary>
            远程参数
            </summary>
        </member>
        <member name="F:Net.Share.RPCModel.serialize">
            <summary>
            数据是否经过内部序列化?
            </summary>
        </member>
        <member name="M:Net.Share.RPCModel.#ctor(System.Byte,System.Byte[])">
            <summary>
            构造
            </summary>
            <param name="cmd"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Share.RPCModel.#ctor(System.Byte,System.String,System.Object[])">
            <summary>
            构造Send
            </summary>
            <param name="cmd"></param>
            <param name="func"></param>
            <param name="pars"></param>
        </member>
        <member name="M:Net.Share.RPCModel.#ctor(System.Byte,System.Byte[],System.Boolean)">
            <summary>
            构造Send
            </summary>
            <param name="cmd"></param>
            <param name="buffer"></param>
            <param name="kernel"></param>
        </member>
        <member name="M:Net.Share.RPCModel.#ctor(System.Byte,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            构造SendRT可靠传输
            </summary>
            <param name="cmd"></param>
            <param name="buffer"></param>
            <param name="kernel"></param>
            <param name="serialize"></param>
        </member>
        <member name="M:Net.Share.RPCModel.#ctor(System.Byte,System.String,System.Object[],System.Boolean,System.Boolean)">
            <summary>
            构造SendRT可靠传输
            </summary>
            <param name="cmd"></param>
            <param name="func"></param>
            <param name="pars"></param>
            <param name="kernel"></param>
            <param name="serialize"></param>
        </member>
        <member name="M:Net.Share.RPCModel.ToString">
            <summary>
            讲类转换字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:Net.Share.RTOMode">
            <summary>
            超时重传模式
            </summary>
        </member>
        <member name="F:Net.Share.RTOMode.Variable">
            <summary>
            可变的重传时间, 以ping指令来自动设置重传时间, 每秒ping一次, 并设置rto时间, 你还可以监听服务器,客户端的OnPingCallback事件来查看网络延迟
            </summary>
        </member>
        <member name="F:Net.Share.RTOMode.Fixed">
            <summary>
            固定重传时间, 以ServerBase的RTO时间重传
            </summary>
        </member>
        <member name="T:Net.Share.SendBuffer">
            <summary>
            发送数据缓冲区
            </summary>
        </member>
        <member name="F:Net.Share.SendBuffer.cmd">
            <summary>
            网络命令0-5已经被插件系统占用，可用6-255为自定义命令
            </summary>
        </member>
        <member name="F:Net.Share.SendBuffer.func">
            <summary>
            RPC函数名称
            </summary>
        </member>
        <member name="F:Net.Share.SendBuffer.pars">
            <summary>
            RPC参数
            </summary>
        </member>
        <member name="F:Net.Share.SendBuffer.buffer">
            <summary>
            字节数组缓冲区
            </summary>
        </member>
        <member name="F:Net.Share.SendBuffer.kernel">
            <summary>
            使用插件内核数据 还是 自定义数据
            </summary>
        </member>
        <member name="M:Net.Share.SendBuffer.#ctor(System.Byte,System.String,System.Object[])">
            <summary>
            构造发送缓冲区 使用插件内核发送数据
            </summary>
            <param name="cmd">网络命令</param>
            <param name="fun">网络RPC函数名称</param>
            <param name="pars">网络RPC参数</param>
        </member>
        <member name="M:Net.Share.SendBuffer.#ctor(System.Byte,System.Byte[])">
            <summary>
            构造发送缓冲区 使用自定义数据发送
            </summary>
            <param name="cmd">网络命令</param>
            <param name="buffer">缓冲区</param>
        </member>
        <member name="T:Net.Share.TransportMode">
            <summary>
            传输模式设置
            </summary>
        </member>
        <member name="F:Net.Share.TransportMode.Normal">
            <summary>
            正常模式, 保证可靠数据接近正常得到应答, 降低多次重传的情况
            </summary>
        </member>
        <member name="F:Net.Share.TransportMode.Quick">
            <summary>
            快速模式, 速度飞起来, 用流量来换取快速应答
            </summary>
        </member>
        <member name="F:Net.Share.TransportMode.DoubleSpeed">
            <summary>
            双倍加速模式, 重传和应答会以2倍速以上响应
            </summary>
        </member>
        <member name="F:Net.Share.TransportMode.VeryFast">
            <summary>
            极快模式, 双倍速度重传与应答
            </summary>
        </member>
        <member name="F:Net.Share.TransportMode.Speeding">
            <summary>
            超速模式, 无法形容的极限速度模式, 流量翻100倍
            </summary>
        </member>
        <member name="T:Net.Share.UnZipHelper">
            <summary>
            压缩数据传输
            </summary>
        </member>
        <member name="M:Net.Share.UnZipHelper.Compress(System.Byte[])">
            <summary>
            返回压缩后的字节数组
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.UnZipHelper.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            返回解压后的字节数组
            </summary>
            <param name="data">原始字节数组</param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.VarSync">
            <summary>
            变量或属性同步特性
            服务器的同步特性只能用<see cref="M:Net.Server.NetPlayer.AddRpcHandle(System.Object)"/>方法来收集
            </summary>
        </member>
        <member name="F:Net.Share.VarSync.id">
            <summary>
            变量或属性的唯一标识
            </summary>
        </member>
        <member name="F:Net.Share.VarSync.passive">
            <summary>
            你的字段,属性不能主动同步, 只能被对方同步
            </summary>
        </member>
        <member name="M:Net.Share.VarSync.#ctor">
            <summary>
            构造字段,属性同步特性
            服务器的同步特性只能用<see cref="M:Net.Server.NetPlayer.AddRpcHandle(System.Object)"/>方法来收集
            </summary>
        </member>
        <member name="M:Net.Share.VarSync.#ctor(System.UInt16)">
            <summary>
            构造字段,属性同步特性
            服务器的同步特性只能用<see cref="M:Net.Server.NetPlayer.AddRpcHandle(System.Object)"/>方法来收集
            </summary>
            <param name="id">唯一id, 不能重复</param>
        </member>
        <member name="T:Net.Share.Win32KernelAPI">
            <summary>
            系统时钟间隔是个很少被关心到的系统标量，
            它反映了系统产生时钟中断的频率，间隔越小频率越高，反之亦然。
            每当时钟中断产生，系统相关的中断函数将会处理这个中断。
            时钟中断处理函数会更新系统时间，检查内核调试信息等。
            </summary>
        </member>
        <member name="M:Net.Share.Win32KernelAPI.timeBeginPeriod(System.UInt32)">
            <summary>
            设置应用程序或驱动程序使用的最小定时器分辨率  
            </summary>
            <param name="uMilliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.Win32KernelAPI.timeEndPeriod(System.UInt32)">
            <summary>
            清除应用程序或驱动程序使用的最小定时器分辨率  
            </summary>
            <param name="uMilliseconds"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.Segment">
            <summary>
            内存数据片段
            </summary>
        </member>
        <member name="P:Net.Share.Segment.Buffer">
            <summary>
            总内存
            </summary>
        </member>
        <member name="P:Net.Share.Segment.Index">
            <summary>
            片的开始位置
            </summary>
        </member>
        <member name="P:Net.Share.Segment.Count">
            <summary>
            片的长度
            </summary>
        </member>
        <member name="P:Net.Share.Segment.Position">
            <summary>
            读写位置
            </summary>
        </member>
        <member name="P:Net.Share.Segment.Length">
            <summary>
            获取总长度
            </summary>
        </member>
        <member name="P:Net.Share.Segment.Item(System.Int32)">
            <summary>
            获取或设置总内存位置索引
            </summary>
            <param name="index">内存位置索引</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.Segment.#ctor(System.Byte[])">
            <summary>
            构造内存分片
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Net.Share.Segment.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            构造内存分片
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:Net.Share.Segment.ToArray(System.Boolean)">
            <summary>
            复制分片数据
            </summary>
            <param name="recovery">复制数据后立即回收此分片?</param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.BufferPool">
            <summary>
            数据缓冲内存池
            </summary>
        </member>
        <member name="P:Net.Share.BufferPool.Size">
            <summary>
            数据缓冲池大小. 默认65536字节
            </summary>
        </member>
        <member name="P:Net.Share.BufferPool.Log">
            <summary>
            当没有合理回收内存，导致内存泄漏被回收后提示
            </summary>
        </member>
        <member name="M:Net.Share.BufferPool.Take">
            <summary>
            从内存池取数据片
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Share.BufferPool.Take(System.Int32)">
            <summary>
            从内存池取数据片
            </summary>
            <param name="size">内存大小</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.BufferPool.Push(Net.Share.Segment)">
            <summary>
            压入数据片, 等待复用
            </summary>
            <param name="segment"></param>
        </member>
        <member name="T:Net.Share.ListPool`1">
            <summary>
            线程安全的List类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Net.Share.ListPool`1.GetRemoveRange(System.Int32,System.Int32)">
            <summary>
            获取列表对象, 并移除列表, 如果在多线程下, 多线程并行下, 是可以获取到对象, 但是会出现长度不是所指定的长度, 所以获取后要判断一下长度
            </summary>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.QueueSafeDebugView`1">
            <summary>
            A debugger view of the IProducerConsumerCollection that makes it simple to browse the
            collection's contents at a point in time.
            </summary>
            <typeparam name="T">The type of elements stored within.</typeparam>
        </member>
        <member name="M:Net.Share.QueueSafeDebugView`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Constructs a new debugger view object for the provided collection object.
            </summary>
            <param name="collection">A collection to browse in the debugger.</param>
        </member>
        <member name="P:Net.Share.QueueSafeDebugView`1.Items">
            <summary>
            Returns a snapshot of the underlying collection's elements.
            </summary>
        </member>
        <member name="T:Net.Share.QueueSafe`1">
            <summary>
            多线程安全队列
            </summary>
            <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
            <remarks>
            All public  and protected members of <see cref="T:Net.Share.QueueSafe`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:Net.Share.QueueSafe`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Net.Share.QueueSafe`1"/> class.
            </summary>
        </member>
        <member name="M:Net.Share.QueueSafe`1.InitializeFromCollection(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes the contents of the queue from an existing collection.
            </summary>
            <param name="collection">A collection from which to copy elements.</param>
        </member>
        <member name="M:Net.Share.QueueSafe`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Net.Share.QueueSafe`1"/>
            class that contains elements copied from the specified collection
            </summary>
            <param name="collection">The collection whose elements are copied to the new <see
            cref="T:Net.Share.QueueSafe`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
        </member>
        <member name="M:Net.Share.QueueSafe`1.OnSerializing(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Get the data array to be serialized
            </summary>
        </member>
        <member name="M:Net.Share.QueueSafe`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Construct the queue from a previously seiralized one
            </summary>
        </member>
        <member name="M:Net.Share.QueueSafe`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
            cref="T:System.Array"/>, starting at a particular
            <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag"/>. The <see
            cref="T:System.Array">Array</see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see
            cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="P:Net.Share.QueueSafe`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:Net.Share.QueueSafe`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:Net.Share.QueueSafe`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="M:Net.Share.QueueSafe`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Net.Share.QueueSafe`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>. The value can be a null
            reference (Nothing in Visual Basic) for reference types.
            </param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:Net.Share.QueueSafe`1"/>, this operation will always add the object to the
            end of the <see cref="T:Net.Share.QueueSafe`1"/>
            and return true.</remarks>
        </member>
        <member name="M:Net.Share.QueueSafe`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
            </summary>
            <param name="item">
            When this method returns, if the operation was successful, <paramref name="item"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned succesfully; otherwise, false.</returns>
            <remarks>For <see cref="T:Net.Share.QueueSafe`1"/>, this operation will attempt to remove the object
            from the beginning of the <see cref="T:Net.Share.QueueSafe`1"/>.
            </remarks>
        </member>
        <member name="P:Net.Share.QueueSafe`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:Net.Share.QueueSafe`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:Net.Share.QueueSafe`1"/> is empty; otherwise, false.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:Net.Share.QueueSafe`1.Count"/> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:Net.Share.QueueSafe`1.IsEmpty"/> returns, thus invalidating
            the result.
            </remarks>
        </member>
        <member name="M:Net.Share.QueueSafe`1.ToArray">
            <summary>
            Copies the elements stored in the <see cref="T:Net.Share.QueueSafe`1"/> to a new array.
            </summary>
            <returns>A new array containing a snapshot of elements copied from the <see
            cref="T:Net.Share.QueueSafe`1"/>.</returns>
        </member>
        <member name="M:Net.Share.QueueSafe`1.ToList">
            <summary>
            Copies the <see cref="T:Net.Share.QueueSafe`1"/> elements to a new <see
            cref="T:System.Collections.Generic.List{T}"/>.
            </summary>
            <returns>A new <see cref="T:System.Collections.Generic.List{T}"/> containing a snapshot of
            elements copied from the <see cref="T:Net.Share.QueueSafe`1"/>.</returns>
        </member>
        <member name="M:Net.Share.QueueSafe`1.GetHeadTailPositions(Net.Share.QueueSafe{`0}.Segment@,Net.Share.QueueSafe{`0}.Segment@,System.Int32@,System.Int32@)">
            <summary>
            Store the position of the current head and tail positions.
            </summary>
            <param name="head">return the head segment</param>
            <param name="tail">return the tail segment</param>
            <param name="headLow">return the head offset, value range [0, SEGMENT_SIZE]</param>
            <param name="tailHigh">return the tail offset, value range [-1, SEGMENT_SIZE-1]</param>
        </member>
        <member name="P:Net.Share.QueueSafe`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:Net.Share.QueueSafe`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:Net.Share.QueueSafe`1"/>.</value>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:Net.Share.QueueSafe`1.IsEmpty"/>
            property is recommended rather than retrieving the number of items from the <see cref="P:Net.Share.QueueSafe`1.Count"/>
            property and comparing it to 0.
            </remarks>
        </member>
        <member name="M:Net.Share.QueueSafe`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:Net.Share.QueueSafe`1"/> elements to an existing one-dimensional <see
            cref="T:System.Array">Array</see>, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:Net.Share.QueueSafe`1"/>. The <see cref="T:System.Array">Array</see> must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:Net.Share.QueueSafe`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref
            name="array"/>.
            </exception>
        </member>
        <member name="M:Net.Share.QueueSafe`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see
            cref="T:Net.Share.QueueSafe`1"/>.
            </summary>
            <returns>An enumerator for the contents of the <see
            cref="T:Net.Share.QueueSafe`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the queue.  It does not reflect any updates to the collection after 
            <see cref="M:Net.Share.QueueSafe`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the queue.
            </remarks>
        </member>
        <member name="M:Net.Share.QueueSafe`1.GetEnumerator(Net.Share.QueueSafe{`0}.Segment,Net.Share.QueueSafe{`0}.Segment,System.Int32,System.Int32)">
            <summary>
            Helper method of GetEnumerator to seperate out yield return statement, and prevent lazy evaluation. 
            </summary>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Enqueue(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:Net.Share.QueueSafe`1"/>.
            </summary>
            <param name="item">The object to add to the end of the <see
            cref="T:Net.Share.QueueSafe`1"/>. The value can be a null reference
            (Nothing in Visual Basic) for reference types.
            </param>
        </member>
        <member name="M:Net.Share.QueueSafe`1.TryDequeue(`0@)">
            <summary>
            Attempts to remove and return the object at the beginning of the <see
            cref="T:Net.Share.QueueSafe`1"/>.
            </summary>
            <param name="result">
            When this method returns, if the operation was successful, <paramref name="result"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned from the beggining of the <see
            cref="T:Net.Share.QueueSafe`1"/>
            succesfully; otherwise, false.</returns>
        </member>
        <member name="M:Net.Share.QueueSafe`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the beginning of the <see cref="T:Net.Share.QueueSafe`1"/>
            without removing it.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains an object from
            the beginning of the <see cref="T:System.Collections.Concurrent.ConccurrentQueue{T}"/> or an
            unspecified value if the operation failed.</param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="T:Net.Share.QueueSafe`1.Segment">
            <summary>
            private class for ConcurrentQueue. 
            a queue is a linked list of small arrays, each node is called a segment.
            A segment contains an array, a pointer to the next segment, and m_low, m_high indices recording
            the first and last valid elements of the array.
            </summary>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.#ctor(System.Int64,Net.Share.QueueSafe{`0})">
            <summary>
            Create and initialize a segment with the specified index.
            </summary>
        </member>
        <member name="P:Net.Share.QueueSafe`1.Segment.Next">
            <summary>
            return the next segment
            </summary>
        </member>
        <member name="P:Net.Share.QueueSafe`1.Segment.IsEmpty">
            <summary>
            return true if the current segment is empty (doesn't have any element available to dequeue, 
            false otherwise
            </summary>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.UnsafeAdd(`0)">
            <summary>
            Add an element to the tail of the current segment
            exclusively called by ConcurrentQueue.InitializedFromCollection
            InitializeFromCollection is responsible to guaratee that there is no index overflow,
            and there is no contention
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.UnsafeGrow">
            <summary>
            Create a new segment and append to the current one
            Does not update the m_tail pointer
            exclusively called by ConcurrentQueue.InitializedFromCollection
            InitializeFromCollection is responsible to guaratee that there is no index overflow,
            and there is no contention
            </summary>
            <returns>the reference to the new Segment</returns>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.Grow">
            <summary>
            Create a new segment and append to the current one
            Update the m_tail pointer
            This method is called when there is no contention
            </summary>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.TryAppend(`0)">
            <summary>
            Try to append an element at the end of this segment.
            </summary>
            <param name="value">the element to append</param>
            <returns>true if the element is appended, false if the current segment is full</returns>
            <remarks>if appending the specified element succeeds, and after which the segment is full, 
            then grow the segment</remarks>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.TryRemove(`0@)">
            <summary>
            try to remove an element from the head of current segment
            </summary>
            <param name="result">The result.</param>
            <returns>return false only if the current segment is empty</returns>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.TryPeek(`0@)">
            <summary>
            try to peek the current segment
            </summary>
            <param name="result">holds the return value of the element at the head position, 
            value set to default(T) if there is no such an element</param>
            <returns>true if there are elements in the current segment, false otherwise</returns>
        </member>
        <member name="M:Net.Share.QueueSafe`1.Segment.AddToList(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>
            Adds part or all of the current segment into a List.
            </summary>
            <param name="list">the list to which to add</param>
            <param name="start">the start position</param>
            <param name="end">the end position</param>
        </member>
        <member name="P:Net.Share.QueueSafe`1.Segment.Low">
            <summary>
            return the position of the head of the current segment
            Value range [0, SEGMENT_SIZE], if it's SEGMENT_SIZE, it means this segment is exhausted and thus empty
            </summary>
        </member>
        <member name="P:Net.Share.QueueSafe`1.Segment.High">
            <summary>
            return the logical position of the tail of the current segment      
            Value range [-1, SEGMENT_SIZE-1]. When it's -1, it means this is a new segment and has no elemnet yet
            </summary>
        </member>
        <member name="T:Net.Share.VolatileBool">
            <summary>
            A wrapper struct for volatile bool, please note the copy of the struct it self will not be volatile
            for example this statement will not include in volatilness operation volatileBool1 = volatileBool2 the jit will copy the struct and will ignore the volatile
            </summary>
        </member>
        <member name="T:Net.Share.RandomSafe">
            <summary>
            随机类 (多线程安全)
            </summary>
        </member>
        <member name="M:Net.Share.ByteHelper.HumanReadableFilesize(System.Double)">
            <summary>
            转换方法
            </summary>
            <param name="size">字节值</param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.Data">
            <summary>
            序列化数据标示
            </summary>
        </member>
        <member name="T:Net.Share.NetConvert">
            <summary>
            网络转换核心 2019.7.16
            </summary>
        </member>
        <member name="T:Net.Share.NetConvert.LimitPropsContractResolver">
            <summary>
            
            </summary>
        </member>
        <member name="M:Net.Share.NetConvert.LimitPropsContractResolver.#ctor(System.String[],System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="props">传入的属性数组</param>
            <param name="retain">true:表示props是需要保留的字段  false：表示props是要排除的字段</param>
        </member>
        <member name="M:Net.Share.NetConvert.LimitPropsContractResolver.CreateProperties(System.Type,Newtonsoft_X.Json.MemberSerialization)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="memberSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvert.Serialize(Net.Share.RPCModel,System.Byte[])">
            <summary>
            新版网络序列化
            </summary>
            <param name="model">函数名</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvert.Deserialize(System.Byte[])">
            <summary>
            新版反序列化
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvert.Deserialize(System.Byte[],System.Int32,System.Int32)">
            <summary>
            新版反序列化
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:Net.Share.NetConvert.DeserializeComplex(System.Type,System.Byte[],System.Int32,System.Int32)">
            <summary>
            反序列化复杂类型
            </summary>
            <param name="type"></param>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="T:Net.Share.NetConvertBase">
            <summary>
            网络转换基础类
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBase.StringToValue(System.Type,System.String)">
            <summary>
            字符串转对象
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBase.StringToValue(System.String,System.String)">
            <summary>
            字符串转系统基础类型 ( type 给定类型名称 , value 转换这个字符串为type类型的值 )
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBase.ToVector2_3_4(System.String,System.String)">
            <summary>
            字符转三维向量值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBase.ToRect(System.String,System.String)">
            <summary>
            字符转矩形值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBase.ToColor(System.String,System.String)">
            <summary>
            字符转颜色值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBase.ToQuaternion(System.String,System.String)">
            <summary>
            字符转欧拉角值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBase.To_Vector234_Rect_Quaternion_Color(System.String,System.String)">
            <summary>
            转换字符为Vector2 或 Vector3 或 Vector4 或 Rect 或 Quaternion 的值 ( type 以字符形式给定一个类型 , value 类型的值 注：类型的值必须以给定类型的值符合才能转换成功 )
            </summary>
        </member>
        <member name="T:Net.Share.NetConvertBinary">
            <summary>
            提供序列化二进制类
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBinary.Init">
            <summary>
            初始化网络转换类型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBinary.AddNetworkBaseType">
            <summary>
            添加网络基本类型， int，float，bool，string......
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertBinary.AddNetworkType``1">
            <summary>
            添加可序列化的参数类型, 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
            <typeparam name="T">要添加的网络类型</typeparam>
        </member>
        <member name="M:Net.Share.NetConvertBinary.AddNetworkType(System.Type)">
            <summary>
            添加可序列化的参数类型, 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
            <param name="type">要添加的网络类型</param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.AddNetworkType(System.Type[])">
            <summary>
            添加可序列化的参数类型, 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.AddNetworkTypeAssembly(System.Type)">
            <summary>
            添加网络程序集，此方法将会添加获取传入的类的程序集并全部添加
            </summary>
            <param name="value">传入的类</param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.AddNetworkAssembly(System.Reflection.Assembly[])">
            <summary>
            添加网络传输程序集， 注意：添加客户端的程序集必须和服务器的程序集必须保持一致， 否则将会出现问题
            </summary>
            <param name="assemblies">程序集</param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.IndexToType(System.UInt16)">
            <summary>
            索引取类型
            </summary>
            <param name="typeIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.TypeToIndex(System.Type)">
            <summary>
            类型取索引
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.WriteValue``1(Net.Share.Segment,``0)">
            <summary>
            序列化基本类型
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.ReadValue(System.TypeCode,System.Byte[],System.Int32@)">
            <summary>
            反序列化基本类型
            </summary>
            <param name="type"></param>
            <param name="buffer"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.WriteArray(Net.Share.Segment,System.Collections.IList,System.Type,System.Boolean,System.Boolean)">
            <summary>
            序列化数组实体
            </summary>
            <param name="stream"></param>
            <param name="array"></param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.ReadArray(System.Byte[],System.Int32@,System.Collections.IList@,System.Type,System.Boolean,System.Boolean)">
            <summary>
            反序列化数组
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="array"></param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.SerializeComplex(System.Object,System.Boolean,System.Boolean)">
            <summary>
            序列化对象, 记录类型
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.Serialize(System.Object,System.Boolean,System.Boolean)">
            <summary>
            序列化
            </summary>
            <param name="obj"></param>
            <param name="recordType"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.SerializeObject``1(``0,System.Boolean,System.Boolean)">
            <summary>
            序列化对象, 不记录反序列化类型
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.SerializeObject``1(Net.Share.Segment,``0,System.Boolean,System.Boolean)">
            <summary>
            序列化对象, 不记录反序列化类型
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.WriteObject``1(Net.Share.Segment,System.Type,``0,System.Boolean,System.Boolean)">
            <summary>
            序列化对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="type"></param>
            <param name="target"></param>
            <param name="recordType"></param>
            <param name="ignore">忽略不使用<see cref="M:Net.Share.NetConvertBinary.AddBaseType``1"/>方法也会被序列化</param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.DeserializeObject``1(Net.Share.Segment,System.Boolean,System.Boolean)">
            <summary>
            反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <param name="recordType"></param>
            <param name="ignore">忽略不使用<see cref="M:Net.Share.NetConvertBinary.AddBaseType``1"/>方法也会被序列化</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.DeserializeObject``1(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
            <param name="recordType">序列化的类型字段是 object[]字段时, 可以帮你记录object的绝对类型</param>
            <param name="ignore">忽略不使用<see cref="M:Net.Share.NetConvertBinary.AddBaseType``1"/>方法也会被序列化</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertBinary.DeserializeComplex(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            反序列化复杂类型
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:Net.Share.NetConvertBinary.ReadObject(System.Byte[],System.Int32@,System.Type,System.Boolean,System.Boolean)">
            <summary>
            反序列化实体对象
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.NetConvertFast">
            <summary>
            快速解析类型, 使用此类需要使用AddNetworkType()先添加序列化类型, 类型是固定, 并且双端统一
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertFast.AddNetworkBaseType">
            <summary>
            添加网络基本类型， int，float，bool，string......
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertFast.AddNetworkType``1">
            <summary>
            添加可序列化的参数类型, 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertFast.AddNetworkType(System.Type)">
            <summary>
            添加经过网络传送的类型
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Net.Share.NetConvertFast.AddAssembly(System.Reflection.Assembly)">
            <summary>
            添加网络传输的程序集, 程序集内的所有类型都会被添加, 注意: 客户端和服务器都必须统一使用一模一样的程序集, 否则有可能出现问题!
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Net.Share.NetConvertFast.AddNameSpaceTypes(System.Reflection.Assembly,System.String)">
            <summary>
            添加assembly程序集的所有nameSpace命名空间的类型
            </summary>
            <param name="assembly"></param>
            <param name="nameSpace"></param>
        </member>
        <member name="M:Net.Share.NetConvertFast.DeserializeComplex(System.Type,System.Byte[],System.Int32,System.Int32)">
            <summary>
            反序列化复杂类型
            </summary>
            <param name="type"></param>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="T:Net.Share.ISerialize">
            <summary>
            快速序列化2接口--动态匹配
            </summary>
        </member>
        <member name="M:Net.Share.ISerialize.WriteValue(System.Object,Net.Share.Segment)">
            <summary>
            序列化写入
            </summary>
            <param name="value"></param>
            <param name="stream"></param>
        </member>
        <member name="M:Net.Share.ISerialize.ReadValue(Net.Share.Segment)">
            <summary>
            反序列化读取
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:Net.Share.ISerialize`1">
            <summary>
            快速序列化2接口---类型匹配
            </summary>
        </member>
        <member name="M:Net.Share.ISerialize`1.Write(`0,Net.Share.Segment)">
            <summary>
            序列化写入
            </summary>
            <param name="value"></param>
            <param name="stream"></param>
        </member>
        <member name="M:Net.Share.ISerialize`1.Read(Net.Share.Segment)">
            <summary>
            反序列化读取
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:Net.Share.NetConvertFast2">
            <summary>
            极速序列化2版本
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertFast2.Init">
            <summary>
            初始化网络转换类型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertFast2.AddBaseType">
            <summary>
            添加网络基本类型， int，float，bool，string......
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertFast2.AddSerializeType``1">
            <summary>
            添加可序列化的参数类型, 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
            <typeparam name="T">要添加的网络类型</typeparam>
        </member>
        <member name="M:Net.Share.NetConvertFast2.AddSerializeType3``1">
            <summary>
            添加可序列化的3个参数类型(T类,T类数组,T类List泛型), 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
            <typeparam name="T">要添加的网络类型</typeparam>
        </member>
        <member name="M:Net.Share.NetConvertFast2.AddSerializeType3(System.Type)">
            <summary>
            添加可序列化的3个参数类型(T类,T类数组,T类List泛型), 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertFast2.AddSerializeType(System.Type)">
            <summary>
            添加可序列化的参数类型, 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
            <param name="type">要添加的网络类型</param>
        </member>
        <member name="M:Net.Share.NetConvertFast2.AddSerializeType(System.Type[])">
            <summary>
            添加可序列化的参数类型, 网络参数类型 如果不进行添加将不会被序列化,反序列化
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:Net.Share.NetConvertFast2.IndexToType(System.UInt16)">
            <summary>
            索引取类型
            </summary>
            <param name="typeIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertFast2.TypeToIndex(System.Type)">
            <summary>
            类型取索引
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.FuncData">
            <summary>
            函数数据
            </summary>
        </member>
        <member name="F:Net.Share.FuncData.name">
            <summary>
            函数名称
            </summary>
        </member>
        <member name="F:Net.Share.FuncData.mask">
            <summary>
            方法遮罩
            </summary>
        </member>
        <member name="F:Net.Share.FuncData.pars">
            <summary>
            参数数组
            </summary>
        </member>
        <member name="F:Net.Share.FuncData.error">
            <summary>
            序列化是否错误?
            </summary>
        </member>
        <member name="M:Net.Share.FuncData.#ctor(System.String,System.Object[])">
            <summary>
            构造函数
            </summary>
            <param name="func"></param>
            <param name="pars"></param>
        </member>
        <member name="P:Net.Share.FuncData.Item(System.Int32)">
            <summary>
            取出index的参数值
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Net.Share.NetConvertOld">
            <summary>
            旧版网络转换，字符串转换
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.AddSerializeType``1">
            <summary>
            添加系列化类型,  当复杂类型时,如果不进行添加则系列化失败: 主要类型 Dictionary
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.AddSerializeType(System.Type)">
            <summary>
            添加系列化类型,  当复杂类型时,如果不进行添加则系列化失败: 主要类型 Dictionary
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Net.Share.NetConvertOld.GetType(System.String)">
            <summary>
            解释 : 获得应用程序当前已加载的所有程序集中查找typeName的类型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.GetTypeAll(System.String)">
            <summary>
            解释 : 获得应用程序当前已加载的所有程序集中查找typeName的类型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.GetTypeAll(System.Int32)">
            <summary>
            解释 : 获得应用程序当前已加载的所有程序集中查找typeName的类型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.ToBaseValue(System.Type,System.String)">
            <summary>
            反序列化基本类型
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertOld.WriteArray(System.Text.StringBuilder@,System.Array)">
            <summary>
            序列化数组实体
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.ToArray(System.String[],System.Int32@,System.Type)">
            <summary>
            反序列化数组
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.ToArray(System.String[],System.Int32@,System.Array@)">
            <summary>
            反序列化数组
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.ToEnum(System.String[],System.Int32@)">
            <summary>
            反序列化枚举类型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.Serialize(System.Object[])">
            <summary>
            新版网络序列化
            </summary>
            <param name="pars"></param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertOld.Serialize(System.String,System.Object[])">
            <summary>
            新版网络序列化
            </summary>
            <param name="funcName">函数名</param>
            <param name="pars">参数</param>
            <returns></returns>
        </member>
        <member name="M:Net.Share.NetConvertOld.WriteObject(System.Text.StringBuilder@,System.Type,System.Object)">
            <summary>
            序列化实体类型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.Deserialize(System.String)">
            <summary>
            新版反序列化
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.Deserialize(System.String,System.Action{System.String,System.Object[]})">
            <summary>
            新版反序列化
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.Deserialize(System.String[],System.Int32,System.Int32)">
            <summary>
            新版反序列化
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.Deserialize(System.String[],System.Int32,System.Int32,System.Action{System.String,System.Object[]})">
            <summary>
            新版反序列化
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.ToObject(System.String[],System.Int32@,System.Type)">
            <summary>
            反序列化实体对象
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.ToList(System.String[],System.Int32@,System.Type)">
            <summary>
            反序列化泛型
            </summary>
        </member>
        <member name="M:Net.Share.NetConvertOld.ToDictionary(System.String[],System.Int32@,System.Type)">
            <summary>
            反序列化字典类型
            </summary>
        </member>
        <member name="T:Net.Matrix3x3">
            <summary>
            3x3矩阵
            </summary>
        </member>
        <member name="T:Net.Helper.DCSHelper`2">
            <summary>
            分散控制系统（分布式子服务器）案例代码 需要开发者扩展
            <code>服务器先时连接网关服务器，委托网关服务器存ip和端口，当网关服务器有客户端连接后，会指派客户端连接的子服务器</code>
            </summary>
            <typeparam name="Player"></typeparam>
            <typeparam name="Scene"></typeparam>
        </member>
        <member name="T:Net.Helper.GatewayServer`1">
            <summary>
            网关服务器(主服务器), 负责分配客户端连接最优的游戏服务器, 负载均衡
            <code>第一步:客户端连接网关服务器，然后网关服务器将集群游戏服务器的ip，端口发给客户端</code>
            <code>第二步:客户端自动连接到指定的游戏服务器上，请查看NetCmd.SwitchPort指令说明</code>
            </summary>
        </member>
        <member name="F:Net.Helper.GatewayServer`1.serverArea">
            <summary>
            分布式(集群)游戏服务器列表
            </summary>
        </member>
        <member name="F:Net.Helper.GatewayServer`1.OnAreaUpdate">
            <summary>
            当分布服务器更新时调用
            </summary>
        </member>
        <member name="T:ECS.Component">
            <summary>
            ECS构架可以将此组件从Entity上移除这个组件并丢入对象池，给其他此刻需要此组件的Entity使用，因此可以节省大量的内存反复创建和释放， 这也是ECS的特性可以大量重复使用Compoent
            </summary>
        </member>
        <member name="T:ECS.Entity">
            <summary>
            ecs实体类, 实体类管理组件的集合 当不使用的时候会丢入system对象池, 给之后创建实体时再次复用
            </summary>
        </member>
        <member name="M:ECS.Entity.#ctor">
            <summary>
            创建实体, 默认是GSystem的单例
            </summary>
        </member>
        <member name="M:ECS.Entity.AddComponent``1">
            <summary>
            添加组件, 从system对象池取出对象, 并添加到entity组件列表
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ECS.GObject.Destroy(ECS.GObject,System.Boolean)">
            <summary>
            移除实体或组件, 并将对象扔进system对象池, 当AddComponent或Create时可以复用
            </summary>
            <param name="gObject"></param>
            <param name="reuse">此对象可以复用? 复用会将对象丢入system对象池, 等待再次使用. 如果是entity对象, 并且不复用, 则把entity所使用的组件也同样不再复用</param>
        </member>
        <member name="T:ECS.GSystem">
            <summary>
            ecs系统, 此系统管理entity和conponent对象池(复用)
            </summary>
        </member>
        <member name="F:ECS.GSystem.Instance">
            <summary>
            system的单例对象
            </summary>
        </member>
        <member name="M:ECS.GSystem.AddEntity(ECS.Entity)">
            <summary>
            添加实体
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:ECS.GSystem.Take``1">
            <summary>
            取出实体组件, 复用
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ECS.GSystem.Push(ECS.GObject)">
            <summary>
            压入实体组件, 后面复用
            </summary>
            <param name="gObject"></param>
        </member>
        <member name="M:ECS.GSystem.Create``1">
            <summary>
            创建实体对象, 从对象池进行查询, 如果对象池存在对象, 则返回对象池的对象, 否则创建一个新的T对象
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ECS.GSystem.Create``1(``0)">
            <summary>
            创建实体对象, 从对象池进行查询, 如果对象池存在对象, 则返回对象池的对象, 否则创建一个新的T对象
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ECS.GSystem.Update(System.Boolean)">
            <summary>
            更新ecs系统
            </summary>
            <param name="worker">线程池并行?</param>
        </member>
        <member name="M:ECS.GSystem.Run(System.Boolean)">
            <summary>
            运行ecs
            </summary>
            <param name="worker">线程池并行?</param>
        </member>
        <member name="T:ECS.IUpdate">
            <summary>
            ecs组件更新接口, 减少组件for循环开销
            </summary>
        </member>
        <member name="M:ECS.IUpdate.Update">
            <summary>
            每帧更新
            </summary>
        </member>
        <member name="T:ECS.UpdateComponent">
            <summary>
            热更层借助此组件进行更新, ilr不支持多继承, 接口继承
            </summary>
        </member>
        <member name="M:ILRuntime.CLR.TypeSystem.ILType.#ctor(ILRuntime.Mono.Cecil.TypeReference,ILRuntime.Runtime.Enviorment.AppDomain)">
            <summary>
            初始化IL类型
            </summary>
            <param name="def">MONO返回的类型定义</param>
            <param name="domain">ILdomain</param>
        </member>
        <member name="M:ILRuntime.CLR.TypeSystem.ILType.RetriveDefinitino(ILRuntime.Mono.Cecil.TypeReference)">
            <summary>
            加载类型
            </summary>
            <param name="def"></param>
        </member>
        <member name="M:ILRuntime.CLR.TypeSystem.IType.GetMethod(System.String,System.Int32,System.Boolean)">
            <summary>
            Get a specified Method in this type
            </summary>
            <param name="name">Name of the Type</param>
            <param name="paramCount">Parameter count</param>
            <param name="declaredOnly">True to search the methods decleared in this type only, false to search base types.</param>
            <returns></returns>
        </member>
        <member name="M:ILRuntime.CLR.TypeSystem.IType.GetMethod(System.String,System.Collections.Generic.List{ILRuntime.CLR.TypeSystem.IType},ILRuntime.CLR.TypeSystem.IType[],ILRuntime.CLR.TypeSystem.IType,System.Boolean)">
            <summary>
             Get a specified Method in this type
            </summary>
            <param name="name">Name of the Type</param>
            <param name="param">List of parameter's types</param>
            <param name="genericArguments">List of Generic Arguments</param>
            <param name="returnType">Return Type</param>
            <param name="declaredOnly">True to search the methods decleared in this type only, false to search base types.</param>
            <returns></returns>
        </member>
        <member name="F:ILRuntime.Mono.Cecil.TypeComparisonMode.SignatureOnlyLoose">
            <summary>
            Types can be in different assemblies, as long as the module, assembly, and type names match they will be considered equal
            </summary>
        </member>
        <member name="T:ILRuntime.Other.DelegateExportAttribute">
            <summary>
            A Delegate Custom Attr, It tells the CodeGenerationTools : this delegate need to register a delegate convertor,when generate ILRuntimeHelper.cs file.
            </summary>
        </member>
        <member name="T:ILRuntime.Other.NeedAdaptorAttribute">
            <summary>
            A Class Custom Attr, It tells the CodeGenerationTools :there is a class need to generate an adaptor for ILScript
            </summary>
        </member>
        <member name="T:ILRuntime.Other.ThreadSafeDictionary`2">
            <summary>
            A thread safe dictionary for internal use
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:ILRuntime.Other.UncheckedList`1">
            <summary>
            This is a copy of the latest .NET framework 4.5 List implementation, with all extraneous checking removed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ILRuntime.Runtime.CLRBinding.CLRBindingUtils.Initialize(ILRuntime.Runtime.Enviorment.AppDomain)">
            <summary>
            This method can instead of CLRBindings.Initialize for avoid compile error when hasn't generator bindingCode.
            </summary>
            <param name="appDomain"></param>
        </member>
        <member name="P:ILRuntime.Runtime.Debugger.DebuggerServer.Port">
            <summary>
            服务器监听的端口
            </summary>
        </member>
        <member name="M:ILRuntime.Runtime.Debugger.DebugService.StartDebugService(System.Int32)">
            <summary>
            Start Debugger Server
            </summary>
            <param name="port">Port to listen on</param>
        </member>
        <member name="M:ILRuntime.Runtime.Debugger.DebugService.StopDebugService">
            <summary>
            Stop Debugger Server
            </summary>
        </member>
        <member name="M:ILRuntime.Runtime.Debugger.DebugService.Break(ILRuntime.Runtime.Intepreter.ILIntepreter,System.Exception)">
            <summary>
            中断运行
            </summary>
            <param name="intpreter"></param>
            <param name="ex"></param>
            <returns>如果挂的有调试器则返回true</returns>
        </member>
        <member name="P:ILRuntime.Runtime.Enviorment.AppDomain.AllowUnboundCLRMethod">
            <summary>
            Determine if invoking unbinded CLR method(using reflection) is allowed
            </summary>
        </member>
        <member name="P:ILRuntime.Runtime.Enviorment.AppDomain.LoadedTypes">
            <summary>
            Attention, this property isn't thread safe
            </summary>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.LoadAssemblyFile(System.String)">
            <summary>
            加载Assembly 文件，从指定的路径
            </summary>
            <param name="path">路径</param>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.LoadAssembly(System.IO.Stream)">
            <summary>
            从流加载Assembly 不加载symbol符号文件
            </summary>
            <param name="stream">Dll数据流</param>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.LoadAssembly(System.IO.Stream,System.IO.Stream,ILRuntime.Mono.Cecil.Cil.ISymbolReaderProvider)">
            <summary>
            从流加载Assembly,以及symbol符号文件(pdb)
            </summary>
            <param name="stream">Assembly Stream</param>
            <param name="symbol">symbol Stream</param>
            <param name="symbolReader">symbol 读取器</param>
            <param name="inMemory">是否完整读入内存</param>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.AddReferenceBytes(System.String,System.Byte[])">
            <summary>
            External reference should be added to the AppDomain by the method
            </summary>
            <param name="name">Assembly name, without .dll</param>
            <param name="content">file content</param>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.GetType(System.String)">
            <summary>
            更近类型名称返回类型
            </summary>
            <param name="fullname">类型全名 命名空间.类型名</param>
            <returns></returns>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.GetType(System.Type)">
            <summary>
            根据CLR类型获取 IL类型
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.Instantiate``1(System.String,System.Object[])">
            <summary>
            Create a instance of the specified type, which is inherited from a CLR Type
            </summary>
            <typeparam name="T">CLR Type</typeparam>
            <param name="type">Full Name of the type</param>
            <param name="args">Arguments for the constructor</param>
            <returns></returns>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.Instantiate(System.String,System.Object[])">
            <summary>
            Create a instance of the specified type
            </summary>
            <param name="type">Full Name of the type</param>
            <param name="args">Arguments for the constructor</param>
            <returns></returns>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.Prewarm(System.String,System.Boolean)">
            <summary>
            Prewarm all methods of the specified type
            </summary>
            <param name="type"></param>
            <param name="recursive"></param>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.Prewarm(ILRuntime.Runtime.Enviorment.PrewarmInfo[],System.Boolean)">
            <summary>
            Prewarm all methods specified by the parameter
            </summary>
            <param name="info"></param>
            <param name="recursive"></param>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.Invoke(System.String,System.String,System.Object,System.Object[])">
            <summary>
            Invoke a method
            </summary>
            <param name="type">Type's fullname</param>
            <param name="method">Method name</param>
            <param name="p">Parameters</param>
            <returns></returns>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.InvokeGenericMethod(System.String,System.String,ILRuntime.CLR.TypeSystem.IType[],System.Object,System.Object[])">
            <summary>
            Invoke a generic method
            </summary>
            <param name="type">Type's fullname</param>
            <param name="method">Method name</param>
            <param name="genericArguments">Generic Arguments</param>
            <param name="instance">Object Instance of the method</param>
            <param name="p">Parameters</param>
            <returns></returns>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.AppDomain.Invoke(ILRuntime.CLR.Method.IMethod,System.Object,System.Object[])">
            <summary>
            Invokes a specific method
            </summary>
            <param name="m">Method</param>
            <param name="instance">object instance</param>
            <param name="p">Parameters</param>
            <returns></returns>
        </member>
        <member name="T:ILRuntime.Runtime.Enviorment.CrossBindingAdaptor">
            <summary>
            This interface is used for inheritance and implementation of CLR Types or interfaces
            </summary>
        </member>
        <member name="P:ILRuntime.Runtime.Enviorment.CrossBindingAdaptor.BaseCLRType">
            <summary>
            This returns the CLR type to be inherited or CLR interface to be implemented
            </summary>
        </member>
        <member name="P:ILRuntime.Runtime.Enviorment.CrossBindingAdaptor.BaseCLRTypes">
            <summary>
            If this Adaptor is capable to impelement multuple interfaces, use this Property, AND BaseCLRType should return null
            </summary>
        </member>
        <member name="M:ILRuntime.Runtime.Enviorment.DelegateManager.FindDelegateAdapter(ILRuntime.Runtime.Intepreter.ILTypeInstance,ILRuntime.CLR.Method.ILMethod,ILRuntime.CLR.Method.IMethod)">
            <summary>
            ilMethod代表的delegate会赋值给method对应的delegate，一般两者参数类型都一致，
            但新版本的支持泛型协变之后，有些时候会不一致，所以此处判断是用method判断，而不是用ilMethod判断
            </summary>
            <param name="instance"></param>
            <param name="ilMethod"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="P:ILRuntime.Runtime.Intepreter.ILTypeInstance.Boxed">
            <summary>
            是否已装箱
            </summary>
        </member>
        <member name="T:ILRuntime.Runtime.Intepreter.OpCodes.OpCode">
            <summary>
            IL指令
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCode.Code">
            <summary>
            当前指令
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCode.TokenInteger">
            <summary>
             Int32 操作数
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCode.TokenLong">
            <summary>
            Int64 操作数
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Nop">
            <summary>
            如果修补操作码，则填充空间。尽管可能消耗处理周期，但未执行任何有意义的操作。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Break">
            <summary>
            向公共语言结构 (CLI) 发出信号以通知调试器已撞上了一个断点。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarg_0">
            <summary>
            将索引为 0 的参数加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarg_1">
            <summary>
            将索引为 1 的参数加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarg_2">
            <summary>
            将索引为 2 的参数加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarg_3">
            <summary>
            将索引为 3 的参数加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloc_0">
            <summary>
            将索引 0 处的局部变量加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloc_1">
            <summary>
            将索引 1 处的局部变量加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloc_2">
            <summary>
            将索引 2 处的局部变量加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloc_3">
            <summary>
            将索引 3 处的局部变量加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stloc_0">
            <summary>
            从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stloc_1">
            <summary>
            从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stloc_2">
            <summary>
            从计算堆栈的顶部弹出当前值并将其存储到索引 2 处的局部变量列表中。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stloc_3">
            <summary>
            从计算堆栈的顶部弹出当前值并将其存储到索引 3 处的局部变量列表中。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarg_S">
            <summary>
            将参数（由指定的短格式索引引用）加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarga_S">
            <summary>
            以短格式将参数地址加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Starg_S">
            <summary>
            将位于计算堆栈顶部的值存储在参数槽中的指定索引处（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloc_S">
            <summary>
            将特定索引处的局部变量加载到计算堆栈上（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloca_S">
            <summary>
            将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stloc_S">
            <summary>
            从计算堆栈的顶部弹出当前值并将其存储在局部变量列表中的 index 处（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldnull">
            <summary>
            将空引用（O 类型）推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_M1">
            <summary>
            将整数值 -1 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_0">
            <summary>
            将整数值 0 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_1">
            <summary>
            将整数值 1 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_2">
            <summary>
            将整数值 2 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_3">
            <summary>
            将整数值 3 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_4">
            <summary>
            将整数值 4 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_5">
            <summary>
            将整数值 5 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_6">
            <summary>
            将整数值 6 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_7">
            <summary>
            将整数值 7 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_8">
            <summary>
            将整数值 8 作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4_S">
            <summary>
            将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I4">
            <summary>
            将所提供的 int32 类型的值作为 int32 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_I8">
            <summary>
            将所提供的 int64 类型的值作为 int64 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_R4">
            <summary>
            将所提供的 float32 类型的值作为 F (float) 类型推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldc_R8">
            <summary>
            将所提供的 float64 类型的值作为 F (float) 类型推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Dup">
            <summary>
            复制计算堆栈上当前最顶端的值，然后将副本推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Pop">
            <summary>
            移除当前位于计算堆栈顶部的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Jmp">
            <summary>
            退出当前方法并跳至指定方法。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Call">
            <summary>
            调用由传递的方法说明符指示的方法。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Calli">
            <summary>
            通过调用约定描述的参数调用在计算堆栈上指示的方法（作为指向入口点的指针）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ret">
            <summary>
            从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Br_S">
            <summary>
            无条件地将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Brfalse_S">
            <summary>
            如果 value 为 false、空引用或零，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Brtrue_S">
            <summary>
            如果 value 为 true、非空或非零，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Beq_S">
            <summary>
            如果两个值相等，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bge_S">
            <summary>
            如果第一个值大于或等于第二个值，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bgt_S">
            <summary>
            如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ble_S">
            <summary>
            如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Blt_S">
            <summary>
            如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bne_Un_S">
            <summary>
            当两个无符号整数值或不可排序的浮点型值不相等时，将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bge_Un_S">
            <summary>
            当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bgt_Un_S">
            <summary>
            当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ble_Un_S">
            <summary>
            当比较无符号整数值或不可排序的浮点值时，如果第一个值小于或等于第二个值，则将控制权转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Blt_Un_S">
            <summary>
            当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Br">
            <summary>
            无条件地将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Brfalse">
            <summary>
            如果 value 为 false、空引用（Visual Basic 中的 Nothing）或零，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Brtrue">
            <summary>
            如果 value 为 true、非空或非零，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Beq">
            <summary>
            如果两个值相等，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bge">
            <summary>
            如果第一个值大于或等于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bgt">
            <summary>
            如果第一个值大于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ble">
            <summary>
            如果第一个值小于或等于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Blt">
            <summary>
            如果第一个值小于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bne_Un">
            <summary>
            当两个无符号整数值或不可排序的浮点型值不相等时，将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bge_Un">
            <summary>
            当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Bgt_Un">
            <summary>
            当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ble_Un">
            <summary>
            当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Blt_Un">
            <summary>
            当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于第二个值，则将控制转移到目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Switch">
            <summary>
            实现跳转表。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_I1">
            <summary>
            将 int8 类型的值作为 int32 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_U1">
            <summary>
            将 unsigned int8 类型的值作为 int32 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_I2">
            <summary>
            将 int16 类型的值作为 int32 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_U2">
            <summary>
            将 unsigned int16 类型的值作为 int32 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_I4">
            <summary>
            将 int32 类型的值作为 int32 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_U4">
            <summary>
            将 unsigned int32 类型的值作为 int32 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_I8">
            <summary>
            将 int64 类型的值作为 int64 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_I">
            <summary>
            将 native int 类型的值作为 native int 间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_R4">
            <summary>
            将 float32 类型的值作为 F (float) 类型间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_R8">
            <summary>
            将 float64 类型的值作为 F (float) 类型间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldind_Ref">
            <summary>
            将对象引用作为 O（对象引用）类型间接加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_Ref">
            <summary>
            存储所提供地址处的对象引用值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_I1">
            <summary>
            在所提供的地址存储 int8 类型的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_I2">
            <summary>
            在所提供的地址存储 int16 类型的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_I4">
            <summary>
            在所提供的地址存储 int32 类型的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_I8">
            <summary>
            在所提供的地址存储 int64 类型的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_R4">
            <summary>
            在所提供的地址存储 float32 类型的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_R8">
            <summary>
            在所提供的地址存储 float64 类型的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Add">
            <summary>
            将两个值相加并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Sub">
            <summary>
            从其他值中减去一个值并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Mul">
            <summary>
            将两个值相乘并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Div">
            <summary>
            将两个值相除并将结果作为浮点（F 类型）或商（int32 类型）推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Div_Un">
            <summary>
            两个无符号整数值相除并将结果 ( int32 ) 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Rem">
            <summary>
            将两个值相除并将余数推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Rem_Un">
            <summary>
            将两个无符号值相除并将余数推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.And">
            <summary>
            计算两个值的按位“与”并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Or">
            <summary>
            计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Xor">
            <summary>
            计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Shl">
            <summary>
            将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Shr">
            <summary>
            将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Shr_Un">
            <summary>
            将无符号整数值右移（用零填充）指定的位数，并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Neg">
            <summary>
            对一个值执行求反并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Not">
            <summary>
            计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_I1">
            <summary>
            将位于计算堆栈顶部的值转换为 int8，然后将其扩展（填充）为 int32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_I2">
            <summary>
            将位于计算堆栈顶部的值转换为 int16，然后将其扩展（填充）为 int32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_I4">
            <summary>
            将位于计算堆栈顶部的值转换为 int32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_I8">
            <summary>
            将位于计算堆栈顶部的值转换为 int64。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_R4">
            <summary>
            将位于计算堆栈顶部的值转换为 float32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_R8">
            <summary>
            将位于计算堆栈顶部的值转换为 float64。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_U4">
            <summary>
            将位于计算堆栈顶部的值转换为 unsigned int32，然后将其扩展为 int32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_U8">
            <summary>
            将位于计算堆栈顶部的值转换为 unsigned int64，然后将其扩展为 int64。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Callvirt">
            <summary>
            对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Cpobj" -->
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldobj">
            <summary>
            将地址指向的值类型对象复制到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldstr">
            <summary>
            推送对元数据中存储的字符串的新对象引用。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Newobj">
            <summary>
            创建一个值类型的新对象或新实例，并将对象引用（O 类型）推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Castclass">
            <summary>
            尝试将引用传递的对象转换为指定的类。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Isinst">
            <summary>
            测试对象引用（O 类型）是否为特定类的实例。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_R_Un">
            <summary>
            将位于计算堆栈顶部的无符号整数值转换为 float32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Unbox">
            <summary>
            将值类型的已装箱的表示形式转换为其未装箱的形式。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Throw">
            <summary>
            引发当前位于计算堆栈上的异常对象。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldfld">
            <summary>
            查找对象中其引用当前位于计算堆栈的字段的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldflda">
            <summary>
            查找对象中其引用当前位于计算堆栈的字段的地址。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stfld">
            <summary>
            用新值替换在对象引用或指针的字段中存储的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldsfld">
            <summary>
            将静态字段的值推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldsflda">
            <summary>
            将静态字段的地址推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stsfld">
            <summary>
            用来自计算堆栈的值替换静态字段的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stobj">
            <summary>
            将指定类型的值从计算堆栈复制到所提供的内存地址中。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I1_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为有符号 int8 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I2_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为有符号 int16 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I4_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为有符号 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I8_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为有符号 int64，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U1_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为 unsigned int8 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U2_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为 unsigned int16 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U4_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为 unsigned int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U8_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为 unsigned int64，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为有符号 native int，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U_Un">
            <summary>
            将位于计算堆栈顶部的无符号值转换为 unsigned native int，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Box">
            <summary>
            将值类转换为对象引用（O 类型）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Newarr">
            <summary>
            将对新的从零开始的一维数组（其元素属于特定类型）的对象引用推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldlen">
            <summary>
            将从零开始的、一维数组的元素的数目推送到计算堆栈上。
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelema" -->
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_I1">
            <summary>
            将位于指定数组索引处的 int8 类型的元素作为 int32 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_U1">
            <summary>
            将位于指定数组索引处的 unsigned int8 类型的元素作为 int32 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_I2">
            <summary>
            将位于指定数组索引处的 int16 类型的元素作为 int32 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_U2">
            <summary>
            将位于指定数组索引处的 unsigned int16 类型的元素作为 int32 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_I4">
            <summary>
            将位于指定数组索引处的 int32 类型的元素作为 int32 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_U4">
            <summary>
            将位于指定数组索引处的 unsigned int32 类型的元素作为 int32 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_I8">
            <summary>
            将位于指定数组索引处的 int64 类型的元素作为 int64 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_I">
            <summary>
            将位于指定数组索引处的 native int 类型的元素作为 native int 加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_R4">
            <summary>
            将位于指定数组索引处的 float32 类型的元素作为 F 类型（浮点型）加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_R8">
            <summary>
            将位于指定数组索引处的 float64 类型的元素作为 F 类型（浮点型）加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_Ref">
            <summary>
            将位于指定数组索引处的包含对象引用的元素作为 O 类型（对象引用）加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_I">
            <summary>
            用计算堆栈上的 native int 值替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_I1">
            <summary>
            用计算堆栈上的 int8 值替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_I2">
            <summary>
            用计算堆栈上的 int16 值替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_I4">
            <summary>
            用计算堆栈上的 int32 值替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_I8">
            <summary>
            用计算堆栈上的 int64 值替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_R4">
            <summary>
            用计算堆栈上的 float32 值替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_R8">
            <summary>
            用计算堆栈上的 float64 值替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_Ref">
            <summary>
            用计算堆栈上的对象 ref 值（O 类型）替换给定索引处的数组元素。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldelem_Any">
            <summary>
            按照指令中指定的类型，将指定数组索引中的元素加载到计算堆栈的顶部。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stelem_Any">
            <summary>
            用计算堆栈中的值替换给定索引处的数组元素，其类型在指令中指定。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Unbox_Any">
            <summary>
            将指令中指定类型的已装箱的表示形式转换成未装箱形式。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I1">
            <summary>
            将位于计算堆栈顶部的有符号值转换为有符号 int8 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U1">
            <summary>
            将位于计算堆栈顶部的有符号值转换为 unsigned int8 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I2">
            <summary>
            将位于计算堆栈顶部的有符号值转换为有符号 int16 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U2">
            <summary>
            将位于计算堆栈顶部的有符号值转换为 unsigned int16 并将其扩展为 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I4">
            <summary>
            将位于计算堆栈顶部的有符号值转换为有符号 int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U4">
            <summary>
            将位于计算堆栈顶部的有符号值转换为 unsigned int32，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I8">
            <summary>
            将位于计算堆栈顶部的有符号值转换为有符号 int64，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U8">
            <summary>
            将位于计算堆栈顶部的有符号值转换为 unsigned int64，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Refanyval" -->
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ckfinite">
            <summary>
            如果值不是有限数，则引发 ArithmeticException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Mkrefany">
            <summary>
            将对特定类型实例的类型化引用推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldtoken">
            <summary>
            将元数据标记转换为其运行时表示形式，并将其推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_U2">
            <summary>
            将位于计算堆栈顶部的值转换为 unsigned int16，然后将其扩展为 int32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_U1">
            <summary>
            将位于计算堆栈顶部的值转换为 unsigned int8，然后将其扩展为 int32。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_I">
            <summary>
            将位于计算堆栈顶部的值转换为 native int。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_I">
            <summary>
            将位于计算堆栈顶部的有符号值转换为有符号 native int，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_Ovf_U">
            <summary>
            将位于计算堆栈顶部的有符号值转换为 unsigned native int，并在溢出时引发 OverflowException。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Add_Ovf">
            <summary>
            将两个整数相加，执行溢出检查，并且将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Add_Ovf_Un">
            <summary>
            将两个无符号整数值相加，执行溢出检查，并且将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Mul_Ovf">
            <summary>
            将两个整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Mul_Ovf_Un">
            <summary>
            将两个无符号整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Sub_Ovf">
            <summary>
            从另一值中减去一个整数值，执行溢出检查，并且将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Sub_Ovf_Un">
            <summary>
            从另一值中减去一个无符号整数值，执行溢出检查，并且将结果推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Endfinally">
            <summary>
            将控制从异常块的 fault 或 finally 子句转移回公共语言结构 (CLI) 异常处理程序。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Leave">
            <summary>
            退出受保护的代码区域，无条件将控制转移到特定目标指令。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Leave_S">
            <summary>
            退出受保护的代码区域，无条件将控制转移到目标指令（缩写形式）。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stind_I">
            <summary>
            在所提供的地址存储 native int 类型的值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Conv_U">
            <summary>
            将位于计算堆栈顶部的值转换为 unsigned native int，然后将其扩展为 native int。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Arglist">
            <summary>
            返回指向当前方法的参数列表的非托管指针。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ceq">
            <summary>
            比较两个值。如果这两个值相等，则将整数值 1 (int32) 推送到计算堆栈上；否则，将 0 (int32) 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Cgt">
            <summary>
            比较两个值。如果第一个值大于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Cgt_Un">
            <summary>
            比较两个无符号的或不可排序的值。如果第一个值大于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Clt">
            <summary>
            比较两个值。如果第一个值小于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Clt_Un">
            <summary>
            比较无符号的或不可排序的值 value1 和 value2。如果 value1 小于 value2，则将整数值 1 (int32 ) 推送到计算堆栈上；反之，将 0 ( int32 ) 推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldftn">
            <summary>
            将指向实现特定方法的本机代码的非托管指针（native int 类型）推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldvirtftn">
            <summary>
            将指向实现与指定对象关联的特定虚方法的本机代码的非托管指针（native int 类型）推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarg">
            <summary>
            将参数（由指定索引值引用）加载到堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldarga">
            <summary>
            将参数地址加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Starg">
            <summary>
            将位于计算堆栈顶部的值存储到位于指定索引的参数槽中。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloc">
            <summary>
            将指定索引处的局部变量加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Ldloca">
            <summary>
            将位于特定索引处的局部变量的地址加载到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Stloc">
            <summary>
            从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Localloc">
            <summary>
            从本地动态内存池分配特定数目的字节并将第一个分配的字节的地址（瞬态指针，* 类型）推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Endfilter">
            <summary>
            将控制从异常的 filter 子句转移回公共语言结构 (CLI) 异常处理程序。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Unaligned">
            <summary>
            指示当前位于计算堆栈上的地址可能没有与紧接的 ldind、stind、ldfld、stfld、ldobj、stobj、initblk 或 cpblk 指令的自然大小对齐。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Volatile">
            <summary>
            指定当前位于计算堆栈顶部的地址可以是易失的，并且读取该位置的结果不能被缓存，或者对该地址的多个存储区不能被取消。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Tail">
            <summary>
            执行后缀的方法调用指令，以便在执行实际调用指令前移除当前方法的堆栈帧。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Initobj">
            <summary>
            将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Constrained">
            <summary>
            约束要对其进行虚方法调用的类型。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Cpblk">
            <summary>
            将指定数目的字节从源地址复制到目标地址。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Initblk">
            <summary>
            将位于特定地址的内存的指定块初始化为给定大小和初始值。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Rethrow">
            <summary>
            再次引发当前异常。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Sizeof">
            <summary>
            将提供的值类型的大小（以字节为单位）推送到计算堆栈上。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Refanytype">
            <summary>
            检索嵌入在类型化引用内的类型标记。
            </summary>
        </member>
        <member name="F:ILRuntime.Runtime.Intepreter.OpCodes.OpCodeEnum.Readonly">
            <summary>
            指定后面的数组地址操作在运行时不执行类型检查，并且返回可变性受限的托管指针。
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Pdb.ILocalScope">
            <summary>
            A range of CLR IL operations that comprise a lexical scope, specified as an IL offset and a length.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.ILocalScope.Offset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.ILocalScope.Length">
            <summary>
            The length of the scope. Offset+Length equals the offset of the first operation outside the scope, or equals the method body length.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Pdb.INamespaceScope">
            <summary>
            A description of the lexical scope in which a namespace type has been nested. This scope is tied to a particular
            method body, so that partial types can be accommodated.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.INamespaceScope.UsedNamespaces">
            <summary>
            Zero or more used namespaces. These correspond to using clauses in C#.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Pdb.IUsedNamespace">
            <summary>
            A namespace that is used (imported) inside a namespace scope.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.IUsedNamespace.Alias">
            <summary>
            An alias for a namespace. For example the "x" of "using x = y.z;" in C#. Empty if no alias is present.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.IUsedNamespace.NamespaceName">
            <summary>
            The name of a namepace that has been aliased.  For example the "y.z" of "using x = y.z;" or "using y.z" in C#.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Pdb.IName">
            <summary>
            The name of an entity. Typically name instances come from a common pool. Within the pool no two distinct instances will have the same Value or UniqueKey.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.IName.UniqueKey">
            <summary>
            An integer that is unique within the pool from which the name instance has been allocated. Useful as a hashtable key.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.IName.UniqueKeyIgnoringCase">
            <summary>
            An integer that is unique within the pool from which the name instance has been allocated. Useful as a hashtable key.
            All name instances in the pool that have the same string value when ignoring the case of the characters in the string
            will have the same key value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Pdb.IName.Value">
            <summary>
            The string value corresponding to this name.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Pdb.PdbConstant">
            <summary />
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbFile.BasicLanguageGuid">
            <summary>
            GUID of the Basic source language.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbFunction.visualBasicScopesAdjusted">
            <summary>
            Flag saying whether the method has been identified as a product of VB compilation using
            the legacy Windows PDB symbol format, in which case scope ends need to be shifted by 1
            due to different semantics of scope limits in VB and C# compilers.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Pdb.PdbFunction.AdjustVisualBasicScopes">
            <summary>
            When the Windows PDB reader identifies a PdbFunction as having 'Basic' as its source language,
            it calls this method which adjusts all scopes by adding 1 to their lengths to compensate
            for different behavior of VB vs. the C# compiler w.r.t. emission of scope info.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Pdb.PdbFunction.AdjustVisualBasicScopes(Microsoft.Cci.Pdb.PdbScope[])">
            <summary>
            Recursively update the entire scope tree by adding 1 to the length of each scope.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Pdb.PdbInfo">
            <summary>
            This class represents the information read from a PDB file (both legacy Windows and Portable).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbInfo.Functions">
            <summary>
            Enumeration of per-function information contained in the PDB file.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbInfo.TokenToSourceMapping">
            <summary>
            Mapping from tokens to source files and line numbers.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbInfo.SourceServerData">
            <summary>
            Source server data information.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbInfo.Age">
            <summary>
            Age of the PDB file is used to match the PDB against the PE binary.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbInfo.Guid">
            <summary>
            GUID of the PDB file is used to match the PDB against the PE binary.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Pdb.PdbInfo.SourceLinkData">
            <summary>
            Source link data information.
            </summary>
        </member>
        <member name="T:Binding.Dictionary_String_List1__Bind">
            <summary>
            这是要开发者自己写的绑定代码, 生成工具目前还没能生成这样的代码
            </summary>
        </member>
        <member name="T:Binding.Dictionary_Int32_Boolean__Bind">
            <summary>
            这是要开发者自己写的绑定代码, 生成工具目前还没能生成这样的代码
            </summary>
        </member>
        <member name="M:Fast2BuildMethod.DynamicBuild(System.Type[])">
            <summary>
            动态编译, 在unity开发过程中不需要生成绑定cs文件, 直接运行时编译使用, 当编译apk. app时才进行生成绑定cs文件
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Fast2BuildMethod.DynamicBuild(System.Int32,System.Type[])">
            <summary>
            动态编译, 在unity开发过程中不需要生成绑定cs文件, 直接运行时编译使用, 当编译apk. app时才进行生成绑定cs文件
            </summary>
            <param name="compilerOptionsIndex">编译参数, 如果编译失败, 可以选择0-7测试哪个编译成功</param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:ArrayExtend.Random``1(``0[])">
            <summary>
            随机一个值,在数组0-count范围内
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:ArrayExtend.Deserialize``1(System.Byte[],System.Int32,System.Int32)">
            <summary>
            反序列化数据(使用ProtoBuf反序列化)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:FPExtend.ToFloat(System.Single,System.Single)">
            <summary>
            定点数, 默认只保留浮点数最好4位
            </summary>
            <param name="self"></param>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:FPExtend.ToVector3(UnityEngine.Vector3,System.Single)">
            <summary>
            定点数, 默认只保留浮点数最好4位
            </summary>
            <param name="self"></param>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:FPExtend.ToVector3Int(UnityEngine.Vector3)">
            <summary>
            定点数, 默认只保留浮点数最好4位
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:FPExtend.FPTranslate(UnityEngine.Transform,UnityEngine.Vector3,System.Single)">
            <summary>
            定点平移
            </summary>
            <param name="self"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="num"></param>
        </member>
        <member name="M:FPExtend.FPTranslate(UnityEngine.Transform,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            定点平移
            </summary>
            <param name="self"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="num"></param>
        </member>
        <member name="M:FPExtend.FPRotate(UnityEngine.Transform,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            定点转向
            </summary>
            <param name="self"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="num"></param>
        </member>
        <member name="M:OtherExtend.Multiply(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            向量相乘
            </summary>
            <param name="self"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Fleck.QueuedStream">
            <summary>
            Wraps a stream and queues multiple write operations.
            Useful for wrapping SslStream as it does not support multiple simultaneous write operations.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Bson.BsonObjectId">
            <summary>
            Represents a BSON Oid (object id).
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Bson.BsonObjectId.Value">
            <summary>
            Gets or sets the value of the Oid.
            </summary>
            <value>The value of the Oid.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonObjectId.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> class.
            </summary>
            <param name="value">The Oid value.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Bson.BsonReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized BSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Bson.BsonReader.JsonNet35BinaryCompatibility">
            <summary>
            Gets or sets a value indicating whether binary data reading should be compatible with incorrect Json.NET 3.5 written binary.
            </summary>
            <value>
            	<c>true</c> if binary data reading will be compatible with incorrect Json.NET 3.5 written binary; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Bson.BsonReader.ReadRootValueAsArray">
            <summary>
            Gets or sets a value indicating whether the root object will be read as a JSON array.
            </summary>
            <value>
            	<c>true</c> if the root object will be read as a JSON array; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Bson.BsonReader.DateTimeKindHandling">
            <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.
            </summary>
            <value>The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream" /> containing the BSON data to read.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
            <param name="reader">The <see cref="T:System.IO.BinaryReader" /> containing the BSON data to read.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonReader.#ctor(System.IO.Stream,System.Boolean,System.DateTimeKind)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream" /> containing the BSON data to read.</param>
            <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
            <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader,System.Boolean,System.DateTimeKind)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
            <param name="reader">The <see cref="T:System.IO.BinaryReader" /> containing the BSON data to read.</param>
            <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
            <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonReader.Read">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.Stream" />.
            </summary>
            <returns>
            <c>true</c> if the next token was read successfully; <c>false</c> if there are no more tokens to read.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonReader.Close">
            <summary>
            Changes the reader's state to <see cref="F:Newtonsoft.Json.JsonReader.State.Closed" />.
            If <see cref="P:Newtonsoft.Json.JsonReader.CloseInput" /> is set to <c>true</c>, the underlying <see cref="T:System.IO.Stream" /> is also closed.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Bson.BsonWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating BSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Bson.BsonWriter.DateTimeKindHandling">
            <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.
            When set to <see cref="F:System.DateTimeKind.Unspecified" /> no conversion will occur.
            </summary>
            <value>The <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter" /> class.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream" /> to write to.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.#ctor(System.IO.BinaryWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter" /> class.
            </summary>
            <param name="writer">The <see cref="T:System.IO.BinaryWriter" /> to write to.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying <see cref="T:System.IO.Stream" /> and also flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteEnd(Newtonsoft_X.Json.JsonToken)">
            <summary>
            Writes the end.
            </summary>
            <param name="token">The token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteComment(System.String)">
            <summary>
            Writes a comment <c>/*...*/</c> containing the specified text.
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteRawValue(System.String)">
            <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteStartArray">
            <summary>
            Writes the beginning of a JSON array.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteStartObject">
            <summary>
            Writes the beginning of a JSON object.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.Close">
            <summary>
            Closes this writer.
            If <see cref="P:Newtonsoft.Json.JsonWriter.CloseOutput" /> is set to <c>true</c>, the underlying <see cref="T:System.IO.Stream" /> is also closed.
            If <see cref="P:Newtonsoft.Json.JsonWriter.AutoCompleteOnClose" /> is set to <c>true</c>, the JSON is auto-completed.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
            <param name="value">The <see cref="T:System.String" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Single" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Double" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Char" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte" />[] value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" />[] value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteObjectId(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte" />[] value that represents a BSON object id.
            </summary>
            <param name="value">The Object ID value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Bson.BsonWriter.WriteRegex(System.String,System.String)">
            <summary>
            Writes a BSON regex.
            </summary>
            <param name="pattern">The regex pattern.</param>
            <param name="options">The regex options.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.ConstructorHandling">
            <summary>
            Specifies how constructors are used when initializing objects during deserialization by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ConstructorHandling.Default">
            <summary>
            First attempt to use the public default constructor, then fall back to a single parameterized constructor, then to the non-public default constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ConstructorHandling.AllowNonPublicDefaultConstructor">
            <summary>
            Json.NET will use a non-public default constructor before falling back to a parameterized constructor.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.BinaryConverter">
            <summary>
            Converts a binary value to and from a base 64 string value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.BinaryConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.BinaryConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.BinaryConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.BsonObjectIdConverter">
            <summary>
            Converts a <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> to and from JSON and BSON.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.BsonObjectIdConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.BsonObjectIdConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.BsonObjectIdConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.CustomCreationConverter`1">
            <summary>
            Creates a custom object.
            </summary>
            <typeparam name="T">The object type to convert.</typeparam>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.CustomCreationConverter`1.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.CustomCreationConverter`1.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.CustomCreationConverter`1.Create(System.Type)">
            <summary>
            Creates an object which will then be populated by the serializer.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>The created object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.CustomCreationConverter`1.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Converters.CustomCreationConverter`1.CanWrite">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
            <value>
            	<c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.DateTimeConverterBase">
            <summary>
            Provides a base class for converting a <see cref="T:System.DateTime" /> to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.DateTimeConverterBase.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.IsoDateTimeConverter">
            <summary>
            Converts a <see cref="T:System.DateTime" /> to and from the ISO 8601 date format (e.g. <c>"2008-04-12T12:53Z"</c>).
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Converters.IsoDateTimeConverter.DateTimeStyles">
            <summary>
            Gets or sets the date time styles used when converting a date to and from JSON.
            </summary>
            <value>The date time styles used when converting a date to and from JSON.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Converters.IsoDateTimeConverter.DateTimeFormat">
            <summary>
            Gets or sets the date time format used when converting a date to and from JSON.
            </summary>
            <value>The date time format used when converting a date to and from JSON.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Converters.IsoDateTimeConverter.Culture">
            <summary>
            Gets or sets the culture used when converting a date to and from JSON.
            </summary>
            <value>The culture used when converting a date to and from JSON.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.IsoDateTimeConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.IsoDateTimeConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.JavaScriptDateTimeConverter">
            <summary>
            Converts a <see cref="T:System.DateTime" /> to and from a JavaScript <c>Date</c> constructor (e.g. <c>new Date(52231943)</c>).
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.JavaScriptDateTimeConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.JavaScriptDateTimeConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing property value of the JSON that is being converted.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.KeyValuePairConverter">
            <summary>
            Converts a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.KeyValuePairConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.KeyValuePairConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.KeyValuePairConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.RegexConverter">
            <summary>
            Converts a <see cref="T:System.Text.RegularExpressions.Regex" /> to and from JSON and BSON.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.RegexConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.RegexConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.RegexConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.StringEnumConverter">
            <summary>
            Converts an <see cref="T:System.Enum" /> to and from its name string value.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Converters.StringEnumConverter.CamelCaseText">
            <summary>
            Gets or sets a value indicating whether the written enum text should be camel case.
            The default value is <c>false</c>.
            </summary>
            <value><c>true</c> if the written enum text will be camel case; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Converters.StringEnumConverter.AllowIntegerValues">
            <summary>
            Gets or sets a value indicating whether integer values are allowed when serializing and deserializing.
            The default value is <c>true</c>.
            </summary>
            <value><c>true</c> if integers are allowed when serializing and deserializing; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.StringEnumConverter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Converters.StringEnumConverter" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.StringEnumConverter.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Converters.StringEnumConverter" /> class.
            </summary>
            <param name="camelCaseText"><c>true</c> if the written enum text will be camel case; otherwise, <c>false</c>.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.StringEnumConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.StringEnumConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.StringEnumConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Converters.VersionConverter">
            <summary>
            Converts a <see cref="T:System.Version" /> to and from a string (e.g. <c>"1.2.3.4"</c>).
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.VersionConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.VersionConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing property value of the JSON that is being converted.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Converters.VersionConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.DateFormatHandling">
            <summary>
            Specifies how dates are formatted when writing JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateFormatHandling.IsoDateFormat">
            <summary>
            Dates are written in the ISO 8601 format, e.g. <c>"2012-03-21T05:40Z"</c>.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateFormatHandling.MicrosoftDateFormat">
            <summary>
            Dates are written in the Microsoft JSON format, e.g. <c>"\/Date(1198908717056)\/"</c>.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.DateParseHandling">
            <summary>
            Specifies how date formatted strings, e.g. <c>"\/Date(1198908717056)\/"</c> and <c>"2012-03-21T05:40Z"</c>, are parsed when reading JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateParseHandling.None">
            <summary>
            Date formatted strings are not parsed to a date type and are read as strings.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateParseHandling.DateTime">
            <summary>
            Date formatted strings, e.g. <c>"\/Date(1198908717056)\/"</c> and <c>"2012-03-21T05:40Z"</c>, are parsed to <see cref="T:System.DateTime" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateParseHandling.DateTimeOffset">
            <summary>
            Date formatted strings, e.g. <c>"\/Date(1198908717056)\/"</c> and <c>"2012-03-21T05:40Z"</c>, are parsed to <see cref="T:System.DateTimeOffset" />.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.DateTimeZoneHandling">
            <summary>
            Specifies how to treat the time value when converting between string and <see cref="T:System.DateTime" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateTimeZoneHandling.Local">
            <summary>
            Treat as local time. If the <see cref="T:System.DateTime" /> object represents a Coordinated Universal Time (UTC), it is converted to the local time.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateTimeZoneHandling.Utc">
            <summary>
            Treat as a UTC. If the <see cref="T:System.DateTime" /> object represents a local time, it is converted to a UTC.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateTimeZoneHandling.Unspecified">
            <summary>
            Treat as a local time if a <see cref="T:System.DateTime" /> is being converted to a string.
            If a string is being converted to <see cref="T:System.DateTime" />, convert to a local time if a time zone is specified.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DateTimeZoneHandling.RoundtripKind">
            <summary>
            Time zone information should be preserved when converting.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.DefaultValueHandling">
            <summary>
            Specifies default value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingObject" title="DefaultValueHandling Class" />
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingExample" title="DefaultValueHandling Ignore Example" />
            </example>
        </member>
        <member name="F:Newtonsoft_X.Json.DefaultValueHandling.Include">
            <summary>
            Include members where the member value is the same as the member's default value when serializing objects.
            Included members are written to JSON. Has no effect when deserializing.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DefaultValueHandling.Ignore">
            <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            so that it is not written to JSON.
            This option will ignore all default values (e.g. <c>null</c> for objects and nullable types; <c>0</c> for integers,
            decimals and floating point numbers; and <c>false</c> for booleans). The default value ignored can be changed by
            placing the <see cref="T:System.ComponentModel.DefaultValueAttribute" /> on the property.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DefaultValueHandling.Populate">
            <summary>
            Members with a default value but no JSON will be set to their default value when deserializing.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.DefaultValueHandling.IgnoreAndPopulate">
            <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            and set members to their default value when deserializing.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.FloatFormatHandling">
            <summary>
            Specifies float format handling options when writing special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" /> with <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.FloatFormatHandling.String">
            <summary>
            Write special floating point values as strings in JSON, e.g. <c>"NaN"</c>, <c>"Infinity"</c>, <c>"-Infinity"</c>.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.FloatFormatHandling.Symbol">
            <summary>
            Write special floating point values as symbols in JSON, e.g. <c>NaN</c>, <c>Infinity</c>, <c>-Infinity</c>.
            Note that this will produce non-valid JSON.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.FloatFormatHandling.DefaultValue">
            <summary>
            Write special floating point values as the property's default value in JSON, e.g. 0.0 for a <see cref="T:System.Double" /> property, <c>null</c> for a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" /> property.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.FloatParseHandling">
            <summary>
            Specifies how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.FloatParseHandling.Double">
            <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Double" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.FloatParseHandling.Decimal">
            <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Decimal" />.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Formatting">
            <summary>
            Specifies formatting options for the <see cref="T:Newtonsoft.Json.JsonTextWriter" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Formatting.None">
            <summary>
            No special formatting is applied. This is the default.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Formatting.Indented">
            <summary>
            Causes child objects to be indented according to the <see cref="P:Newtonsoft.Json.JsonTextWriter.Indentation" /> and <see cref="P:Newtonsoft.Json.JsonTextWriter.IndentChar" /> settings.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.IArrayPool`1">
            <summary>
            Provides an interface for using pooled arrays.
            </summary>
            <typeparam name="T">The array type content.</typeparam>
        </member>
        <member name="M:Newtonsoft_X.Json.IArrayPool`1.Rent(System.Int32)">
            <summary>
            Rent an array from the pool. This array must be returned when it is no longer needed.
            </summary>
            <param name="minimumLength">The minimum required length of the array. The returned array may be longer.</param>
            <returns>The rented array from the pool. This array must be returned when it is no longer needed.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.IArrayPool`1.Return(`0[])">
            <summary>
            Return an array to the pool.
            </summary>
            <param name="array">The array that is being returned.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.IJsonLineInfo">
            <summary>
            Provides an interface to enable a class to return line and position information.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.IJsonLineInfo.HasLineInfo">
            <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
            <returns>
            	<c>true</c> if <see cref="P:Newtonsoft.Json.IJsonLineInfo.LineNumber" /> and <see cref="P:Newtonsoft.Json.IJsonLineInfo.LinePosition" /> can be provided; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.IJsonLineInfo.LineNumber">
            <summary>
            Gets the current line number.
            </summary>
            <value>The current line number or 0 if no line information is available (for example, when <see cref="M:Newtonsoft.Json.IJsonLineInfo.HasLineInfo" /> returns <c>false</c>).</value>
        </member>
        <member name="P:Newtonsoft_X.Json.IJsonLineInfo.LinePosition">
            <summary>
            Gets the current line position.
            </summary>
            <value>The current line position or 0 if no line information is available (for example, when <see cref="M:Newtonsoft.Json.IJsonLineInfo.HasLineInfo" /> returns <c>false</c>).</value>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonArrayAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the collection.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonArrayAttribute.AllowNullItems">
            <summary>
            Gets or sets a value indicating whether null items are allowed in the collection.
            </summary>
            <value><c>true</c> if null items are allowed in the collection; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonArrayAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonArrayAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with a flag indicating whether the array can contain null items.
            </summary>
            <param name="allowNullItems">A flag indicating whether the array can contain null items.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonArrayAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonConstructorAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to use the specified constructor when deserializing that object.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonContainerAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.Id">
            <summary>
            Gets or sets the id.
            </summary>
            <value>The id.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.Title">
            <summary>
            Gets or sets the title.
            </summary>
            <value>The title.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.Description">
            <summary>
            Gets or sets the description.
            </summary>
            <value>The description.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.ItemConverterType">
            <summary>
            Gets or sets the collection's items converter.
            </summary>
            <value>The collection's items converter.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.ItemConverterParameters">
            <summary>
            The parameter list to use when constructing the <see cref="T:Newtonsoft.Json.JsonConverter" /> described by <see cref="P:Newtonsoft.Json.JsonContainerAttribute.ItemConverterType" />.
            If <c>null</c>, the default constructor is used.
            When non-<c>null</c>, there must be a constructor defined in the <see cref="T:Newtonsoft.Json.JsonConverter" /> that exactly matches the number,
            order, and type of these parameters.
            </summary>
            <example>
            <code>
            [JsonContainer(ItemConverterType = typeof(MyContainerConverter), ItemConverterParameters = new object[] { 123, "Four" })]
            </code>
            </example>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.NamingStrategyType">
            <summary>
            Gets or sets the <see cref="T:System.Type" /> of the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" />.
            </summary>
            <value>The <see cref="T:System.Type" /> of the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" />.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.NamingStrategyParameters">
            <summary>
            The parameter list to use when constructing the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" /> described by <see cref="P:Newtonsoft.Json.JsonContainerAttribute.NamingStrategyType" />.
            If <c>null</c>, the default constructor is used.
            When non-<c>null</c>, there must be a constructor defined in the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" /> that exactly matches the number,
            order, and type of these parameters.
            </summary>
            <example>
            <code>
            [JsonContainer(NamingStrategyType = typeof(MyNamingStrategy), NamingStrategyParameters = new object[] { 123, "Four" })]
            </code>
            </example>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.IsReference">
            <summary>
            Gets or sets a value that indicates whether to preserve object references.
            </summary>
            <value>
            	<c>true</c> to keep object reference; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.ItemIsReference">
            <summary>
            Gets or sets a value that indicates whether to preserve collection's items references.
            </summary>
            <value>
            	<c>true</c> to keep collection's items object references; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the reference loop handling used when serializing the collection's items.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonContainerAttribute.ItemTypeNameHandling">
            <summary>
            Gets or sets the type name handling used when serializing the collection's items.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonContainerAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonContainerAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonConvert">
            <summary>
            Provides methods for converting between .NET types and JSON types.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="SerializeObject" title="Serializing and Deserializing JSON with JsonConvert" />
            </example>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonConvert.DefaultSettings">
            <summary>
            Gets or sets a function that creates default <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            Default settings are automatically used by serialization methods on <see cref="T:Newtonsoft.Json.JsonConvert" />,
            and <see cref="M:Newtonsoft.Json.Linq.JToken.ToObject``1" /> and <see cref="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)" /> on <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            To serialize without using any default settings create a <see cref="T:Newtonsoft.Json.JsonSerializer" /> with
            <see cref="M:Newtonsoft.Json.JsonSerializer.Create" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.DateTime)">
            <summary>
            Converts the <see cref="T:System.DateTime" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTime" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.DateTime,Newtonsoft_X.Json.DateFormatHandling,Newtonsoft_X.Json.DateTimeZoneHandling)">
            <summary>
            Converts the <see cref="T:System.DateTime" /> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling" /> specified.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="format">The format the date will be converted to.</param>
            <param name="timeZoneHandling">The time zone handling when the date is converted to a string.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTime" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.DateTimeOffset)">
            <summary>
            Converts the <see cref="T:System.DateTimeOffset" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.DateTimeOffset,Newtonsoft_X.Json.DateFormatHandling)">
            <summary>
            Converts the <see cref="T:System.DateTimeOffset" /> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling" /> specified.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="format">The format the date will be converted to.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Boolean)">
            <summary>
            Converts the <see cref="T:System.Boolean" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Boolean" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Char)">
            <summary>
            Converts the <see cref="T:System.Char" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Char" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Enum)">
            <summary>
            Converts the <see cref="T:System.Enum" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Enum" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Int32)">
            <summary>
            Converts the <see cref="T:System.Int32" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Int32" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Int16)">
            <summary>
            Converts the <see cref="T:System.Int16" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Int16" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.UInt16)">
            <summary>
            Converts the <see cref="T:System.UInt16" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.UInt16" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.UInt32)">
            <summary>
            Converts the <see cref="T:System.UInt32" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.UInt32" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Int64)">
            <summary>
            Converts the <see cref="T:System.Int64" />  to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Int64" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.UInt64)">
            <summary>
            Converts the <see cref="T:System.UInt64" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.UInt64" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Single)">
            <summary>
            Converts the <see cref="T:System.Single" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Single" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Double)">
            <summary>
            Converts the <see cref="T:System.Double" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Double" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Byte)">
            <summary>
            Converts the <see cref="T:System.Byte" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Byte" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.SByte)">
            <summary>
            Converts the <see cref="T:System.SByte" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.SByte" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Decimal)">
            <summary>
            Converts the <see cref="T:System.Decimal" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Decimal" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Guid)">
            <summary>
            Converts the <see cref="T:System.Guid" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Guid" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.TimeSpan)">
            <summary>
            Converts the <see cref="T:System.TimeSpan" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.TimeSpan" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Uri)">
            <summary>
            Converts the <see cref="T:System.Uri" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Uri" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.String)">
            <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.String,System.Char)">
            <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="delimiter">The string delimiter character.</param>
            <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.String,System.Char,Newtonsoft_X.Json.StringEscapeHandling)">
            <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="delimiter">The string delimiter character.</param>
            <param name="stringEscapeHandling">The string escape handling.</param>
            <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.ToString(System.Object)">
            <summary>
            Converts the <see cref="T:System.Object" /> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Object" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object)">
            <summary>
            Serializes the specified object to a JSON string.
            </summary>
            <param name="value">The object to serialize.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft_X.Json.Formatting)">
            <summary>
            Serializes the specified object to a JSON string using formatting.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output should be formatted.</param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Serializes the specified object to a JSON string using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="converters">A collection of converters used while serializing.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft_X.Json.Formatting,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Serializes the specified object to a JSON string using formatting and a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output should be formatted.</param>
            <param name="converters">A collection of converters used while serializing.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is <c>null</c>, default serialization settings will be used.</param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is <c>null</c>, default serialization settings will be used.</param>
            <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is <see cref="F:Newtonsoft.Json.TypeNameHandling.Auto" /> to write out the type name if the type of the value does not match.
            Specifying the type is optional.
            </param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft_X.Json.Formatting,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output should be formatted.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is <c>null</c>, default serialization settings will be used.</param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft_X.Json.Formatting,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output should be formatted.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is <c>null</c>, default serialization settings will be used.</param>
            <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is <see cref="F:Newtonsoft.Json.TypeNameHandling.Auto" /> to write out the type name if the type of the value does not match.
            Specifying the type is optional.
            </param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject(System.String)">
            <summary>
            Deserializes the JSON to a .NET object.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject(System.String,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to a .NET object using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is <c>null</c>, default serialization settings will be used.
            </param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject(System.String,System.Type)">
            <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="type">The <see cref="T:System.Type" /> of object being deserialized.</param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject``1(System.String)">
            <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
            <typeparam name="T">The type of the object to deserialize to.</typeparam>
            <param name="value">The JSON to deserialize.</param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0)">
            <summary>
            Deserializes the JSON to the given anonymous type.
            </summary>
            <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be inferred from the anonymous type passed
            as a parameter.
            </typeparam>
            <param name="value">The JSON to deserialize.</param>
            <param name="anonymousTypeObject">The anonymous type object.</param>
            <returns>The deserialized anonymous type from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to the given anonymous type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be inferred from the anonymous type passed
            as a parameter.
            </typeparam>
            <param name="value">The JSON to deserialize.</param>
            <param name="anonymousTypeObject">The anonymous type object.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is <c>null</c>, default serialization settings will be used.
            </param>
            <returns>The deserialized anonymous type from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
            <typeparam name="T">The type of the object to deserialize to.</typeparam>
            <param name="value">The JSON to deserialize.</param>
            <param name="converters">Converters to use while deserializing.</param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <typeparam name="T">The type of the object to deserialize to.</typeparam>
            <param name="value">The object to deserialize.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is <c>null</c>, default serialization settings will be used.
            </param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="type">The type of the object to deserialize.</param>
            <param name="converters">Converters to use while deserializing.</param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="type">The type of the object to deserialize to.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is <c>null</c>, default serialization settings will be used.
            </param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.PopulateObject(System.String,System.Object)">
            <summary>
            Populates the object with values from the JSON string.
            </summary>
            <param name="value">The JSON to populate values from.</param>
            <param name="target">The target object to populate values onto.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConvert.PopulateObject(System.String,System.Object,Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Populates the object with values from the JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="value">The JSON to populate values from.</param>
            <param name="target">The target object to populate values onto.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is <c>null</c>, default serialization settings will be used.
            </param>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonConvert.True">
            <summary>
            Represents JavaScript's boolean value <c>true</c> as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonConvert.False">
            <summary>
            Represents JavaScript's boolean value <c>false</c> as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonConvert.Null">
            <summary>
            Represents JavaScript's <c>null</c> as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonConvert.Undefined">
            <summary>
            Represents JavaScript's <c>undefined</c> as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonConvert.PositiveInfinity">
            <summary>
            Represents JavaScript's positive infinity as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonConvert.NegativeInfinity">
            <summary>
            Represents JavaScript's negative infinity as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonConvert.NaN">
            <summary>
            Represents JavaScript's <c>NaN</c> as a string. This field is read-only.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonConverter">
            <summary>
            Converts an object to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConverter.WriteJson(Newtonsoft_X.Json.JsonWriter,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConverter.ReadJson(Newtonsoft_X.Json.JsonReader,System.Type,System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonConverter.CanRead">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON.
            </summary>
            <value><c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonConverter.CanWrite">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
            <value><c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonConverterAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to use the specified <see cref="T:Newtonsoft.Json.JsonConverter" /> when serializing the member or class.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonConverterAttribute.ConverterType">
            <summary>
            Gets the <see cref="T:System.Type" /> of the <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
            <value>The <see cref="T:System.Type" /> of the <see cref="T:Newtonsoft.Json.JsonConverter" />.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonConverterAttribute.ConverterParameters">
            <summary>
            The parameter list to use when constructing the <see cref="T:Newtonsoft.Json.JsonConverter" /> described by <see cref="P:Newtonsoft.Json.JsonConverterAttribute.ConverterType" />.
            If <c>null</c>, the default constructor is used.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConverterAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonConverterAttribute" /> class.
            </summary>
            <param name="converterType">Type of the <see cref="T:Newtonsoft.Json.JsonConverter" />.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonConverterAttribute.#ctor(System.Type,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonConverterAttribute" /> class.
            </summary>
            <param name="converterType">Type of the <see cref="T:Newtonsoft.Json.JsonConverter" />.</param>
            <param name="converterParameters">Parameter list to use when constructing the <see cref="T:Newtonsoft.Json.JsonConverter" />. Can be <c>null</c>.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonConverterCollection">
            <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonDictionaryAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the collection.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonDictionaryAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonDictionaryAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute" /> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonException">
            <summary>
            The exception thrown when an error occurs during JSON serialization or deserialization.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or <c>null</c> if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is <c>null</c>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <c>null</c> or <see cref="P:System.Exception.HResult" /> is zero (0).</exception>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonExtensionDataAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to deserialize properties with no matching class member into the specified collection
            and write values during serialization.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonExtensionDataAttribute.WriteData">
            <summary>
            Gets or sets a value that indicates whether to write extension data when serializing the object.
            </summary>
            <value>
            	<c>true</c> to write extension data when serializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonExtensionDataAttribute.ReadData">
            <summary>
            Gets or sets a value that indicates whether to read extension data when deserializing the object.
            </summary>
            <value>
            	<c>true</c> to read extension data when deserializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonExtensionDataAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonExtensionDataAttribute" /> class.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonIgnoreAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> not to serialize the public field or public read/write property value.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonObjectAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonObjectAttribute.MemberSerialization">
            <summary>
            Gets or sets the member serialization.
            </summary>
            <value>The member serialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonObjectAttribute.ItemRequired">
            <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
            <value>
            	A value indicating whether the object's properties are required.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonObjectAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonObjectAttribute.#ctor(Newtonsoft_X.Json.MemberSerialization)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified member serialization.
            </summary>
            <param name="memberSerialization">The member serialization.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonObjectAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonPropertyAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to always serialize the member with the specified name.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.ItemConverterType">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.JsonConverter" /> type used when serializing the property's collection items.
            </summary>
            <value>The collection's items <see cref="T:Newtonsoft.Json.JsonConverter" /> type.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.ItemConverterParameters">
            <summary>
            The parameter list to use when constructing the <see cref="T:Newtonsoft.Json.JsonConverter" /> described by <see cref="P:Newtonsoft.Json.JsonPropertyAttribute.ItemConverterType" />.
            If <c>null</c>, the default constructor is used.
            When non-<c>null</c>, there must be a constructor defined in the <see cref="T:Newtonsoft.Json.JsonConverter" /> that exactly matches the number,
            order, and type of these parameters.
            </summary>
            <example>
            <code>
            [JsonProperty(ItemConverterType = typeof(MyContainerConverter), ItemConverterParameters = new object[] { 123, "Four" })]
            </code>
            </example>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.NamingStrategyType">
            <summary>
            Gets or sets the <see cref="T:System.Type" /> of the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" />.
            </summary>
            <value>The <see cref="T:System.Type" /> of the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" />.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.NamingStrategyParameters">
            <summary>
            The parameter list to use when constructing the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" /> described by <see cref="P:Newtonsoft.Json.JsonPropertyAttribute.NamingStrategyType" />.
            If <c>null</c>, the default constructor is used.
            When non-<c>null</c>, there must be a constructor defined in the <see cref="T:Newtonsoft.Json.Serialization.NamingStrategy" /> that exactly matches the number,
            order, and type of these parameters.
            </summary>
            <example>
            <code>
            [JsonProperty(NamingStrategyType = typeof(MyNamingStrategy), NamingStrategyParameters = new object[] { 123, "Four" })]
            </code>
            </example>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.NullValueHandling">
            <summary>
            Gets or sets the null value handling used when serializing this property.
            </summary>
            <value>The null value handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.DefaultValueHandling">
            <summary>
            Gets or sets the default value handling used when serializing this property.
            </summary>
            <value>The default value handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.ReferenceLoopHandling">
            <summary>
            Gets or sets the reference loop handling used when serializing this property.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.ObjectCreationHandling">
            <summary>
            Gets or sets the object creation handling used when deserializing this property.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.TypeNameHandling">
            <summary>
            Gets or sets the type name handling used when serializing this property.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.IsReference">
            <summary>
            Gets or sets whether this property's value is serialized as a reference.
            </summary>
            <value>Whether this property's value is serialized as a reference.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.Order">
            <summary>
            Gets or sets the order of serialization of a member.
            </summary>
            <value>The numeric order of serialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.Required">
            <summary>
            Gets or sets a value indicating whether this property is required.
            </summary>
            <value>
            	A value indicating whether this property is required.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.PropertyName">
            <summary>
            Gets or sets the name of the property.
            </summary>
            <value>The name of the property.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the reference loop handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.ItemTypeNameHandling">
            <summary>
            Gets or sets the type name handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items type name handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonPropertyAttribute.ItemIsReference">
            <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
            <value>Whether this property's collection items are serialized as a reference.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonPropertyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonPropertyAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class with the specified name.
            </summary>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized JSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.CurrentState">
            <summary>
            Gets the current reader state.
            </summary>
            <value>The current reader state.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.CloseInput">
            <summary>
            Gets or sets a value indicating whether the source should be closed when this reader is closed.
            </summary>
            <value>
            <c>true</c> to close the source when this reader is closed; otherwise <c>false</c>. The default is <c>true</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.SupportMultipleContent">
            <summary>
            Gets or sets a value indicating whether multiple pieces of JSON content can
            be read from a continuous stream without erroring.
            </summary>
            <value>
            <c>true</c> to support reading multiple pieces of JSON content; otherwise <c>false</c>.
            The default is <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.QuoteChar">
            <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.DateTimeZoneHandling">
            <summary>
            Gets or sets how <see cref="T:System.DateTime" /> time zones are handled when reading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.DateParseHandling">
            <summary>
            Gets or sets how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.FloatParseHandling">
            <summary>
            Gets or sets how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.DateFormatString">
            <summary>
            Gets or sets how custom date formatted strings are parsed when reading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.MaxDepth">
            <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.TokenType">
            <summary>
            Gets the type of the current JSON token. 
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.Value">
            <summary>
            Gets the text value of the current JSON token.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.ValueType">
            <summary>
            Gets the .NET type for the current JSON token.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.Depth">
            <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
            <value>The depth of the current token in the JSON document.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.Path">
            <summary>
            Gets the path of the current JSON token. 
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReader.Culture">
            <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.Read">
            <summary>
            Reads the next JSON token from the source.
            </summary>
            <returns><c>true</c> if the next token was read successfully; <c>false</c> if there are no more tokens to read.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsString">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.String" />.
            </summary>
            <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Byte" />[].
            </summary>
            <returns>A <see cref="T:System.Byte" />[] or <c>null</c> if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsDouble">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsBoolean">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.Skip">
            <summary>
            Skips the children of the current token.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.SetToken(Newtonsoft_X.Json.JsonToken)">
            <summary>
            Sets the current token.
            </summary>
            <param name="newToken">The new token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.SetToken(Newtonsoft_X.Json.JsonToken,System.Object)">
            <summary>
            Sets the current token and value.
            </summary>
            <param name="newToken">The new token.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.SetToken(Newtonsoft_X.Json.JsonToken,System.Object,System.Boolean)">
            <summary>
            Sets the current token and value.
            </summary>
            <param name="newToken">The new token.</param>
            <param name="value">The value.</param>
            <param name="updateIndex">A flag indicating whether the position index inside an array should be updated.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.SetStateBasedOnCurrent">
            <summary>
            Sets the state based on current token type.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReader.Close">
            <summary>
            Changes the reader's state to <see cref="F:Newtonsoft.Json.JsonReader.State.Closed" />.
            If <see cref="P:Newtonsoft.Json.JsonReader.CloseInput" /> is set to <c>true</c>, the source is also closed.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonReader.State">
            <summary>
            Specifies the state of the reader.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Start">
            <summary>
            A <see cref="T:Newtonsoft.Json.JsonReader" /> read method has not been called.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Complete">
            <summary>
            The end of the file has been reached successfully.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Property">
            <summary>
            Reader is at a property.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.ObjectStart">
            <summary>
            Reader is at the start of an object.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Object">
            <summary>
            Reader is in an object.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.ArrayStart">
            <summary>
            Reader is at the start of an array.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Array">
            <summary>
            Reader is in an array.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Closed">
            <summary>
            The <see cref="M:Newtonsoft.Json.JsonReader.Close" /> method has been called.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.PostValue">
            <summary>
            Reader has just read a value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.ConstructorStart">
            <summary>
            Reader is at the start of a constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Constructor">
            <summary>
            Reader is in a constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Error">
            <summary>
            An error occurred that prevents the read operation from continuing.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonReader.State.Finished">
            <summary>
            The end of the file has been reached successfully.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonReaderException">
            <summary>
            The exception thrown when an error occurs while reading JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReaderException.LineNumber">
            <summary>
            Gets the line number indicating where the error occurred.
            </summary>
            <value>The line number indicating where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReaderException.LinePosition">
            <summary>
            Gets the line position indicating where the error occurred.
            </summary>
            <value>The line position indicating where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonReaderException.Path">
            <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
            <value>The path to the JSON where the error occurred.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReaderException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReaderException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReaderException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or <c>null</c> if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is <c>null</c>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <c>null</c> or <see cref="P:System.Exception.HResult" /> is zero (0).</exception>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonRequiredAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to always serialize the member, and to require that the member has a value.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonSerializationException">
            <summary>
            The exception thrown when an error occurs during JSON serialization or deserialization.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or <c>null</c> if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is <c>null</c>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <c>null</c> or <see cref="P:System.Exception.HResult" /> is zero (0).</exception>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonSerializer">
            <summary>
            Serializes and deserializes objects into and from the JSON format.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> enables you to control how objects are encoded into JSON.
            </summary>
        </member>
        <member name="E:Newtonsoft_X.Json.JsonSerializer.Error">
            <summary>
            Occurs when the <see cref="T:Newtonsoft.Json.JsonSerializer" /> errors during serialization and deserialization.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.ReferenceResolver">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.Binder">
            <summary>
            Gets or sets the <see cref="P:Newtonsoft.Json.JsonSerializer.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.TraceWriter">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter" /> used by the serializer when writing trace messages.
            </summary>
            <value>The trace writer.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.EqualityComparer">
            <summary>
            Gets or sets the equality comparer used by the serializer when comparing references.
            </summary>
            <value>The equality comparer.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.TypeNameHandling">
            <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            The default value is <see cref="F:Newtonsoft.Json.TypeNameHandling.None" />.
            </summary>
            <remarks>
            <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> should be used with caution when your application deserializes JSON from an external source.
            Incoming types should be validated with a custom <see cref="P:Newtonsoft.Json.JsonSerializer.SerializationBinder" />
            when deserializing with a value other than <see cref="F:Newtonsoft.Json.TypeNameHandling.None" />.
            </remarks>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.TypeNameAssemblyFormat">
            <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            The default value is <see cref="F:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple" />.
            </summary>
            <value>The type name assembly format.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.PreserveReferencesHandling">
            <summary>
            Gets or sets how object references are preserved by the serializer.
            The default value is <see cref="F:Newtonsoft.Json.PreserveReferencesHandling.None" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.ReferenceLoopHandling">
            <summary>
            Gets or sets how reference loops (e.g. a class referencing itself) is handled.
            The default value is <see cref="F:Newtonsoft.Json.ReferenceLoopHandling.Error" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.MissingMemberHandling">
            <summary>
            Gets or sets how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.MissingMemberHandling.Ignore" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.NullValueHandling">
            <summary>
            Gets or sets how null values are handled during serialization and deserialization.
            The default value is <see cref="F:Newtonsoft.Json.NullValueHandling.Include" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.DefaultValueHandling">
            <summary>
            Gets or sets how default values are handled during serialization and deserialization.
            The default value is <see cref="F:Newtonsoft.Json.DefaultValueHandling.Include" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.ObjectCreationHandling">
            <summary>
            Gets or sets how objects are created during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.ObjectCreationHandling.Auto" />.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.ConstructorHandling">
            <summary>
            Gets or sets how constructors are used during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.ConstructorHandling.Default" />.
            </summary>
            <value>The constructor handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.MetadataPropertyHandling">
            <summary>
            Gets or sets how metadata properties are used during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.MetadataPropertyHandling.Default" />.
            </summary>
            <value>The metadata properties handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.Converters">
            <summary>
            Gets a collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.
            </summary>
            <value>Collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.ContractResolver">
            <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.Context">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
            <value>The context.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.Formatting">
            <summary>
            Indicates how JSON text output is formatted.
            The default value is <see cref="F:Newtonsoft.Json.Formatting.None" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.DateFormatHandling">
            <summary>
            Gets or sets how dates are written to JSON text.
            The default value is <see cref="F:Newtonsoft.Json.DateFormatHandling.IsoDateFormat" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.DateTimeZoneHandling">
            <summary>
            Gets or sets how <see cref="T:System.DateTime" /> time zones are handled during serialization and deserialization.
            The default value is <see cref="F:Newtonsoft.Json.DateTimeZoneHandling.RoundtripKind" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.DateParseHandling">
            <summary>
            Gets or sets how date formatted strings, e.g. <c>"\/Date(1198908717056)\/"</c> and <c>"2012-03-21T05:40Z"</c>, are parsed when reading JSON.
            The default value is <see cref="F:Newtonsoft.Json.DateParseHandling.DateTime" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.FloatParseHandling">
            <summary>
            Gets or sets how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            The default value is <see cref="F:Newtonsoft.Json.FloatParseHandling.Double" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.FloatFormatHandling">
            <summary>
            Gets or sets how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written as JSON text.
            The default value is <see cref="F:Newtonsoft.Json.FloatFormatHandling.String" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.StringEscapeHandling">
            <summary>
            Gets or sets how strings are escaped when writing JSON text.
            The default value is <see cref="F:Newtonsoft.Json.StringEscapeHandling.Default" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.DateFormatString">
            <summary>
            Gets or sets how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatted when writing JSON text,
            and the expected date format when reading JSON text.
            The default value is <c>"yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK"</c>.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.Culture">
            <summary>
            Gets or sets the culture used when reading JSON.
            The default value is <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.MaxDepth">
            <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            A null value means there is no maximum.
            The default value is <c>null</c>.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializer.CheckAdditionalContent">
            <summary>
            Gets a value indicating whether there will be a check for additional JSON content after deserializing an object.
            The default value is <c>false</c>.
            </summary>
            <value>
            	<c>true</c> if there will be a check for additional JSON content after deserializing an object; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializer" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Create">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" />.
            </summary>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" />.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Create(Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" />.
            </summary>
            <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer" />.</param>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" />.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.CreateDefault">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" />.
            </summary>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" />.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.CreateDefault(Newtonsoft_X.Json.JsonSerializerSettings)">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" /> as well as the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
            <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer" />.</param>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings 
            from <see cref="P:Newtonsoft.Json.JsonConvert.DefaultSettings" /> as well as the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Populate(System.IO.TextReader,System.Object)">
            <summary>
            Populates the JSON values onto the target object.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader" /> that contains the JSON structure to read values from.</param>
            <param name="target">The target object to populate values onto.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Populate(Newtonsoft_X.Json.JsonReader,System.Object)">
            <summary>
            Populates the JSON values onto the target object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to read values from.</param>
            <param name="target">The target object to populate values onto.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Deserialize(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Deserializes the JSON structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to deserialize.</param>
            <returns>The <see cref="T:System.Object" /> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Deserialize(System.IO.TextReader,System.Type)">
            <summary>
            Deserializes the JSON structure contained by the specified <see cref="T:System.IO.TextReader" />
            into an instance of the specified type.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader" /> containing the object.</param>
            <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
            <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Deserialize``1(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Deserializes the JSON structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
            <typeparam name="T">The type of the object to deserialize.</typeparam>
            <returns>The instance of <typeparamref name="T" /> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Deserialize(Newtonsoft_X.Json.JsonReader,System.Type)">
            <summary>
            Deserializes the JSON structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
            <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
            <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object)">
            <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the JSON structure
            using the specified <see cref="T:System.IO.TextWriter" />.
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> used to write the JSON structure.</param>
            <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Serialize(Newtonsoft_X.Json.JsonWriter,System.Object,System.Type)">
            <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the JSON structure
            using the specified <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter" /> used to write the JSON structure.</param>
            <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
            <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is <see cref="F:Newtonsoft.Json.TypeNameHandling.Auto" /> to write out the type name if the type of the value does not match.
            Specifying the type is optional.
            </param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object,System.Type)">
            <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the JSON structure
            using the specified <see cref="T:System.IO.TextWriter" />.
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> used to write the JSON structure.</param>
            <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
            <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifying the type is optional.
            </param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializer.Serialize(Newtonsoft_X.Json.JsonWriter,System.Object)">
            <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the JSON structure
            using the specified <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter" /> used to write the JSON structure.</param>
            <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonSerializerSettings">
            <summary>
            Specifies the settings on a <see cref="T:Newtonsoft.Json.JsonSerializer" /> object.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.ReferenceLoopHandling">
            <summary>
            Gets or sets how reference loops (e.g. a class referencing itself) are handled.
            The default value is <see cref="F:Newtonsoft.Json.ReferenceLoopHandling.Error" />.
            </summary>
            <value>Reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.MissingMemberHandling">
            <summary>
            Gets or sets how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.MissingMemberHandling.Ignore" />.
            </summary>
            <value>Missing member handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.ObjectCreationHandling">
            <summary>
            Gets or sets how objects are created during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.ObjectCreationHandling.Auto" />.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.NullValueHandling">
            <summary>
            Gets or sets how null values are handled during serialization and deserialization.
            The default value is <see cref="F:Newtonsoft.Json.NullValueHandling.Include" />.
            </summary>
            <value>Null value handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.DefaultValueHandling">
            <summary>
            Gets or sets how default values are handled during serialization and deserialization.
            The default value is <see cref="F:Newtonsoft.Json.DefaultValueHandling.Include" />.
            </summary>
            <value>The default value handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.Converters">
            <summary>
            Gets or sets a <see cref="T:Newtonsoft.Json.JsonConverter" /> collection that will be used during serialization.
            </summary>
            <value>The converters.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.PreserveReferencesHandling">
            <summary>
            Gets or sets how object references are preserved by the serializer.
            The default value is <see cref="F:Newtonsoft.Json.PreserveReferencesHandling.None" />.
            </summary>
            <value>The preserve references handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.TypeNameHandling">
            <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            The default value is <see cref="F:Newtonsoft.Json.TypeNameHandling.None" />.
            </summary>
            <remarks>
            <see cref="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameHandling" /> should be used with caution when your application deserializes JSON from an external source.
            Incoming types should be validated with a custom <see cref="P:Newtonsoft.Json.JsonSerializerSettings.SerializationBinder" />
            when deserializing with a value other than <see cref="F:Newtonsoft.Json.TypeNameHandling.None" />.
            </remarks>
            <value>The type name handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.MetadataPropertyHandling">
            <summary>
            Gets or sets how metadata properties are used during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.MetadataPropertyHandling.Default" />.
            </summary>
            <value>The metadata properties handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.TypeNameAssemblyFormat">
            <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            The default value is <see cref="F:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple" />.
            </summary>
            <value>The type name assembly format.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.ConstructorHandling">
            <summary>
            Gets or sets how constructors are used during deserialization.
            The default value is <see cref="F:Newtonsoft.Json.ConstructorHandling.Default" />.
            </summary>
            <value>The constructor handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.ContractResolver">
            <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
            <value>The contract resolver.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.EqualityComparer">
            <summary>
            Gets or sets the equality comparer used by the serializer when comparing references.
            </summary>
            <value>The equality comparer.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.ReferenceResolver">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
            <value>The reference resolver.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.ReferenceResolverProvider">
            <summary>
            Gets or sets a function that creates the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
            <value>A function that creates the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.TraceWriter">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter" /> used by the serializer when writing trace messages.
            </summary>
            <value>The trace writer.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.Binder">
            <summary>
            Gets or sets the <see cref="P:Newtonsoft.Json.JsonSerializerSettings.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
            <value>The binder.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.Error">
            <summary>
            Gets or sets the error handler called during serialization and deserialization.
            </summary>
            <value>The error handler called during serialization and deserialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.Context">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
            <value>The context.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.DateFormatString">
            <summary>
            Gets or sets how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatted when writing JSON text,
            and the expected date format when reading JSON text.
            The default value is <c>"yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK"</c>.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.MaxDepth">
            <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            A null value means there is no maximum.
            The default value is <c>null</c>.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.Formatting">
            <summary>
            Indicates how JSON text output is formatted.
            The default value is <see cref="F:Newtonsoft.Json.Formatting.None" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.DateFormatHandling">
            <summary>
            Gets or sets how dates are written to JSON text.
            The default value is <see cref="F:Newtonsoft.Json.DateFormatHandling.IsoDateFormat" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.DateTimeZoneHandling">
            <summary>
            Gets or sets how <see cref="T:System.DateTime" /> time zones are handled during serialization and deserialization.
            The default value is <see cref="F:Newtonsoft.Json.DateTimeZoneHandling.RoundtripKind" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.DateParseHandling">
            <summary>
            Gets or sets how date formatted strings, e.g. <c>"\/Date(1198908717056)\/"</c> and <c>"2012-03-21T05:40Z"</c>, are parsed when reading JSON.
            The default value is <see cref="F:Newtonsoft.Json.DateParseHandling.DateTime" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.FloatFormatHandling">
            <summary>
            Gets or sets how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written as JSON.
            The default value is <see cref="F:Newtonsoft.Json.FloatFormatHandling.String" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.FloatParseHandling">
            <summary>
            Gets or sets how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            The default value is <see cref="F:Newtonsoft.Json.FloatParseHandling.Double" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.StringEscapeHandling">
            <summary>
            Gets or sets how strings are escaped when writing JSON text.
            The default value is <see cref="F:Newtonsoft.Json.StringEscapeHandling.Default" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.Culture">
            <summary>
            Gets or sets the culture used when reading JSON.
            The default value is <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonSerializerSettings.CheckAdditionalContent">
            <summary>
            Gets a value indicating whether there will be a check for additional content after deserializing an object.
            The default value is <c>false</c>.
            </summary>
            <value>
            	<c>true</c> if there will be a check for additional content after deserializing an object; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonSerializerSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> class.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonTextReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to JSON text data.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonTextReader" /> class with the specified <see cref="T:System.IO.TextReader" />.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader" /> containing the JSON data to read.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextReader.ArrayPool">
            <summary>
            Gets or sets the reader's character buffer pool.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.Read">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" />.
            </summary>
            <returns>
            <c>true</c> if the next token was read successfully; <c>false</c> if there are no more tokens to read.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsString">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.String" />.
            </summary>
            <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.Byte" />[].
            </summary>
            <returns>A <see cref="T:System.Byte" />[] or <c>null</c> if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsBoolean">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.ReadAsDouble">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:System.IO.TextReader" /> as a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" />.
            </summary>
            <returns>A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" />. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.Close">
            <summary>
            Changes the reader's state to <see cref="F:Newtonsoft.Json.JsonReader.State.Closed" />.
            If <see cref="P:Newtonsoft.Json.JsonReader.CloseInput" /> is set to <c>true</c>, the underlying <see cref="T:System.IO.TextReader" /> is also closed.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextReader.HasLineInfo">
            <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
            <returns>
            	<c>true</c> if <see cref="P:Newtonsoft.Json.JsonTextReader.LineNumber" /> and <see cref="P:Newtonsoft.Json.JsonTextReader.LinePosition" /> can be provided; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextReader.LineNumber">
            <summary>
            Gets the current line number.
            </summary>
            <value>
            The current line number or 0 if no line information is available (for example, <see cref="M:Newtonsoft.Json.JsonTextReader.HasLineInfo" /> returns <c>false</c>).
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextReader.LinePosition">
            <summary>
            Gets the current line position.
            </summary>
            <value>
            The current line position or 0 if no line information is available (for example, <see cref="M:Newtonsoft.Json.JsonTextReader.HasLineInfo" /> returns <c>false</c>).
            </value>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonTextWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating JSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextWriter.ArrayPool">
            <summary>
            Gets or sets the writer's character array pool.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextWriter.Indentation">
            <summary>
            Gets or sets how many <see cref="P:Newtonsoft.Json.JsonTextWriter.IndentChar" />s to write for each level in the hierarchy when <see cref="P:Newtonsoft.Json.JsonWriter.Formatting" /> is set to <see cref="F:Newtonsoft.Json.Formatting.Indented" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextWriter.QuoteChar">
            <summary>
            Gets or sets which character to use to quote attribute values.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextWriter.IndentChar">
            <summary>
            Gets or sets which character to use for indenting when <see cref="P:Newtonsoft.Json.JsonWriter.Formatting" /> is set to <see cref="F:Newtonsoft.Json.Formatting.Indented" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonTextWriter.QuoteName">
            <summary>
            Gets or sets a value indicating whether object names will be surrounded with quotes.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonTextWriter" /> class using the specified <see cref="T:System.IO.TextWriter" />.
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> to write to.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying <see cref="T:System.IO.TextWriter" /> and also flushes the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.Close">
            <summary>
            Closes this writer.
            If <see cref="P:Newtonsoft.Json.JsonWriter.CloseOutput" /> is set to <c>true</c>, the underlying <see cref="T:System.IO.TextWriter" /> is also closed.
            If <see cref="P:Newtonsoft.Json.JsonWriter.AutoCompleteOnClose" /> is set to <c>true</c>, the JSON is auto-completed.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteStartObject">
            <summary>
            Writes the beginning of a JSON object.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteStartArray">
            <summary>
            Writes the beginning of a JSON array.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteEnd(Newtonsoft_X.Json.JsonToken)">
            <summary>
            Writes the specified end token.
            </summary>
            <param name="token">The end token to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WritePropertyName(System.String,System.Boolean)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteIndent">
            <summary>
            Writes indent characters.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValueDelimiter">
            <summary>
            Writes the JSON value delimiter.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteIndentSpace">
            <summary>
            Writes an indent space.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
            <param name="value">The <see cref="T:System.String" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Single" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Nullable{System.Single})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Double" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Nullable{System.Double})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Char" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte" />[] value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" />[] value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteComment(System.String)">
            <summary>
            Writes a comment <c>/*...*/</c> containing the specified text. 
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonTextWriter.WriteWhitespace(System.String)">
            <summary>
            Writes the given white space.
            </summary>
            <param name="ws">The string of white space characters.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonToken">
            <summary>
            Specifies the type of JSON token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.None">
            <summary>
            This is returned by the <see cref="T:Newtonsoft.Json.JsonReader" /> if a read method has not been called.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.StartObject">
            <summary>
            An object start token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.StartArray">
            <summary>
            An array start token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.StartConstructor">
            <summary>
            A constructor start token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.PropertyName">
            <summary>
            An object property name.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Comment">
            <summary>
            A comment.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Raw">
            <summary>
            Raw JSON.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Integer">
            <summary>
            An integer.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Float">
            <summary>
            A float.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.String">
            <summary>
            A string.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Boolean">
            <summary>
            A boolean.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Null">
            <summary>
            A null token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Undefined">
            <summary>
            An undefined token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.EndObject">
            <summary>
            An object end token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.EndArray">
            <summary>
            An array end token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.EndConstructor">
            <summary>
            A constructor end token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Date">
            <summary>
            A Date.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.JsonToken.Bytes">
            <summary>
            Byte data.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating JSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.CloseOutput">
            <summary>
            Gets or sets a value indicating whether the destination should be closed when this writer is closed.
            </summary>
            <value>
            <c>true</c> to close the destination when this writer is closed; otherwise <c>false</c>. The default is <c>true</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.Top">
            <summary>
            Gets the top.
            </summary>
            <value>The top.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.WriteState">
            <summary>
            Gets the state of the writer.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.Path">
            <summary>
            Gets the path of the writer. 
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.Formatting">
            <summary>
            Gets or sets a value indicating how JSON text output should be formatted.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.DateFormatHandling">
            <summary>
            Gets or sets how dates are written to JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.DateTimeZoneHandling">
            <summary>
            Gets or sets how <see cref="T:System.DateTime" /> time zones are handled when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.StringEscapeHandling">
            <summary>
            Gets or sets how strings are escaped when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.FloatFormatHandling">
            <summary>
            Gets or sets how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written to JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.DateFormatString">
            <summary>
            Gets or sets how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatted when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriter.Culture">
            <summary>
            Gets or sets the culture used when writing JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriter" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the destination and also flushes the destination.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.Close">
            <summary>
            Closes this writer.
            If <see cref="P:Newtonsoft.Json.JsonWriter.CloseOutput" /> is set to <c>true</c>, the destination is also closed.
            If <see cref="P:Newtonsoft.Json.JsonWriter.AutoCompleteOnClose" /> is set to <c>true</c>, the JSON is auto-completed.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteStartObject">
            <summary>
            Writes the beginning of a JSON object.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteEndObject">
            <summary>
            Writes the end of a JSON object.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteStartArray">
            <summary>
            Writes the beginning of a JSON array.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteEndArray">
            <summary>
            Writes the end of an array.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteEndConstructor">
            <summary>
            Writes the end constructor.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair of a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WritePropertyName(System.String,System.Boolean)">
            <summary>
            Writes the property name of a name/value pair of a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteEnd">
            <summary>
            Writes the end of the current JSON object or array.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteToken(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader" /> token and its children.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read the token from.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteToken(Newtonsoft_X.Json.JsonReader,System.Boolean)">
            <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader" /> token.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read the token from.</param>
            <param name="writeChildren">A flag indicating whether the current token's children should be written.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteToken(Newtonsoft_X.Json.JsonToken,System.Object)">
            <summary>
            Writes the <see cref="T:Newtonsoft.Json.JsonToken" /> token and its value.
            </summary>
            <param name="token">The <see cref="T:Newtonsoft.Json.JsonToken" /> to write.</param>
            <param name="value">
            The value to write.
            A value is only required for tokens that have an associated value, e.g. the <see cref="T:System.String" /> property name for <see cref="F:Newtonsoft.Json.JsonToken.PropertyName" />.
            <c>null</c> can be passed to the method for tokens that don't have a value, e.g. <see cref="F:Newtonsoft.Json.JsonToken.StartObject" />.
            </param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteToken(Newtonsoft_X.Json.JsonToken)">
            <summary>
            Writes the <see cref="T:Newtonsoft.Json.JsonToken" /> token.
            </summary>
            <param name="token">The <see cref="T:Newtonsoft.Json.JsonToken" /> to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteEnd(Newtonsoft_X.Json.JsonToken)">
            <summary>
            Writes the specified end token.
            </summary>
            <param name="token">The end token to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteIndent">
            <summary>
            Writes indent characters.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValueDelimiter">
            <summary>
            Writes the JSON value delimiter.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteIndentSpace">
            <summary>
            Writes an indent space.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON without changing the writer's state.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteRawValue(System.String)">
            <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
            <param name="value">The <see cref="T:System.String" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Single" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Double" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Char" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Int32})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.UInt32})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Int64})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.UInt64})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Single})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Double})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Boolean})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Int16})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.UInt16})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Char})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Char" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Char" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Byte})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Byte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Byte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.SByte})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.SByte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.SByte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Decimal})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.DateTime})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.DateTimeOffset})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.Guid})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Guid" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.Guid" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Nullable{System.TimeSpan})">
            <summary>
            Writes a <see cref="T:System.Nullable`1" /> of <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1" /> of <see cref="T:System.TimeSpan" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte" />[] value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" />[] value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteComment(System.String)">
            <summary>
            Writes a comment <c>/*...*/</c> containing the specified text.
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.WriteWhitespace(System.String)">
            <summary>
            Writes the given white space.
            </summary>
            <param name="ws">The string of white space characters.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriter.SetWriteState(Newtonsoft_X.Json.JsonToken,System.Object)">
            <summary>
            Sets the state of the <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="token">The <see cref="T:Newtonsoft.Json.JsonToken" /> being written.</param>
            <param name="value">The value being written.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.JsonWriterException">
            <summary>
            The exception thrown when an error occurs while writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.JsonWriterException.Path">
            <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
            <value>The path to the JSON where the error occurred.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriterException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriterException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriterException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or <c>null</c> if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.JsonWriterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is <c>null</c>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <c>null</c> or <see cref="P:System.Exception.HResult" /> is zero (0).</exception>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.CommentHandling">
            <summary>
            Specifies how JSON comments are handled when loading JSON.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.CommentHandling.Ignore">
            <summary>
            Ignore comments.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.CommentHandling.Load">
            <summary>
            Load comments as a <see cref="T:Newtonsoft.Json.Linq.JValue" /> with type <see cref="F:Newtonsoft.Json.Linq.JTokenType.Comment" />.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.Extensions">
            <summary>
            Contains the LINQ to JSON extension methods.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Ancestors``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of tokens that contains the ancestors of every token in the source collection.
            </summary>
            <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JToken" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the ancestors of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.AncestorsAndSelf``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of tokens that contains every token in the source collection, and the ancestors of every token in the source collection.
            </summary>
            <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JToken" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains every token in the source collection, the ancestors of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Descendants``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of tokens that contains the descendants of every token in the source collection.
            </summary>
            <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JContainer" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the descendants of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.DescendantsAndSelf``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of tokens that contains every token in the source collection, and the descendants of every token in the source collection.
            </summary>
            <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JContainer" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains every token in the source collection, and the descendants of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Properties(System.Collections.Generic.IEnumerable{Newtonsoft_X.Json.Linq.JObject})">
            <summary>
            Returns a collection of child properties of every object in the source collection.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the properties of every object in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft_X.Json.Linq.JToken},System.Object)">
            <summary>
            Returns a collection of child values of every object in the source collection with the given key.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <param name="key">The token key.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every token in the source collection with the given key.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft_X.Json.Linq.JToken})">
            <summary>
            Returns a collection of child values of every object in the source collection.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft_X.Json.Linq.JToken},System.Object)">
            <summary>
            Returns a collection of converted child values of every object in the source collection with the given key.
            </summary>
            <typeparam name="U">The type to convert the values to.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <param name="key">The token key.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every token in the source collection with the given key.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft_X.Json.Linq.JToken})">
            <summary>
            Returns a collection of converted child values of every object in the source collection.
            </summary>
            <typeparam name="U">The type to convert the values to.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Value``1(System.Collections.Generic.IEnumerable{Newtonsoft_X.Json.Linq.JToken})">
            <summary>
            Converts the value.
            </summary>
            <typeparam name="U">The type to convert the value to.</typeparam>
            <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <returns>A converted value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Value``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the value.
            </summary>
            <typeparam name="T">The source collection type.</typeparam>
            <typeparam name="U">The type to convert the value to.</typeparam>
            <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <returns>A converted value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Children``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of child tokens of every array in the source collection.
            </summary>
            <typeparam name="T">The source collection type.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.Children``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of converted child tokens of every array in the source collection.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <typeparam name="U">The type to convert the values to.</typeparam>
            <typeparam name="T">The source collection type.</typeparam>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every token in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.AsJEnumerable(System.Collections.Generic.IEnumerable{Newtonsoft_X.Json.Linq.JToken})">
            <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.Extensions.AsJEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
            <typeparam name="T">The source collection type.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
            <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.IJEnumerable`1">
            <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
            <typeparam name="T">The type of token.</typeparam>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.IJEnumerable`1.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JArray">
            <summary>
            Represents a JSON array.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
            </example>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JArray.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JArray.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.#ctor(Newtonsoft_X.Json.Linq.JArray)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class from another <see cref="T:Newtonsoft.Json.Linq.JArray" /> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JArray" /> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
            <param name="content">The contents of the array.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
            <param name="content">The contents of the array.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Load(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Load(Newtonsoft_X.Json.JsonReader,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Parse(System.String)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> populated from the string that contains JSON.</returns>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
            </example>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Parse(System.String,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> populated from the string that contains JSON.</returns>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
            </example>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.FromObject(System.Object)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.FromObject(System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.WriteTo(Newtonsoft_X.Json.JsonWriter,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JArray.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JArray.Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.IndexOf(Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Determines the index of a specific item in the <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </summary>
            <param name="item">The object to locate in the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Insert(System.Int32,Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Inserts an item to the <see cref="T:Newtonsoft.Json.Linq.JArray" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is not a valid index in the <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </exception>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:Newtonsoft.Json.Linq.JArray" /> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is not a valid index in the <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </exception>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Add(Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Adds an item to the <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </summary>
            <param name="item">The object to add to the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Clear">
            <summary>
            Removes all items from the <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Contains(Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JArray" /> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <returns>
            <c>true</c> if <paramref name="item" /> is found in the <see cref="T:Newtonsoft.Json.Linq.JArray" />; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.CopyTo(Newtonsoft_X.Json.Linq.JToken[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> to an array, starting at a particular array index.
            </summary>
            <param name="array">The array.</param>
            <param name="arrayIndex">Index of the array.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JArray.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:Newtonsoft.Json.Linq.JArray" /> is read-only.
            </summary>
            <returns><c>true</c> if the <see cref="T:Newtonsoft.Json.Linq.JArray" /> is read-only; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JArray.Remove(Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </summary>
            <param name="item">The object to remove from the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
            <returns>
            <c>true</c> if <paramref name="item" /> was successfully removed from the <see cref="T:Newtonsoft.Json.Linq.JArray" />; otherwise, <c>false</c>. This method also returns <c>false</c> if <paramref name="item" /> is not found in the original <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JConstructor">
            <summary>
            Represents a JSON constructor.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JConstructor.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JConstructor.Name">
            <summary>
            Gets or sets the name of this constructor.
            </summary>
            <value>The constructor name.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JConstructor.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.#ctor(Newtonsoft_X.Json.Linq.JConstructor)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class from another <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
            <param name="name">The constructor name.</param>
            <param name="content">The contents of the constructor.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
            <param name="name">The constructor name.</param>
            <param name="content">The contents of the constructor.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name.
            </summary>
            <param name="name">The constructor name.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.WriteTo(Newtonsoft_X.Json.JsonWriter,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JConstructor.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.Load(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Loads a <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" />.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JConstructor.Load(Newtonsoft_X.Json.JsonReader,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Loads a <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" />.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JContainer">
            <summary>
            Represents a token that can contain other tokens.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JContainer.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JContainer.HasValues">
            <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
            <value>
            	<c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JContainer.First">
            <summary>
            Get the first child token of this token.
            </summary>
            <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JContainer.Last">
            <summary>
            Get the last child token of this token.
            </summary>
            <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.Children">
            <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.Values``1">
            <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
            <typeparam name="T">The type to convert the values to.</typeparam>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.Descendants">
            <summary>
            Returns a collection of the descendant tokens for this token in document order.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the descendant tokens of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.DescendantsAndSelf">
            <summary>
            Returns a collection of the tokens that contain this token, and all descendant tokens of this token, in document order.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing this token, and all the descendant tokens of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.Add(System.Object)">
            <summary>
            Adds the specified content as children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="content">The content to be added.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.AddFirst(System.Object)">
            <summary>
            Adds the specified content as the first children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="content">The content to be added.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.CreateWriter">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.JsonWriter" /> that can be used to add tokens to the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <returns>A <see cref="T:Newtonsoft.Json.JsonWriter" /> that is ready to have content written to it.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.ReplaceAll(System.Object)">
            <summary>
            Replaces the child nodes of this token with the specified content.
            </summary>
            <param name="content">The content.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.RemoveAll">
            <summary>
            Removes the child nodes from this token.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.Merge(System.Object)">
            <summary>
            Merge the specified content into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="content">The content to be merged.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JContainer.Merge(System.Object,Newtonsoft_X.Json.Linq.JsonMergeSettings)">
            <summary>
            Merge the specified content into this <see cref="T:Newtonsoft.Json.Linq.JToken" /> using <see cref="T:Newtonsoft.Json.Linq.JsonMergeSettings" />.
            </summary>
            <param name="content">The content to be merged.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonMergeSettings" /> used to merge the content.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JContainer.Count">
            <summary>
            Gets the count of child JSON tokens.
            </summary>
            <value>The count of child JSON tokens.</value>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JEnumerable`1">
            <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
            <typeparam name="T">The type of token.</typeparam>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> struct.
            </summary>
            <param name="enumerable">The enumerable.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JEnumerable`1.GetEnumerator">
            <summary>
            Returns an enumerator that can be used to iterate through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JEnumerable`1.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JEnumerable`1.Equals(Newtonsoft_X.Json.Linq.JEnumerable{`0})">
            <summary>
            Determines whether the specified <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> to compare with this instance.</param>
            <returns>
            	<c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JEnumerable`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
            	<c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JEnumerable`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JEnumerable`1.Empty">
            <summary>
            An empty collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JObject">
            <summary>
            Represents a JSON object.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
            </example>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JObject.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="E:Newtonsoft_X.Json.Linq.JObject.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.#ctor(Newtonsoft_X.Json.Linq.JObject)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class from another <see cref="T:Newtonsoft.Json.Linq.JObject" /> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JObject" /> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
            <param name="content">The contents of the object.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
            <param name="content">The contents of the object.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JObject.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Properties">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JProperty" /> of this object's properties.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JProperty" /> of this object's properties.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Property(System.String)">
            <summary>
            Gets a <see cref="T:Newtonsoft.Json.Linq.JProperty" /> with the specified name.
            </summary>
            <param name="name">The property name.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> with the specified name or <c>null</c>.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.PropertyValues">
            <summary>
            Gets a <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this object's property values.
            </summary>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this object's property values.</returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JObject.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JObject.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
            <value></value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Load(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Loads a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
            <exception cref="T:Newtonsoft.Json.JsonReaderException">
                <paramref name="reader" /> is not valid JSON.
            </exception>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Load(Newtonsoft_X.Json.JsonReader,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Loads a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
            <exception cref="T:Newtonsoft.Json.JsonReaderException">
                <paramref name="reader" /> is not valid JSON.
            </exception>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Parse(System.String)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> populated from the string that contains JSON.</returns>
            <exception cref="T:Newtonsoft.Json.JsonReaderException">
                <paramref name="json" /> is not valid JSON.
            </exception>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
            </example>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Parse(System.String,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> populated from the string that contains JSON.</returns>
            <exception cref="T:Newtonsoft.Json.JsonReaderException">
                <paramref name="json" /> is not valid JSON.
            </exception>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
            </example>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.FromObject(System.Object)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> with the values of the specified object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.FromObject(System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> with the values of the specified object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.WriteTo(Newtonsoft_X.Json.JsonWriter,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.GetValue(System.String)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.GetValue(System.String,System.StringComparison)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison" /> will be used to match a property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.TryGetValue(System.String,System.StringComparison,Newtonsoft_X.Json.Linq.JToken@)">
            <summary>
            Tries to get the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison" /> will be used to match a property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The value.</param>
            <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
            <returns><c>true</c> if a value was successfully retrieved; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Add(System.String,Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Adds the specified property name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.Remove(System.String)">
            <summary>
            Removes the property with the specified name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns><c>true</c> if item was successfully removed; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.TryGetValue(System.String,Newtonsoft_X.Json.Linq.JToken@)">
            <summary>
            Tries to get the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The value.</param>
            <returns><c>true</c> if a value was successfully retrieved; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.GetEnumerator">
            <summary>
            Returns an enumerator that can be used to iterate through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JObject.OnPropertyChanged(System.String)">
            <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanged" /> event with the provided arguments.
            </summary>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JProperty">
            <summary>
            Represents a JSON property.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JProperty.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JProperty.Name">
            <summary>
            Gets the property name.
            </summary>
            <value>The property name.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JProperty.Value">
            <summary>
            Gets or sets the property value.
            </summary>
            <value>The property value.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JProperty.#ctor(Newtonsoft_X.Json.Linq.JProperty)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class from another <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object to copy from.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JProperty.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JProperty.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
            <param name="name">The property name.</param>
            <param name="content">The property content.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JProperty.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
            <param name="name">The property name.</param>
            <param name="content">The property content.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JProperty.WriteTo(Newtonsoft_X.Json.JsonWriter,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JProperty.Load(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Loads a <see cref="T:Newtonsoft.Json.Linq.JProperty" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JProperty" />.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JProperty.Load(Newtonsoft_X.Json.JsonReader,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Loads a <see cref="T:Newtonsoft.Json.Linq.JProperty" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JProperty" />.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JPropertyDescriptor">
            <summary>
            Represents a view of a <see cref="T:Newtonsoft.Json.Linq.JProperty" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JPropertyDescriptor.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JPropertyDescriptor" /> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JPropertyDescriptor.CanResetValue(System.Object)">
            <summary>
            When overridden in a derived class, returns whether resetting an object changes its value.
            </summary>
            <returns>
            <c>true</c> if resetting the component changes its value; otherwise, <c>false</c>.
            </returns>
            <param name="component">The component to test for reset capability.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JPropertyDescriptor.GetValue(System.Object)">
            <summary>
            When overridden in a derived class, gets the current value of the property on a component.
            </summary>
            <returns>
            The value of a property for a given component.
            </returns>
            <param name="component">The component with the property for which to retrieve the value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JPropertyDescriptor.ResetValue(System.Object)">
            <summary>
            When overridden in a derived class, resets the value for this property of the component to the default value.
            </summary>
            <param name="component">The component with the property value that is to be reset to the default value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JPropertyDescriptor.SetValue(System.Object,System.Object)">
            <summary>
            When overridden in a derived class, sets the value of the component to a different value.
            </summary>
            <param name="component">The component with the property value that is to be set.</param>
            <param name="value">The new value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JPropertyDescriptor.ShouldSerializeValue(System.Object)">
            <summary>
            When overridden in a derived class, determines a value indicating whether the value of this property needs to be persisted.
            </summary>
            <returns>
            <c>true</c> if the property should be persisted; otherwise, <c>false</c>.
            </returns>
            <param name="component">The component with the property to be examined for persistence.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JPropertyDescriptor.ComponentType">
            <summary>
            When overridden in a derived class, gets the type of the component this property is bound to.
            </summary>
            <returns>
            A <see cref="T:System.Type" /> that represents the type of component this property is bound to.
            When the <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> or
            <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" />
            methods are invoked, the object specified might be an instance of this type.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JPropertyDescriptor.IsReadOnly">
            <summary>
            When overridden in a derived class, gets a value indicating whether this property is read-only.
            </summary>
            <returns>
            <c>true</c> if the property is read-only; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JPropertyDescriptor.PropertyType">
            <summary>
            When overridden in a derived class, gets the type of the property.
            </summary>
            <returns>
            A <see cref="T:System.Type" /> that represents the type of the property.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JPropertyDescriptor.NameHashCode">
            <summary>
            Gets the hash code for the name of the member.
            </summary>
            <value></value>
            <returns>
            The hash code for the name of the member.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JRaw">
            <summary>
            Represents a raw JSON string.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JRaw.#ctor(Newtonsoft_X.Json.Linq.JRaw)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class from another <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JRaw.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class.
            </summary>
            <param name="rawJson">The raw json.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JRaw.Create(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Creates an instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.
            </summary>
            <param name="reader">The reader.</param>
            <returns>An instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JsonLoadSettings">
            <summary>
            Specifies the settings used when loading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JsonLoadSettings.CommentHandling">
            <summary>
            Gets or sets how JSON comments are handled when loading JSON.
            The default value is <see cref="F:Newtonsoft.Json.Linq.CommentHandling.Ignore" />.
            </summary>
            <value>The JSON comment handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JsonLoadSettings.LineInfoHandling">
            <summary>
            Gets or sets how JSON line info is handled when loading JSON.
            The default value is <see cref="F:Newtonsoft.Json.Linq.LineInfoHandling.Load" />.
            </summary>
            <value>The JSON line info handling.</value>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JsonMergeSettings">
            <summary>
            Specifies the settings used when merging JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JsonMergeSettings.MergeArrayHandling">
            <summary>
            Gets or sets the method used when merging JSON arrays.
            </summary>
            <value>The method used when merging JSON arrays.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JsonMergeSettings.MergeNullValueHandling">
            <summary>
            Gets or sets how null value properties are merged.
            </summary>
            <value>How null value properties are merged.</value>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Represents an abstract JSON token.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.EqualityComparer">
            <summary>
            Gets a comparer that can compare two tokens for value equality.
            </summary>
            <value>A <see cref="T:Newtonsoft.Json.Linq.JTokenEqualityComparer" /> that can compare two nodes for value equality.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Parent">
            <summary>
            Gets or sets the parent.
            </summary>
            <value>The parent.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Root">
            <summary>
            Gets the root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <value>The root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.HasValues">
            <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
            <value>
            	<c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.DeepEquals(Newtonsoft_X.Json.Linq.JToken,Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Compares the values of two tokens, including the values of all descendant tokens.
            </summary>
            <param name="t1">The first <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
            <param name="t2">The second <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
            <returns><c>true</c> if the tokens are equal; otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Next">
            <summary>
            Gets the next sibling token of this node.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the next sibling token.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Previous">
            <summary>
            Gets the previous sibling token of this node.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the previous sibling token.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Path">
            <summary>
            Gets the path of the JSON token. 
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.AddAfterSelf(System.Object)">
            <summary>
            Adds the specified content immediately after this token.
            </summary>
            <param name="content">A content object that contains simple content or a collection of content objects to be added after this token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.AddBeforeSelf(System.Object)">
            <summary>
            Adds the specified content immediately before this token.
            </summary>
            <param name="content">A content object that contains simple content or a collection of content objects to be added before this token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Ancestors">
            <summary>
            Returns a collection of the ancestor tokens of this token.
            </summary>
            <returns>A collection of the ancestor tokens of this token.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.AncestorsAndSelf">
            <summary>
            Returns a collection of tokens that contain this token, and the ancestors of this token.
            </summary>
            <returns>A collection of tokens that contain this token, and the ancestors of this token.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.AfterSelf">
            <summary>
            Returns a collection of the sibling tokens after this token, in document order.
            </summary>
            <returns>A collection of the sibling tokens after this tokens, in document order.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.BeforeSelf">
            <summary>
            Returns a collection of the sibling tokens before this token, in document order.
            </summary>
            <returns>A collection of the sibling tokens before this token, in document order.</returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Value``1(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key converted to the specified type.
            </summary>
            <typeparam name="T">The type to convert the token to.</typeparam>
            <param name="key">The token key.</param>
            <returns>The converted token value.</returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.First">
            <summary>
            Get the first child token of this token.
            </summary>
            <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JToken.Last">
            <summary>
            Get the last child token of this token.
            </summary>
            <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Children">
            <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Children``1">
            <summary>
            Returns a collection of the child tokens of this token, in document order, filtered by the specified type.
            </summary>
            <typeparam name="T">The type to filter the child tokens on.</typeparam>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Values``1">
            <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
            <typeparam name="T">The type to convert the values to.</typeparam>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Remove">
            <summary>
            Removes this token from its parent.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Replace(Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Replaces this token with the specified token.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.WriteTo(Newtonsoft_X.Json.JsonWriter,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ToString">
            <summary>
            Returns the indented JSON for this token.
            </summary>
            <remarks>
            <c>ToString()</c> returns a non-JSON string value for tokens with a type of <see cref="F:Newtonsoft.Json.Linq.JTokenType.String" />.
            If you want the JSON for all token types then you should use <see cref="M:Newtonsoft.Json.Linq.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])" />.
            </remarks>
            <returns>
            The indented JSON for this token.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ToString(Newtonsoft_X.Json.Formatting,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Returns the JSON for this token using the given formatting and converters.
            </summary>
            <param name="formatting">Indicates how the output should be formatted.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" />s which will be used when writing the token.</param>
            <returns>The JSON for this token using the given formatting and converters.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Boolean">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Boolean" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.DateTimeOffset">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.DateTimeOffset" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Boolean}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Int64">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.DateTime}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.DateTimeOffset}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Decimal}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Double}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Char}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Char" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Int32">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int32" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Int16">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int16" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.UInt16">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt16" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Char">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Char" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Byte">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Byte" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.SByte">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.SByte" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Int32}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" /> .
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Int16}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int16" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.UInt16}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt16" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Byte}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Byte" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.SByte}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.SByte" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.DateTime">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Int64}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Single}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Decimal">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Decimal" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.UInt32}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt32" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.UInt64}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt64" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Double">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Double" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Single">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Single" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.String">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.String" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.UInt32">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt32" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.UInt64">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt64" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Byte[]">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Byte" />[].
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Guid">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Guid" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.Guid}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Guid" /> .
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.TimeSpan">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.TimeSpan" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Nullable{System.TimeSpan}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" /> of <see cref="T:System.TimeSpan" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Explicit(Newtonsoft_X.Json.Linq.JToken)~System.Uri">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Uri" />.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Boolean)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Boolean" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.DateTimeOffset)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.DateTimeOffset" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Byte)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Byte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Byte})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Byte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.SByte)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.SByte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.SByte})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.SByte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Boolean})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Int64)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTime})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTimeOffset})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Decimal})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Double})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Int16)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Int16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.UInt16)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.UInt16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Int32)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int32})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.DateTime)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.DateTime" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int64})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Single})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Decimal)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Decimal" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int16})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt16})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt32})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt64})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt64" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Double)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Double" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Single)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Single" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.String)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.UInt32)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.UInt32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.UInt64)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.UInt64" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Byte[])~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Byte" />[] to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Uri)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Uri" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.TimeSpan)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.TimeSpan" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.TimeSpan})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.TimeSpan" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Guid)~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Guid" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.op_Implicit(System.Nullable{System.Guid})~Newtonsoft_X.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> of <see cref="T:System.Guid" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.CreateReader">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.JsonReader" /> for this token.
            </summary>
            <returns>A <see cref="T:Newtonsoft.Json.JsonReader" /> that can be used to read this token and its descendants.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.FromObject(System.Object)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.FromObject(System.Object,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when reading the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ToObject``1">
            <summary>
            Creates an instance of the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ToObject(System.Type)">
            <summary>
            Creates an instance of the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="objectType">The object type that the token will be deserialized to.</param>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ToObject``1(Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Creates an instance of the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" /> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
            <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when creating the object.</param>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ToObject(System.Type,Newtonsoft_X.Json.JsonSerializer)">
            <summary>
            Creates an instance of the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" /> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
            <param name="objectType">The object type that the token will be deserialized to.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when creating the object.</param>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ReadFrom(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <returns>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.ReadFrom(Newtonsoft_X.Json.JsonReader,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Parse(System.String)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> populated from the string that contains JSON.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Parse(System.String,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> populated from the string that contains JSON.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Load(Newtonsoft_X.Json.JsonReader,Newtonsoft_X.Json.Linq.JsonLoadSettings)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonLoadSettings" /> used to load the JSON.
            If this is <c>null</c>, default load settings will be used.</param>
            <returns>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Load(Newtonsoft_X.Json.JsonReader)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
            <returns>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.SelectToken(System.String)">
            <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken" /> using a JSONPath expression. Selects the token that matches the object path.
            </summary>
            <param name="path">
            A <see cref="T:System.String" /> that contains a JSONPath expression.
            </param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" />, or <c>null</c>.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.SelectToken(System.String,System.Boolean)">
            <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken" /> using a JSONPath expression. Selects the token that matches the object path.
            </summary>
            <param name="path">
            A <see cref="T:System.String" /> that contains a JSONPath expression.
            </param>
            <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.SelectTokens(System.String)">
            <summary>
            Selects a collection of elements using a JSONPath expression.
            </summary>
            <param name="path">
            A <see cref="T:System.String" /> that contains a JSONPath expression.
            </param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the selected elements.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.SelectTokens(System.String,System.Boolean)">
            <summary>
            Selects a collection of elements using a JSONPath expression.
            </summary>
            <param name="path">
            A <see cref="T:System.String" /> that contains a JSONPath expression.
            </param>
            <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the selected elements.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.DeepClone">
            <summary>
            Creates a new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />. All child tokens are recursively cloned.
            </summary>
            <returns>A new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.AddAnnotation(System.Object)">
            <summary>
            Adds an object to the annotation list of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="annotation">The annotation to add.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Annotation``1">
            <summary>
            Get the first annotation object of the specified type from this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <typeparam name="T">The type of the annotation to retrieve.</typeparam>
            <returns>The first annotation object that matches the specified type, or <c>null</c> if no annotation is of the specified type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Annotation(System.Type)">
            <summary>
            Gets the first annotation object of the specified type from this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="type">The <see cref="P:Newtonsoft.Json.Linq.Type" /> of the annotation to retrieve.</param>
            <returns>The first annotation object that matches the specified type, or <c>null</c> if no annotation is of the specified type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Annotations``1">
            <summary>
            Gets a collection of annotations of the specified type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <typeparam name="T">The type of the annotations to retrieve.</typeparam>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the annotations for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.Annotations(System.Type)">
            <summary>
            Gets a collection of annotations of the specified type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="type">The <see cref="P:Newtonsoft.Json.Linq.Type" /> of the annotations to retrieve.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Object" /> that contains the annotations that match the specified type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.RemoveAnnotations``1">
            <summary>
            Removes the annotations of the specified type from this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <typeparam name="T">The type of annotations to remove.</typeparam>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JToken.RemoveAnnotations(System.Type)">
            <summary>
            Removes the annotations of the specified type from this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <param name="type">The <see cref="P:Newtonsoft.Json.Linq.Type" /> of annotations to remove.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JTokenEqualityComparer">
            <summary>
            Compares tokens to determine whether they are equal.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenEqualityComparer.Equals(Newtonsoft_X.Json.Linq.JToken,Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
            <param name="y">The second object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
            <returns>
            <c>true</c> if the specified objects are equal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenEqualityComparer.GetHashCode(Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
            <returns>A hash code for the specified object.</returns>
            <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is <c>null</c>.</exception>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JTokenReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized JSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JTokenReader.CurrentToken">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> at the reader's current position.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenReader.#ctor(Newtonsoft_X.Json.Linq.JToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenReader" /> class.
            </summary>
            <param name="token">The token to read from.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenReader.#ctor(Newtonsoft_X.Json.Linq.JToken,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenReader" /> class.
            </summary>
            <param name="token">The token to read from.</param>
            <param name="initialPath">The initial path of the token. It is prepended to the returned <see cref="P:Newtonsoft.Json.Linq.JTokenReader.Path" />.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenReader.Read">
            <summary>
            Reads the next JSON token from the underlying <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <returns>
            <c>true</c> if the next token was read successfully; <c>false</c> if there are no more tokens to read.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JTokenReader.Path">
            <summary>
            Gets the path of the current JSON token. 
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JTokenType">
            <summary>
            Specifies the type of token.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.None">
            <summary>
            No token type has been set.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Object">
            <summary>
            A JSON object.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Array">
            <summary>
            A JSON array.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Constructor">
            <summary>
            A JSON constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Property">
            <summary>
            A JSON object property.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Comment">
            <summary>
            A comment.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Integer">
            <summary>
            An integer value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Float">
            <summary>
            A float value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.String">
            <summary>
            A string value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Boolean">
            <summary>
            A boolean value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Null">
            <summary>
            A null value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Undefined">
            <summary>
            An undefined value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Date">
            <summary>
            A date value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Raw">
            <summary>
            A raw JSON value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Bytes">
            <summary>
            A collection of bytes value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Guid">
            <summary>
            A Guid value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.Uri">
            <summary>
            A Uri value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.JTokenType.TimeSpan">
            <summary>
            A TimeSpan value.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JTokenWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating JSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JTokenWriter.CurrentToken">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> at the writer's current position.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JTokenWriter.Token">
            <summary>
            Gets the token being written.
            </summary>
            <value>The token being written.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.#ctor(Newtonsoft_X.Json.Linq.JContainer)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class writing to the given <see cref="T:Newtonsoft.Json.Linq.JContainer" />.
            </summary>
            <param name="container">The container being written to.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying <see cref="T:Newtonsoft.Json.Linq.JContainer" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.Close">
            <summary>
            Closes this writer.
            If <see cref="P:Newtonsoft.Json.JsonWriter.AutoCompleteOnClose" /> is set to <c>true</c>, the JSON is auto-completed.
            </summary>
            <remarks>
            Setting <see cref="P:Newtonsoft.Json.JsonWriter.CloseOutput" /> to <c>true</c> has no additional effect, since the underlying <see cref="T:Newtonsoft.Json.Linq.JContainer" /> is a type that cannot be closed.
            </remarks>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteStartObject">
            <summary>
            Writes the beginning of a JSON object.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteStartArray">
            <summary>
            Writes the beginning of a JSON array.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteEnd(Newtonsoft_X.Json.JsonToken)">
            <summary>
            Writes the end.
            </summary>
            <param name="token">The token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will be raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteComment(System.String)">
            <summary>
            Writes a comment <c>/*...*/</c> containing the specified text.
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
            <param name="value">The <see cref="T:System.String" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Single" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Double" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Char" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte" />[] value.
            </summary>
            <param name="value">The <see cref="T:System.Byte" />[] value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JTokenWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.JValue">
            <summary>
            Represents a value in JSON (string, integer, date, etc).
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(Newtonsoft_X.Json.Linq.JValue)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class from another <see cref="T:Newtonsoft.Json.Linq.JValue" /> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JValue" /> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Char)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.DateTimeOffset)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JValue.HasValues">
            <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
            <value>
            	<c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.CreateComment(System.String)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.
            </summary>
            <param name="value">The value.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.CreateString(System.String)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.
            </summary>
            <param name="value">The value.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.CreateNull">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> null value.
            </summary>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> null value.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.CreateUndefined">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> undefined value.
            </summary>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> undefined value.</returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JValue.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Linq.JValue.Value">
            <summary>
            Gets or sets the underlying token value.
            </summary>
            <value>The underlying token value.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.WriteTo(Newtonsoft_X.Json.JsonWriter,Newtonsoft_X.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" />s which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.Equals(Newtonsoft_X.Json.Linq.JValue)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <c>false</c>.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <remarks>
            <c>ToString()</c> returns a non-JSON string value for tokens with a type of <see cref="F:Newtonsoft.Json.Linq.JTokenType.String" />.
            If you want the JSON for all token types then you should use <see cref="M:Newtonsoft.Json.Linq.JValue.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])" />.
            </remarks>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.ToString(System.String)">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.ToString(System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Linq.JValue.CompareTo(Newtonsoft_X.Json.Linq.JValue)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings:
            Value
            Meaning
            Less than zero
            This instance is less than <paramref name="obj" />.
            Zero
            This instance is equal to <paramref name="obj" />.
            Greater than zero
            This instance is greater than <paramref name="obj" />.
            </returns>
            <exception cref="T:System.ArgumentException">
            	<paramref name="obj" /> is not of the same type as this instance.
            </exception>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.LineInfoHandling">
            <summary>
            Specifies how line information is handled when loading JSON.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.LineInfoHandling.Ignore">
            <summary>
            Ignore line information.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.LineInfoHandling.Load">
            <summary>
            Load line information.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.MergeArrayHandling">
            <summary>
            Specifies how JSON arrays are merged together.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.MergeArrayHandling.Concat">
            <summary>Concatenate arrays.</summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.MergeArrayHandling.Union">
            <summary>Union arrays, skipping items that already exist.</summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.MergeArrayHandling.Replace">
            <summary>Replace all array items.</summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.MergeArrayHandling.Merge">
            <summary>Merge array items together, matched by index.</summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Linq.MergeNullValueHandling">
            <summary>
            Specifies how null value properties are merged.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.MergeNullValueHandling.Ignore">
            <summary>
            The content's null value properties will be ignored during merging.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Linq.MergeNullValueHandling.Merge">
            <summary>
            The content's null value properties will be merged.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.MemberSerialization">
            <summary>
            Specifies the member serialization options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MemberSerialization.OptOut">
            <summary>
            All public members are serialized by default. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute" /> or <see cref="T:System.NonSerializedAttribute" />.
            This is the default member serialization mode.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MemberSerialization.OptIn">
            <summary>
            Only members marked with <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> or <see cref="T:System.Runtime.Serialization.DataMemberAttribute" /> are serialized.
            This member serialization mode can also be set by marking the class with <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MemberSerialization.Fields">
            <summary>
            All public and private fields are serialized. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute" /> or <see cref="T:System.NonSerializedAttribute" />.
            This member serialization mode can also be set by marking the class with <see cref="T:System.SerializableAttribute" />
            and setting IgnoreSerializableAttribute on <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> to <c>false</c>.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.MetadataPropertyHandling">
            <summary>
            Specifies metadata property handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MetadataPropertyHandling.Default">
            <summary>
            Read metadata properties located at the start of a JSON object.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MetadataPropertyHandling.ReadAhead">
            <summary>
            Read metadata properties located anywhere in a JSON object. Note that this setting will impact performance.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MetadataPropertyHandling.Ignore">
            <summary>
            Do not try to read metadata properties.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.MissingMemberHandling">
            <summary>
            Specifies missing member handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MissingMemberHandling.Ignore">
            <summary>
            Ignore a missing member and do not attempt to deserialize it.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.MissingMemberHandling.Error">
            <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a missing member is encountered during deserialization.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.NullValueHandling">
            <summary>
            Specifies null value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingObject" title="NullValueHandling Class" />
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingExample" title="NullValueHandling Ignore Example" />
            </example>
        </member>
        <member name="F:Newtonsoft_X.Json.NullValueHandling.Include">
            <summary>
            Include null values when serializing and deserializing objects.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.NullValueHandling.Ignore">
            <summary>
            Ignore null values when serializing and deserializing objects.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.ObjectCreationHandling">
            <summary>
            Specifies how object creation is handled by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ObjectCreationHandling.Auto">
            <summary>
            Reuse existing objects, create new objects when needed.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ObjectCreationHandling.Reuse">
            <summary>
            Only reuse existing objects.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ObjectCreationHandling.Replace">
            <summary>
            Always create new objects.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.PreserveReferencesHandling">
            <summary>
            Specifies reference handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            Note that references cannot be preserved when a value is set via a non-default constructor such as types that implement <see cref="T:System.Runtime.Serialization.ISerializable" />.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="PreservingObjectReferencesOn" title="Preserve Object References" />       
            </example>
        </member>
        <member name="F:Newtonsoft_X.Json.PreserveReferencesHandling.None">
            <summary>
            Do not preserve references when serializing types.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.PreserveReferencesHandling.Objects">
            <summary>
            Preserve references when serializing into a JSON object structure.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.PreserveReferencesHandling.Arrays">
            <summary>
            Preserve references when serializing into a JSON array structure.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.PreserveReferencesHandling.All">
            <summary>
            Preserve references when serializing.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.ReferenceLoopHandling">
            <summary>
            Specifies reference loop handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ReferenceLoopHandling.Error">
            <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a loop is encountered.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ReferenceLoopHandling.Ignore">
            <summary>
            Ignore loop references and do not serialize.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.ReferenceLoopHandling.Serialize">
            <summary>
            Serialize loop references.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Required">
            <summary>
            Indicating whether a property is required.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Required.Default">
            <summary>
            The property is not required. The default state.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Required.AllowNull">
            <summary>
            The property must be defined in JSON but can be a null value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Required.Always">
            <summary>
            The property must be defined in JSON and cannot be a null value.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.Required.DisallowNull">
            <summary>
            The property is not required but it cannot be a null value.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.CamelCaseNamingStrategy">
            <summary>
            A camel case naming strategy.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.CamelCaseNamingStrategy.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.CamelCaseNamingStrategy" /> class.
            </summary>
            <param name="processDictionaryKeys">
            A flag indicating whether dictionary keys should be processed.
            </param>
            <param name="overrideSpecifiedNames">
            A flag indicating whether explicitly specified property names should be processed,
            e.g. a property name customized with a <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" />.
            </param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.CamelCaseNamingStrategy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.CamelCaseNamingStrategy" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.CamelCaseNamingStrategy.ResolvePropertyName(System.String)">
            <summary>
            Resolves the specified property name.
            </summary>
            <param name="name">The property name to resolve.</param>
            <returns>The resolved property name.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.CamelCasePropertyNamesContractResolver">
            <summary>
            Resolves member mappings for a type, camel casing property names.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.CamelCasePropertyNamesContractResolver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver" /> class.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.DefaultContractResolver">
            <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolve a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.DefaultContractResolver.DynamicCodeGeneration">
            <summary>
            Gets a value indicating whether members are being get and set using dynamic code generation.
            This value is determined by the runtime permissions available.
            </summary>
            <value>
            	<c>true</c> if using dynamic code generation; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.DefaultContractResolver.DefaultMembersSearchFlags">
            <summary>
            Gets or sets the default members search flags.
            </summary>
            <value>The default members search flags.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.DefaultContractResolver.SerializeCompilerGeneratedMembers">
            <summary>
            Gets or sets a value indicating whether compiler generated members should be serialized.
            </summary>
            <value>
            	<c>true</c> if serialized compiler generated members; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.DefaultContractResolver.IgnoreSerializableInterface">
            <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface when serializing and deserializing types.
            </summary>
            <value>
            	<c>true</c> if the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.DefaultContractResolver.IgnoreSerializableAttribute">
            <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.SerializableAttribute" /> attribute when serializing and deserializing types.
            </summary>
            <value>
            	<c>true</c> if the <see cref="T:System.SerializableAttribute" /> attribute will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.DefaultContractResolver.NamingStrategy">
            <summary>
            Gets or sets the naming strategy used to resolve how property names and dictionary keys are serialized.
            </summary>
            <value>The naming strategy used to resolve how property names and dictionary keys are serialized.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.ResolveContract(System.Type)">
            <summary>
            Resolves the contract for a given type.
            </summary>
            <param name="type">The type to resolve a contract for.</param>
            <returns>The contract for a given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.GetSerializableMembers(System.Type)">
            <summary>
            Gets the serializable members for the type.
            </summary>
            <param name="objectType">The type to get serializable members for.</param>
            <returns>The serializable members for the type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateObjectContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateConstructorParameters(System.Reflection.ConstructorInfo,Newtonsoft_X.Json.Serialization.JsonPropertyCollection)">
            <summary>
            Creates the constructor parameters.
            </summary>
            <param name="constructor">The constructor to create properties for.</param>
            <param name="memberProperties">The type's member properties.</param>
            <returns>Properties for the given <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreatePropertyFromConstructorParameter(Newtonsoft_X.Json.Serialization.JsonProperty,System.Reflection.ParameterInfo)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
            <param name="matchingMemberProperty">The matching member property.</param>
            <param name="parameterInfo">The constructor parameter.</param>
            <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.ResolveContractConverter(System.Type)">
            <summary>
            Resolves the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for the contract.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>The contract's default <see cref="T:Newtonsoft.Json.JsonConverter" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateDictionaryContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateArrayContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreatePrimitiveContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateLinqContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateISerializableContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateStringContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateContract(System.Type)">
            <summary>
            Determines which contract type is created for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateProperties(System.Type,Newtonsoft_X.Json.MemberSerialization)">
            <summary>
            Creates properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.
            </summary>
            <param name="type">The type to create properties for.</param>
            /// <param name="memberSerialization">The member serialization mode for the type.</param>
            <returns>Properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateMemberValueProvider(System.Reflection.MemberInfo)">
            <summary>
            Creates the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.
            </summary>
            <param name="member">The member.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.CreateProperty(System.Reflection.MemberInfo,Newtonsoft_X.Json.MemberSerialization)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.
            </summary>
            <param name="memberSerialization">The member's parent <see cref="T:Newtonsoft.Json.MemberSerialization" />.</param>
            <param name="member">The member to create a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for.</param>
            <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.ResolvePropertyName(System.String)">
            <summary>
            Resolves the name of the property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>Resolved name of the property.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.ResolveDictionaryKey(System.String)">
            <summary>
            Resolves the key of the dictionary. By default <see cref="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolvePropertyName(System.String)" /> is used to resolve dictionary keys.
            </summary>
            <param name="dictionaryKey">Key of the dictionary.</param>
            <returns>Resolved key of the dictionary.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultContractResolver.GetResolvedPropertyName(System.String)">
            <summary>
            Gets the resolved name of the property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>Name of the property.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.DefaultSerializationBinder">
            <summary>
            The default serialization binder used when resolving and loading classes from type names.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.DefaultSerializationBinder.BindToType(System.String,System.String)">
            <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
            <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly" /> name of the serialized object.</param>
            <param name="typeName">Specifies the <see cref="T:System.Type" /> name of the serialized object.</param>
            <returns>
            The type of the object the formatter creates a new instance of.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ErrorContext">
            <summary>
            Provides information surrounding an error.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ErrorContext.Error">
            <summary>
            Gets the error.
            </summary>
            <value>The error.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ErrorContext.OriginalObject">
            <summary>
            Gets the original object that caused the error.
            </summary>
            <value>The original object that caused the error.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ErrorContext.Member">
            <summary>
            Gets the member that caused the error.
            </summary>
            <value>The member that caused the error.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ErrorContext.Path">
            <summary>
            Gets the path of the JSON location where the error occurred.
            </summary>
            <value>The path of the JSON location where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ErrorContext.Handled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.ErrorContext" /> is handled.
            </summary>
            <value><c>true</c> if handled; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ErrorEventArgs">
            <summary>
            Provides data for the Error event.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ErrorEventArgs.CurrentObject">
            <summary>
            Gets the current object the error event is being raised against.
            </summary>
            <value>The current object the error event is being raised against.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ErrorEventArgs.ErrorContext">
            <summary>
            Gets the error context.
            </summary>
            <value>The error context.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ErrorEventArgs.#ctor(System.Object,Newtonsoft_X.Json.Serialization.ErrorContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ErrorEventArgs" /> class.
            </summary>
            <param name="currentObject">The current object.</param>
            <param name="errorContext">The error context.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ExtensionDataGetter">
            <summary>
            Gets extension data for an object during serialization.
            </summary>
            <param name="o">The object to set extension data on.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ExtensionDataSetter">
            <summary>
            Sets extension data for an object during deserialization.
            </summary>
            <param name="o">The object to set extension data on.</param>
            <param name="key">The extension data key.</param>
            <param name="value">The extension data value.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.IAttributeProvider">
            <summary>
            Provides methods to get attributes.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IAttributeProvider.GetAttributes(System.Boolean)">
            <summary>
            Returns a collection of all of the attributes, or an empty collection if there are no attributes.
            </summary>
            <param name="inherit">When <c>true</c>, look up the hierarchy chain for the inherited custom attribute.</param>
            <returns>A collection of <see cref="T:System.Attribute" />s, or an empty collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IAttributeProvider.GetAttributes(System.Type,System.Boolean)">
            <summary>
            Returns a collection of attributes, identified by type, or an empty collection if there are no attributes.
            </summary>
            <param name="attributeType">The type of the attributes.</param>
            <param name="inherit">When <c>true</c>, look up the hierarchy chain for the inherited custom attribute.</param>
            <returns>A collection of <see cref="T:System.Attribute" />s, or an empty collection.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.IContractResolver">
            <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolve a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverObject" title="IContractResolver Class" />
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverExample" title="IContractResolver Example" />
            </example>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IContractResolver.ResolveContract(System.Type)">
            <summary>
            Resolves the contract for a given type.
            </summary>
            <param name="type">The type to resolve a contract for.</param>
            <returns>The contract for a given type.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.IReferenceResolver">
            <summary>
            Used to resolve references when serializing and deserializing JSON by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IReferenceResolver.ResolveReference(System.Object,System.String)">
            <summary>
            Resolves a reference to its object.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="reference">The reference to resolve.</param>
            <returns>The object that was resolved from the reference.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IReferenceResolver.GetReference(System.Object,System.Object)">
            <summary>
            Gets the reference for the specified object.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="value">The object to get a reference for.</param>
            <returns>The reference to the object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IReferenceResolver.IsReferenced(System.Object,System.Object)">
            <summary>
            Determines whether the specified object is referenced.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="value">The object to test for a reference.</param>
            <returns>
            	<c>true</c> if the specified object is referenced; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IReferenceResolver.AddReference(System.Object,System.String,System.Object)">
            <summary>
            Adds a reference to the specified object.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="reference">The reference.</param>
            <param name="value">The object to reference.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ITraceWriter">
            <summary>
            Represents a trace writer.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.ITraceWriter.LevelFilter">
            <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <see cref="F:System.Diagnostics.TraceLevel.Info" /> will exclude <see cref="F:System.Diagnostics.TraceLevel.Verbose" /> messages and include <see cref="F:System.Diagnostics.TraceLevel.Info" />,
            <see cref="F:System.Diagnostics.TraceLevel.Warning" /> and <see cref="F:System.Diagnostics.TraceLevel.Error" /> messages.
            </summary>
            <value>The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ITraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
            <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
            <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
            <param name="message">The trace message.</param>
            <param name="ex">The trace exception. This parameter is optional.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.IValueProvider">
            <summary>
            Provides methods to get and set values.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IValueProvider.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value.
            </summary>
            <param name="target">The target to set the value on.</param>
            <param name="value">The value to set on the target.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.IValueProvider.GetValue(System.Object)">
            <summary>
            Gets the value.
            </summary>
            <param name="target">The target to get the value from.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonArrayContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonArrayContract.CollectionItemType">
            <summary>
            Gets the <see cref="T:System.Type" /> of the collection items.
            </summary>
            <value>The <see cref="T:System.Type" /> of the collection items.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonArrayContract.IsMultidimensionalArray">
            <summary>
            Gets a value indicating whether the collection type is a multidimensional array.
            </summary>
            <value><c>true</c> if the collection type is a multidimensional array; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonArrayContract.OverrideCreator">
            <summary>
            Gets or sets the function used to create the object. When set this function will override <see cref="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator" />.
            </summary>
            <value>The function used to create the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonArrayContract.HasParameterizedCreator">
            <summary>
            Gets a value indicating whether the creator has a parameter with the collection values.
            </summary>
            <value><c>true</c> if the creator has a parameter with the collection values; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonArrayContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonContainerContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContainerContract.ItemConverter">
            <summary>
            Gets or sets the default collection items <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
            <value>The converter.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContainerContract.ItemIsReference">
            <summary>
            Gets or sets a value indicating whether the collection items preserve object references.
            </summary>
            <value><c>true</c> if collection items preserve object references; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContainerContract.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the collection item reference loop handling.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContainerContract.ItemTypeNameHandling">
            <summary>
            Gets or sets the collection item type name handling.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonContainerContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonContainerContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.UnderlyingType">
            <summary>
            Gets the underlying type for the contract.
            </summary>
            <value>The underlying type for the contract.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.CreatedType">
            <summary>
            Gets or sets the type created during deserialization.
            </summary>
            <value>The type created during deserialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.IsReference">
            <summary>
            Gets or sets whether this type contract is serialized as a reference.
            </summary>
            <value>Whether this type contract is serialized as a reference.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.Converter">
            <summary>
            Gets or sets the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for this contract.
            </summary>
            <value>The converter.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.InternalConverter">
            <summary>
            Gets the internally resolved <see cref="T:Newtonsoft.Json.JsonConverter" /> for the contract's type.
            This converter is used as a fallback converter when no other converter is resolved.
            Setting <see cref="P:Newtonsoft.Json.Serialization.JsonContract.Converter" /> will always override this converter.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.OnDeserializedCallbacks">
            <summary>
            Gets or sets all methods called immediately after deserialization of the object.
            </summary>
            <value>The methods called immediately after deserialization of the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.OnDeserializingCallbacks">
            <summary>
            Gets or sets all methods called during deserialization of the object.
            </summary>
            <value>The methods called during deserialization of the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.OnSerializedCallbacks">
            <summary>
            Gets or sets all methods called after serialization of the object graph.
            </summary>
            <value>The methods called after serialization of the object graph.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.OnSerializingCallbacks">
            <summary>
            Gets or sets all methods called before serialization of the object.
            </summary>
            <value>The methods called before serialization of the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.OnErrorCallbacks">
            <summary>
            Gets or sets all method called when an error is thrown during the serialization of the object.
            </summary>
            <value>The methods called when an error is thrown during the serialization of the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.DefaultCreator">
            <summary>
            Gets or sets the default creator method used to create the object.
            </summary>
            <value>The default creator method used to create the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonContract.DefaultCreatorNonPublic">
            <summary>
            Gets or sets a value indicating whether the default creator is non-public.
            </summary>
            <value><c>true</c> if the default object creator is non-public; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonDictionaryContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonDictionaryContract.DictionaryKeyResolver">
            <summary>
            Gets or sets the dictionary key resolver.
            </summary>
            <value>The dictionary key resolver.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonDictionaryContract.DictionaryKeyType">
            <summary>
            Gets the <see cref="T:System.Type" /> of the dictionary keys.
            </summary>
            <value>The <see cref="T:System.Type" /> of the dictionary keys.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonDictionaryContract.DictionaryValueType">
            <summary>
            Gets the <see cref="T:System.Type" /> of the dictionary values.
            </summary>
            <value>The <see cref="T:System.Type" /> of the dictionary values.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonDictionaryContract.OverrideCreator">
            <summary>
            Gets or sets the function used to create the object. When set this function will override <see cref="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator" />.
            </summary>
            <value>The function used to create the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonDictionaryContract.HasParameterizedCreator">
            <summary>
            Gets a value indicating whether the creator has a parameter with the dictionary values.
            </summary>
            <value><c>true</c> if the creator has a parameter with the dictionary values; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonDictionaryContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonISerializableContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonISerializableContract.ISerializableCreator">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.ISerializable" /> object constructor.
            </summary>
            <value>The <see cref="T:System.Runtime.Serialization.ISerializable" /> object constructor.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonISerializableContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonLinqContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonLinqContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonObjectContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.MemberSerialization">
            <summary>
            Gets or sets the object member serialization.
            </summary>
            <value>The member object serialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.ItemRequired">
            <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
            <value>
            	A value indicating whether the object's properties are required.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.Properties">
            <summary>
            Gets the object's properties.
            </summary>
            <value>The object's properties.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.CreatorParameters">
            <summary>
            Gets a collection of <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> instances that define the parameters used with <see cref="P:Newtonsoft.Json.Serialization.JsonObjectContract.OverrideCreator" />.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.OverrideCreator">
            <summary>
            Gets or sets the function used to create the object. When set this function will override <see cref="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator" />.
            This function is called with a collection of arguments which are defined by the <see cref="P:Newtonsoft.Json.Serialization.JsonObjectContract.CreatorParameters" /> collection.
            </summary>
            <value>The function used to create the object.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.ExtensionDataSetter">
            <summary>
            Gets or sets the extension data setter.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.ExtensionDataGetter">
            <summary>
            Gets or sets the extension data getter.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonObjectContract.ExtensionDataValueType">
            <summary>
            Gets or sets the extension data value type.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonObjectContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonPrimitiveContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonPrimitiveContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonProperty">
            <summary>
            Maps a JSON property to a .NET member or constructor parameter.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.PropertyName">
            <summary>
            Gets or sets the name of the property.
            </summary>
            <value>The name of the property.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.DeclaringType">
            <summary>
            Gets or sets the type that declared this property.
            </summary>
            <value>The type that declared this property.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.Order">
            <summary>
            Gets or sets the order of serialization of a member.
            </summary>
            <value>The numeric order of serialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.UnderlyingName">
            <summary>
            Gets or sets the name of the underlying member or parameter.
            </summary>
            <value>The name of the underlying member or parameter.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ValueProvider">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.AttributeProvider">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IAttributeProvider" /> for this property.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Serialization.IAttributeProvider" /> for this property.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.PropertyType">
            <summary>
            Gets or sets the type of the property.
            </summary>
            <value>The type of the property.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.Converter">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.JsonConverter" /> for the property.
            If set this converter takes precedence over the contract converter for the property type.
            </summary>
            <value>The converter.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.MemberConverter">
            <summary>
            Gets or sets the member converter.
            </summary>
            <value>The member converter.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.Ignored">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is ignored.
            </summary>
            <value><c>true</c> if ignored; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.Readable">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is readable.
            </summary>
            <value><c>true</c> if readable; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.Writable">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is writable.
            </summary>
            <value><c>true</c> if writable; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.HasMemberAttribute">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> has a member attribute.
            </summary>
            <value><c>true</c> if has a member attribute; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.DefaultValue">
            <summary>
            Gets the default value.
            </summary>
            <value>The default value.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.Required">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.
            </summary>
            <value>A value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.IsReference">
            <summary>
            Gets or sets a value indicating whether this property preserves object references.
            </summary>
            <value>
            	<c>true</c> if this instance is reference; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.NullValueHandling">
            <summary>
            Gets or sets the property null value handling.
            </summary>
            <value>The null value handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.DefaultValueHandling">
            <summary>
            Gets or sets the property default value handling.
            </summary>
            <value>The default value handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ReferenceLoopHandling">
            <summary>
            Gets or sets the property reference loop handling.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ObjectCreationHandling">
            <summary>
            Gets or sets the property object creation handling.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.TypeNameHandling">
            <summary>
            Gets or sets or sets the type name handling.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ShouldSerialize">
            <summary>
            Gets or sets a predicate used to determine whether the property should be serialized.
            </summary>
            <value>A predicate used to determine whether the property should be serialized.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ShouldDeserialize">
            <summary>
            Gets or sets a predicate used to determine whether the property should be deserialized.
            </summary>
            <value>A predicate used to determine whether the property should be deserialized.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.GetIsSpecified">
            <summary>
            Gets or sets a predicate used to determine whether the property should be serialized.
            </summary>
            <value>A predicate used to determine whether the property should be serialized.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.SetIsSpecified">
            <summary>
            Gets or sets an action used to set whether the property has been deserialized.
            </summary>
            <value>An action used to set whether the property has been deserialized.</value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonProperty.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ItemConverter">
            <summary>
            Gets or sets the converter used when serializing the property's collection items.
            </summary>
            <value>The collection's items converter.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ItemIsReference">
            <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
            <value>Whether this property's collection items are serialized as a reference.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ItemTypeNameHandling">
            <summary>
            Gets or sets the type name handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items type name handling.</value>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.JsonProperty.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the reference loop handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items reference loop handling.</value>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonPropertyCollection">
            <summary>
            A collection of <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> objects.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonPropertyCollection.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPropertyCollection" /> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonPropertyCollection.GetKeyForItem(Newtonsoft_X.Json.Serialization.JsonProperty)">
            <summary>
            When implemented in a derived class, extracts the key from the specified element.
            </summary>
            <param name="item">The element from which to extract the key.</param>
            <returns>The key for the specified element.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonPropertyCollection.AddProperty(Newtonsoft_X.Json.Serialization.JsonProperty)">
            <summary>
            Adds a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            </summary>
            <param name="property">The property to add to the collection.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonPropertyCollection.GetClosestMatchProperty(System.String)">
            <summary>
            Gets the closest matching <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            First attempts to get an exact case match of <paramref name="propertyName" /> and then
            a case insensitive match.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>A matching property if found.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonPropertyCollection.GetProperty(System.String,System.StringComparison)">
            <summary>
            Gets a property by property name.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="comparisonType">Type property name string comparison.</param>
            <returns>A matching property if found.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.JsonStringContract">
            <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonStringContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.JsonTypeReflector.CreateJsonConverterInstance(System.Type,System.Object[])">
            <summary>
            Lookup and create an instance of the <see cref="T:Newtonsoft.Json.JsonConverter" /> type described by the argument.
            </summary>
            <param name="converterType">The <see cref="T:Newtonsoft.Json.JsonConverter" /> type to create.</param>
            <param name="args">Optional arguments to pass to an initializing constructor of the JsonConverter.
            If <c>null</c>, the default constructor is used.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.MemoryTraceWriter">
            <summary>
            Represents a trace writer that writes to memory. When the trace message limit is
            reached then old trace messages will be removed as new messages are added.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.MemoryTraceWriter.LevelFilter">
            <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <see cref="F:System.Diagnostics.TraceLevel.Info" /> will exclude <see cref="F:System.Diagnostics.TraceLevel.Verbose" /> messages and include <see cref="F:System.Diagnostics.TraceLevel.Info" />,
            <see cref="F:System.Diagnostics.TraceLevel.Warning" /> and <see cref="F:System.Diagnostics.TraceLevel.Error" /> messages.
            </summary>
            <value>
            The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            </value>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.MemoryTraceWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.MemoryTraceWriter" /> class.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.MemoryTraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
            <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
            <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
            <param name="message">The trace message.</param>
            <param name="ex">The trace exception. This parameter is optional.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.MemoryTraceWriter.GetTraceMessages">
            <summary>
            Returns an enumeration of the most recent trace messages.
            </summary>
            <returns>An enumeration of the most recent trace messages.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.MemoryTraceWriter.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> of the most recent trace messages.
            </summary>
            <returns>
            A <see cref="T:System.String" /> of the most recent trace messages.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.NamingStrategy">
            <summary>
            A base class for resolving how property names and dictionary keys are serialized.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.NamingStrategy.ProcessDictionaryKeys">
            <summary>
            A flag indicating whether dictionary keys should be processed.
            Defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Newtonsoft_X.Json.Serialization.NamingStrategy.OverrideSpecifiedNames">
            <summary>
            A flag indicating whether explicitly specified property names,
            e.g. a property name customized with a <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" />, should be processed.
            Defaults to <c>false</c>.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.NamingStrategy.GetPropertyName(System.String,System.Boolean)">
            <summary>
            Gets the serialized name for a given property name.
            </summary>
            <param name="name">The initial property name.</param>
            <param name="hasSpecifiedName">A flag indicating whether the property has had a name explicitly specified.</param>
            <returns>The serialized property name.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.NamingStrategy.GetDictionaryKey(System.String)">
            <summary>
            Gets the serialized key for a given dictionary key.
            </summary>
            <param name="key">The initial dictionary key.</param>
            <returns>The serialized dictionary key.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.NamingStrategy.ResolvePropertyName(System.String)">
            <summary>
            Resolves the specified property name.
            </summary>
            <param name="name">The property name to resolve.</param>
            <returns>The resolved property name.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ObjectConstructor`1">
            <summary>
            Represents a method that constructs an object.
            </summary>
            <typeparam name="T">The object type to create.</typeparam>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.OnErrorAttribute">
            <summary>
            When applied to a method, specifies that the method is called when an error occurs serializing an object.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ReflectionAttributeProvider">
            <summary>
            Provides methods to get attributes from a <see cref="T:System.Type" />, <see cref="T:System.Reflection.MemberInfo" />, <see cref="T:System.Reflection.ParameterInfo" /> or <see cref="T:System.Reflection.Assembly" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ReflectionAttributeProvider.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ReflectionAttributeProvider" /> class.
            </summary>
            <param name="attributeProvider">The instance to get attributes for. This parameter should be a <see cref="T:System.Type" />, <see cref="T:System.Reflection.MemberInfo" />, <see cref="T:System.Reflection.ParameterInfo" /> or <see cref="T:System.Reflection.Assembly" />.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ReflectionAttributeProvider.GetAttributes(System.Boolean)">
            <summary>
            Returns a collection of all of the attributes, or an empty collection if there are no attributes.
            </summary>
            <param name="inherit">When <c>true</c>, look up the hierarchy chain for the inherited custom attribute.</param>
            <returns>A collection of <see cref="T:System.Attribute" />s, or an empty collection.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ReflectionAttributeProvider.GetAttributes(System.Type,System.Boolean)">
            <summary>
            Returns a collection of attributes, identified by type, or an empty collection if there are no attributes.
            </summary>
            <param name="attributeType">The type of the attributes.</param>
            <param name="inherit">When <c>true</c>, look up the hierarchy chain for the inherited custom attribute.</param>
            <returns>A collection of <see cref="T:System.Attribute" />s, or an empty collection.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.ReflectionValueProvider">
            <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using reflection.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ReflectionValueProvider.#ctor(System.Reflection.MemberInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ReflectionValueProvider" /> class.
            </summary>
            <param name="memberInfo">The member info.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ReflectionValueProvider.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value.
            </summary>
            <param name="target">The target to set the value on.</param>
            <param name="value">The value to set on the target.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Serialization.ReflectionValueProvider.GetValue(System.Object)">
            <summary>
            Gets the value.
            </summary>
            <param name="target">The target to get the value from.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.SerializationCallback">
            <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer" /> serialization callback events.
            </summary>
            <param name="o">The object that raised the callback event.</param>
            <param name="context">The streaming context.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.Serialization.SerializationErrorCallback">
            <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer" /> serialization error callback events.
            </summary>
            <param name="o">The object that raised the callback event.</param>
            <param name="context">The streaming context.</param>
            <param name="errorContext">The error context.</param>
        </member>
        <member name="T:Newtonsoft_X.Json.StringEscapeHandling">
            <summary>
            Specifies how strings are escaped when writing JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.StringEscapeHandling.Default">
            <summary>
            Only control characters (e.g. newline) are escaped.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.StringEscapeHandling.EscapeNonAscii">
            <summary>
            All non-ASCII and control characters (e.g. newline) are escaped.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.StringEscapeHandling.EscapeHtml">
            <summary>
            HTML (&lt;, &gt;, &amp;, ', ") and control characters (e.g. newline) are escaped.
            </summary>
        </member>
        <member name="T:Newtonsoft_X.Json.TypeNameHandling">
            <summary>
            Specifies type name handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
            <remarks>
            <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> should be used with caution when your application deserializes JSON from an external source.
            Incoming types should be validated with a custom <see cref="P:Newtonsoft.Json.JsonSerializer.SerializationBinder" />
            when deserializing with a value other than <see cref="F:Newtonsoft.Json.TypeNameHandling.None" />.
            </remarks>
        </member>
        <member name="F:Newtonsoft_X.Json.TypeNameHandling.None">
            <summary>
            Do not include the .NET type name when serializing types.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.TypeNameHandling.Objects">
            <summary>
            Include the .NET type name when serializing into a JSON object structure.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.TypeNameHandling.Arrays">
            <summary>
            Include the .NET type name when serializing into a JSON array structure.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.TypeNameHandling.All">
            <summary>
            Always include the .NET type name when serializing.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.TypeNameHandling.Auto">
            <summary>
            Include the .NET type name when the type of the object being serialized is not the same as its declared type.
            Note that this doesn't include the root serialized object by default. To include the root object's type name in JSON
            you must specify a root type object with <see cref="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.JsonSerializerSettings)" />
            or <see cref="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object,System.Type)" />.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.CollectionUtils.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Determines whether the collection is <c>null</c> or empty.
            </summary>
            <param name="collection">The collection.</param>
            <returns>
            	<c>true</c> if the collection is <c>null</c> or empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.CollectionUtils.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the elements of the specified collection to the specified generic <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
            <param name="initial">The list to add to.</param>
            <param name="collection">The collection of elements to add.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ConvertUtils.ConvertOrCast(System.Object,System.Globalization.CultureInfo,System.Type)">
            <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
            <param name="initialValue">The value to convert.</param>
            <param name="culture">The culture to use when converting.</param>
            <param name="targetType">The type to convert or cast the value to.</param>
            <returns>
            The converted type. If conversion was unsuccessful, the initial value
            is returned if assignable to the target type.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ReflectionUtils.GetCollectionItemType(System.Type)">
            <summary>
            Gets the type of the typed collection's items.
            </summary>
            <param name="type">The type.</param>
            <returns>The type of the typed collection's items.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(System.Reflection.MemberInfo)">
            <summary>
            Gets the member's underlying type.
            </summary>
            <param name="member">The member.</param>
            <returns>The underlying type of the member.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether the property is an indexed property.
            </summary>
            <param name="property">The property.</param>
            <returns>
            	<c>true</c> if the property is an indexed property; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ReflectionUtils.GetMemberValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Gets the member's value on the object.
            </summary>
            <param name="member">The member.</param>
            <param name="target">The target object.</param>
            <returns>The member's value on the object.</returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ReflectionUtils.SetMemberValue(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>
            Sets the member's value on the target object.
            </summary>
            <param name="member">The member.</param>
            <param name="target">The target.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ReflectionUtils.CanReadMemberValue(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Determines whether the specified MemberInfo can be read.
            </summary>
            <param name="member">The MemberInfo to determine whether can be read.</param>
            /// <param name="nonPublic">if set to <c>true</c> then allow the member to be gotten non-publicly.</param>
            <returns>
            	<c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.ReflectionUtils.CanSetMemberValue(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
            <summary>
            Determines whether the specified MemberInfo can be set.
            </summary>
            <param name="member">The MemberInfo to determine whether can be set.</param>
            <param name="nonPublic">if set to <c>true</c> then allow the member to be set non-publicly.</param>
            <param name="canSetReadOnly">if set to <c>true</c> then allow the member to be set if read-only.</param>
            <returns>
            	<c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.Utilities.StringBuffer">
            <summary>
            Builds a string. Unlike <see cref="T:System.Text.StringBuilder" /> this class lets you reuse its internal buffer.
            </summary>
        </member>
        <member name="M:Newtonsoft_X.Json.Utilities.StringUtils.IsWhiteSpace(System.String)">
            <summary>
            Determines whether the string is all white space. Empty string will return <c>false</c>.
            </summary>
            <param name="s">The string to test whether it is all white space.</param>
            <returns>
            	<c>true</c> if the string is all white space; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft_X.Json.WriteState">
            <summary>
            Specifies the state of the <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.WriteState.Error">
            <summary>
            An exception has been thrown, which has left the <see cref="T:Newtonsoft.Json.JsonWriter" /> in an invalid state.
            You may call the <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method to put the <see cref="T:Newtonsoft.Json.JsonWriter" /> in the <c>Closed</c> state.
            Any other <see cref="T:Newtonsoft.Json.JsonWriter" /> method calls result in an <see cref="T:System.InvalidOperationException" /> being thrown.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.WriteState.Closed">
            <summary>
            The <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method has been called.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.WriteState.Object">
            <summary>
            An object is being written. 
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.WriteState.Array">
            <summary>
            An array is being written.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.WriteState.Constructor">
            <summary>
            A constructor is being written.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.WriteState.Property">
            <summary>
            A property is being written.
            </summary>
        </member>
        <member name="F:Newtonsoft_X.Json.WriteState.Start">
            <summary>
            A <see cref="T:Newtonsoft.Json.JsonWriter" /> write method has not been called.
            </summary>
        </member>
        <member name="T:ProtoBuf.BclHelpers">
            <summary>
            Provides support for common .NET types that do not have a direct representation
            in protobuf, using the definitions from bcl.proto
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.GetUninitializedObject(System.Type)">
            <summary>
            Creates a new instance of the specified type, bypassing the constructor.
            </summary>
            <param name="type">The type to create</param>
            <returns>The new instance</returns>
            <exception cref="T:System.NotSupportedException">If the platform does not support constructor-skipping</exception>
        </member>
        <member name="F:ProtoBuf.BclHelpers.TimestampEpoch">
            <summary>
            The default value for dates that are following google.protobuf.Timestamp semantics
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimeSpan(System.TimeSpan,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a TimeSpan to a protobuf stream using protobuf-net's own representation, bcl.TimeSpan
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimeSpan(ProtoBuf.ProtoReader)">
            <summary>
            Parses a TimeSpan from a protobuf stream using protobuf-net's own representation, bcl.TimeSpan
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDuration(ProtoBuf.ProtoReader)">
            <summary>
            Parses a TimeSpan from a protobuf stream using the standardized format, google.protobuf.Duration
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDuration(System.TimeSpan,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a TimeSpan to a protobuf stream using the standardized format, google.protobuf.Duration
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimestamp(ProtoBuf.ProtoReader)">
            <summary>
            Parses a DateTime from a protobuf stream using the standardized format, google.protobuf.Timestamp
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimestamp(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream using the standardized format, google.protobuf.Timestamp
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDateTime(ProtoBuf.ProtoReader)">
            <summary>
            Parses a DateTime from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTime(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream, excluding the <c>Kind</c>
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTimeWithKind(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream, including the <c>Kind</c>
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDecimal(ProtoBuf.ProtoReader)">
            <summary>
            Parses a decimal from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDecimal(System.Decimal,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a decimal to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuid(System.Guid,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuid(ProtoBuf.ProtoReader)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="T:ProtoBuf.BclHelpers.NetObjectOptions">
            <summary>
            Optional behaviours that introduce .NET-specific functionality
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.None">
            <summary>
            No special behaviour
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.UseConstructor">
            <summary>
            If false, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.LateSet">
            <summary>
            Should the object index be reserved, rather than creating an object promptly
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadNetObject(System.Object,ProtoBuf.ProtoReader,System.Int32,System.Type,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Reads an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteNetObject(System.Object,ProtoBuf.ProtoWriter,System.Int32,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Writes an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="T:ProtoBuf.BufferExtension">
            <summary>
            Provides a simple buffer-based implementation of an <see cref="T:ProtoBuf.IExtension">extension</see> object.
            </summary>
        </member>
        <member name="F:ProtoBuf.BufferPool.MaxByteArraySize">
            <remarks>
            https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element
            </remarks>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
        </member>
        <member name="M:ProtoBuf.Compiler.CompilerContext.LoadNullRef">
            <summary>
            Pushes a null reference onto the stack. Note that this should only
            be used to return a null (or set a variable to null); for null-tests
            use BranchIfTrue / BranchIfFalse.
            </summary>
        </member>
        <member name="M:ProtoBuf.Compiler.CompilerContext.UsingBlock.#ctor(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            Creates a new "using" block (equivalent) around a variable;
            the variable must exist, and note that (unlike in C#) it is
            the variables *final* value that gets disposed. If you need
            *original* disposal, copy your variable first.
            
            It is the callers responsibility to ensure that the variable's
            scope fully-encapsulates the "using"; if not, the variable
            may be re-used (and thus re-assigned) unexpectedly.
            </summary>
        </member>
        <member name="T:ProtoBuf.DataFormat">
            <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Default">
            <summary>
            Uses the default encoding for the data-type.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.ZigZag">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.TwosComplement">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.FixedSize">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Group">
            <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.WellKnown">
            <summary>
            When applied to members of types such as DateTime or TimeSpan, specifies
            that the "well known" standardized representation should be use; DateTime uses Timestamp,
            
            </summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnionObject">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnionObject.Object">
            <summary>The value typed as Object</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnionObject.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnionObject.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnionObject.Reset(ProtoBuf.DiscriminatedUnionObject@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion64">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.Reset(ProtoBuf.DiscriminatedUnion64@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion128Object">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Guid">
            <summary>The value typed as Guid</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Object">
            <summary>The value typed as Double</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Nullable{System.Guid})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.Reset(ProtoBuf.DiscriminatedUnion128Object@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion128">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Guid">
            <summary>The value typed as Guid</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Nullable{System.Guid})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.Reset(ProtoBuf.DiscriminatedUnion128@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion64Object">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Object">
            <summary>The value typed as Double</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.Reset(ProtoBuf.DiscriminatedUnion64Object@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion32">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.Reset(ProtoBuf.DiscriminatedUnion32@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion32Object">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Object">
            <summary>The value typed as Double</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.Reset(ProtoBuf.DiscriminatedUnion32Object@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="T:ProtoBuf.Extensible">
            <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
            <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
            <seealso cref="T:ProtoBuf.IExtensible"/>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(ProtoBuf.IExtension@,System.Boolean)">
            <summary>
            Provides a simple, default implementation for <see cref="T:ProtoBuf.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:ProtoBuf.IExtensible"/>.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <param name="extensionObject">The extension field to check (and possibly update).</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The type of the value to append.</typeparam>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Object@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <param name="type">The data-type of the field.</param>
            <param name="model">The model to use for configuration.</param>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="type">The data-type of the field.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="T:ProtoBuf.ExtensibleUtil">
            <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            accross classes, which isn't allowed in Silverlight)
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="T:ProtoBuf.Helpers">
            <summary>
            Not all frameworks are created equal (fx1.1 vs fx2.0,
            micro-framework, compact-framework,
            silverlight, etc). This class simply wraps up a few things that would
            otherwise make the real code unnecessarily messy, providing fallback
            implementations if necessary.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoTypeCode">
            <summary>
            Intended to be a direct map to regular TypeCode, but:
            - with missing types
            - existing on WinRT
            </summary>
        </member>
        <member name="T:ProtoBuf.IExtensible">
            <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:ProtoBuf.IExtension">extensions</see>.
            </summary>
            <remarks>Can be implemented by deriving from Extensible.</remarks>
        </member>
        <member name="M:ProtoBuf.IExtensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="T:ProtoBuf.IExtension">
            <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginAppend">
            <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
            <returns>A new stream suitable for storing data.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
            <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
            <param name="stream">The stream originally obtained by BeginAppend.</param>
            <param name="commit">True if the append operation completed successfully.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginQuery">
            <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
            <returns>A prepared stream of the unexpected fields.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndQuery(System.IO.Stream)">
            <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
            <param name="stream">The stream originally obtained by BeginQuery.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.GetLength">
            <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
            <returns>The length of the binary stream representing unexpected data.</returns>
        </member>
        <member name="T:ProtoBuf.IExtensionResettable">
            <summary>
            Provides the ability to remove all existing extension data
            </summary>
        </member>
        <member name="M:ProtoBuf.IExtensionResettable.Reset">
            <summary>
            Remove all existing extension data
            </summary>
        </member>
        <member name="T:ProtoBuf.ImplicitFields">
            <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.None">
            <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllPublic">
            <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllFields">
            <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.CallbackSet">
            <summary>
            Represents the set of serialization callbacks to be used when serializing/deserializing a type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeSerialize">
            <summary>Called before serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeDeserialize">
            <summary>Called before deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterSerialize">
            <summary>Called after serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterDeserialize">
            <summary>Called after deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.NonTrivial">
            <summary>
            True if any callback is set, else False
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.MetaType">
            <summary>
            Represents a type at runtime for use with protobuf, allowing the field mappings (etc) to be defined
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ToString">
            <summary>
            Get the name of the type being represented
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.BaseType">
            <summary>
            Gets the base-type for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IncludeSerializerMethod">
            <summary>
            When used to compile a model, should public serialization/deserialzation methods
            be included for this type?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default?
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasCallbacks">
            <summary>
            Indicates whether the current type has defined callbacks 
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasSubtypes">
            <summary>
            Indicates whether the current type has defined subtypes
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Callbacks">
            <summary>
            Returns the set of callbacks defined for this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.String,System.String,System.String,System.String)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The name of the method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The name of the method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The name of the method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The name of the method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Name">
            <summary>
            Gets or sets the name of this contract.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.String)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ThrowIfFrozen">
            <summary>
            Throws an exception if the type has been made immutable
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Type">
            <summary>
            The runtime type that the meta-type represents
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.UseConstructor">
            <summary>
            Gets or sets whether the type should use a parameterless constructor (the default),
            or whether the type should skip the constructor completely. This option is not supported
            on compact-framework.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.ConstructType">
            <summary>
            The concrete type to create when a new instance of this type is needed; this may be useful when dealing
            with dynamic proxies, or with interface-based APIs
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetSurrogate(System.Type)">
            <summary>
            Performs serialization of this type via a surrogate; all
            other serialization options are ignored and handled
            by the surrogate's configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String[])">
            <summary>
            Adds a set of members (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Object)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Int32)">
            <summary>
            Returns the ValueMember that matchs a given field number, or null if not found
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Reflection.MemberInfo)">
            <summary>
            Returns the ValueMember that matchs a given member (property/field), or null if not found
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetFields">
            <summary>
            Returns the ValueMember instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetSubtypes">
            <summary>
            Returns the SubType instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.CompileInPlace">
            <summary>
            Compiles the serializer for this type; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.EnumPassthru">
            <summary>
            Gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IgnoreListHandling">
            <summary>
            Gets or sets a value indicating that this type should NOT be treated as a list, even if it has
            familiar list-like characteristics (enumerable, add, etc)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IsGroup">
            <summary>
            Indicates whether this type should always be treated as a "group" (rather than a string-prefixed sub-message)
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.ProtoSyntax">
            <summary>
            Indiate the variant of the protobuf .proto DSL syntax to use
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.ProtoSyntax.Proto2">
            <summary>
            https://developers.google.com/protocol-buffers/docs/proto
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.ProtoSyntax.Proto3">
            <summary>
            https://developers.google.com/protocol-buffers/docs/proto3
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel">
            <summary>
            Provides protobuf serialization support for a number of types that can be defined at runtime
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault">
            <summary>
            Global default that
            enables/disables automatic tag generation based on the existing name / order
            of the defined members. See <seealso cref="P:ProtoBuf.ProtoContractAttribute.InferTagFromName"/>
            for usage and <b>important warning</b> / explanation.
            You must set the global default before attempting to serialize/deserialize any
            impacted type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddProtoContractTypesOnly">
            <summary>
            Global default that determines whether types are considered serializable
            if they have [DataContract] / [XmlType]. With this enabled, <b>ONLY</b>
            types marked as [ProtoContract] are added automatically.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.UseImplicitZeroDefaults">
            <summary>
            Global switch that enables or disables the implicit
            handling of "zero defaults"; meanning: if no other default is specified,
            it assumes bools always default to false, integers to zero, etc.
            
            If this is disabled, no such assumptions are made and only *explicit*
            default values are processed. This is enabled by default to 
            preserve similar logic to v1.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AllowParseableTypes">
            <summary>
            Global switch that determines whether types with a <c>.ToString()</c> and a <c>Parse(string)</c>
            should be serialized as strings.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.IncludeDateTimeKind">
            <summary>
            Global switch that determines whether DateTime serialization should include the <c>Kind</c> of the date/time.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.SerializeDateTimeKind">
            <summary>
            Should the <c>Kind</c> be included on date/time values?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Default">
            <summary>
            The default model, used to support ProtoBuf.Serializer
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetTypes">
            <summary>
            Returns a sequence of the Type instances that can be
            processed by this model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetSchema(System.Type,ProtoBuf.Meta.ProtoSyntax)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
            <param name="syntax">The .proto syntax to use</param>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Item(System.Type)">
            <summary>
            Obtains the MetaType associated with a given Type for the current model,
            allowing additional configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add(System.Type,System.Boolean)">
            <summary>
            Adds support for an additional type in this model, optionally
            applying inbuilt patterns. If the type is already known to the
            model, the existing type is returned **without** applying
            any additional behaviour.
            </summary>
            <remarks>Inbuilt patterns include:
            [ProtoContract]/[ProtoMember(n)]
            [DataContract]/[DataMember(Order=n)]
            [XmlType]/[XmlElement(Order=n)]
            [On{Des|S}erializ{ing|ed}]
            ShouldSerialize*/*Specified
            </remarks>
            <param name="type">The type to be supported</param>
            <param name="applyDefaultBehaviour">Whether to apply the inbuilt configuration patterns (via attributes etc), or
            just add the type with no additional configuration (the type must then be manually configured).</param>
            <returns>The MetaType representing this type, allowing
            further configuration.</returns>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoCompile">
            <summary>
            Should serializers be compiled on demand? It may be useful
            to disable this for debugging purposes.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddMissingTypes">
            <summary>
            Should support for unexpected types be added automatically?
            If false, an exception is thrown when unexpected types
            are encountered.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.ThrowIfFrozen">
            <summary>
            Verifies that the model is still open to changes; if not, an exception is thrown
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Freeze">
            <summary>
            Prevents further changes to this model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompileInPlace">
            <summary>
            Compiles the serializers individually; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile">
            <summary>
            Fully compiles the current model into a static-compiled model instance
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions">
            <summary>
            Represents configuration options for compiling a model to 
            a standalone assembly.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.SetFrameworkOptions(ProtoBuf.Meta.MetaType)">
            <summary>
            Import framework options from an existing type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkName">
            <summary>
            The TargetFrameworkAttribute FrameworkName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkDisplayName">
            <summary>
            The TargetFrameworkAttribute FrameworkDisplayName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TypeName">
            <summary>
            The name of the TypeModel class to create
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.OutputPath">
            <summary>
            The path for the new dll
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.ImageRuntimeVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.MetaDataVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.Accessibility">
            <summary>
            The acecssibility of the generated serializer
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.Accessibility">
            <summary>
            Type accessibility
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Public">
            <summary>
            Available to all callers
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Internal">
            <summary>
            Available to all callers in the same assembly, or assemblies specified via [InternalsVisibleTo(...)]
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(System.String,System.String)">
            <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <param name="name">The name of the TypeModel class to create</param>
            <param name="path">The path for the new dll</param>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions)">
            <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.MetadataTimeoutMilliseconds">
            <summary>
            The amount of time to wait if there are concurrent metadata access operations
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.LockCount">
            <summary>
            Gets how many times a model lock was taken
            </summary>
        </member>
        <member name="E:ProtoBuf.Meta.RuntimeTypeModel.LockContended">
            <summary>
            If a lock-contention is detected, this event signals the *owner* of the lock responsible for the blockage, indicating
            what caused the problem; this is only raised if the lock-owning code successfully completes.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.SetDefaultFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of any type; note that this only affect types seen by the serializer *after* setting the factory.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventArgs">
            <summary>
            Contains the stack-trace of the owning code when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.LockContentedEventArgs.OwnerStackTrace">
            <summary>
            The stack-trace of the code that owned the lock when a lock-contention scenario occurred
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventHandler">
            <summary>
            Event-type that is raised when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.SubType">
            <summary>
            Represents an inherited type in a type hierarchy.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.FieldNumber">
            <summary>
            The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.DerivedType">
            <summary>
            The sub-type to be considered.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.SubType.#ctor(System.Int32,ProtoBuf.Meta.MetaType,ProtoBuf.DataFormat)">
            <summary>
            Creates a new SubType instance.
            </summary>
            <param name="fieldNumber">The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.</param>
            <param name="derivedType">The sub-type to be considered.</param>
            <param name="format">Specific encoding style to use; in particular, Grouped can be used to avoid buffering, but is not the default.</param>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventArgs">
            <summary>
            Event arguments needed to perform type-formatting functions; this could be resolving a Type to a string suitable for serialization, or could
            be requesting a Type from a string. If no changes are made, a default implementation will be used (from the assembly-qualified names).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.Type">
            <summary>
            The type involved in this map; if this is initially null, a Type is expected to be provided for the string in FormattedName.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.FormattedName">
            <summary>
            The formatted-name involved in this map; if this is initially null, a formatted-name is expected from the type in Type.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventHandler">
            <summary>
            Delegate type used to perform type-formatting functions; the sender originates as the type-model.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel">
            <summary>
            Provides protobuf serialization support for a number of types
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeDateTimeKind">
            <summary>
            Should the <c>Kind</c> be included on date/time values?
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type,System.Boolean)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TrySerializeAuxiliaryType(ProtoBuf.ProtoWriter,System.Type,ProtoBuf.DataFormat,System.Int32,System.Object,System.Boolean,System.Object)">
            <summary>
            This is the more "complete" version of Serialize, which handles single instances of mapped types.
            The value is written as a complete field, including field-header and (for sub-objects) a
            length-prefix
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IEnumerable sequences of any type handled by TrySerializeAuxiliaryType
             
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination writer to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,System.Int32@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,System.Int64@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int64)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int64,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(ProtoBuf.ProtoReader,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer reader to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The reader to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TryDeserializeAuxiliaryType(ProtoBuf.ProtoReader,ProtoBuf.DataFormat,System.Int32,System.Type,System.Object@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Object)">
            <summary>
            This is the more "complete" version of Deserialize, which handles single instances of mapped types.
            The value is read as a complete field, including field-header and (for sub-objects) a
            length-prefix..kmc  
            
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IList sets of any type handled by TryDeserializeAuxiliaryType
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Create">
            <summary>
            Creates a new runtime model, to which the caller
            can add support for a range of types. A model
            can be used "as is", or can be compiled for
            optimal performance.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ResolveProxies(System.Type)">
            <summary>
            Applies common proxy scenarios, resolving the actual type to consider
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsDefined(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKey(System.Type@)">
            <summary>
            Provides the key that represents a given type in the current model.
            The type is also normalized for proxies at the same time.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel.CallbackType">
            <summary>
            Indicates the type of callback to be used
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeSerialize">
            <summary>
            Invoked before an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterSerialize">
            <summary>
            Invoked after an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeDeserialize">
            <summary>
            Invoked before an object is deserialized (or when a new instance is created)
            </summary>            
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterDeserialize">
            <summary>
            Invoked after an object is deserialized
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype(System.Type,System.Type)">
            <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedType(System.Type)">
            <summary>
            Indicates that the given type was not expected, and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowCannotCreateInstance(System.Type)">
            <summary>
            Indicates that the given type cannot be constructed; it may still be possible to 
            deserialize into existing instances.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeContractType(System.Type)">
            <summary>
            Returns true if the type supplied is either a recognised contract type,
            or a *list* of a recognised contract type. 
            </summary>
            <remarks>Note that primitives always return false, even though the engine
            will, if forced, try to serialize such</remarks>
            <returns>True if this type is recognised as a serializable entity, else false</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerialize(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            a recognised contract type, or a *list* of a basic / contract type. 
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeBasicType(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            or a *list* of a basic type with inbuilt handling
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSchema(System.Type)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSchema(System.Type,ProtoBuf.Meta.ProtoSyntax)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
            <param name="syntax">The .proto syntax to use for the operation</param>
        </member>
        <member name="E:ProtoBuf.Meta.TypeModel.DynamicTypeFormatting">
            <summary>
            Used to provide custom services for writing and parsing type names when using dynamic types. Both parsing and formatting
            are provided on a single API as it is essential that both are mapped identically at all times.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CreateFormatter(System.Type)">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
            <param name="type">The type of object to be [de]deserialized by the formatter.</param>
        </member>
        <member name="P:ProtoBuf.Meta.TypeModel.ForwardsOnly">
            <summary>
            If true, buffering of nested objects is disabled
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.ValueMember">
            <summary>
            Represents a member (property/field) that is mapped to a protobuf field
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.FieldNumber">
            <summary>
            The number that identifies this member in a protobuf stream
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Member">
            <summary>
            Gets the member (field/property) which this member relates to.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.BackingMember">
            <summary>
            Gets the backing member (field/property) which this member relates to
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ItemType">
            <summary>
            Within a list / array / etc, the type of object for each item in the list (especially useful with ArrayList)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MemberType">
            <summary>
            The underlying type of the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultType">
            <summary>
            For abstract types (IList etc), the type of concrete object to create (if required)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ParentType">
            <summary>
            The type the defines the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultValue">
            <summary>
            The default value of the item (members with this value will not be serialized)
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Type,System.Int32,System.Reflection.MemberInfo,System.Type,System.Type,System.Type,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Int32,System.Type,System.Type,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DataFormat">
            <summary>
            Specifies the rules used to process the field; this is used to determine the most appropriate
            wite-type, but also to describe subtypes <i>within</i> that wire-type (such as SignedVariant)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsStrict">
            <summary>
            Indicates whether this field should follow strict encoding rules; this means (for example) that if a "fixed32"
            is encountered when "variant" is defined, then it will fail (throw an exception) when parsing. Note that
            when serializing the defined type is always used.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsPacked">
            <summary>
            Indicates whether this field should use packed encoding (which can save lots of space for repeated primitive values).
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsRequired">
            <summary>
            Indicates whether this field is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsMap">
            <summary>
            Indicates that the member should be treated as a protobuf Map
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MapKeyFormat">
            <summary>
            Specifies the data-format that should be used for the key, when IsMap is enabled
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MapValueFormat">
            <summary>
            Specifies the data-format that should be used for the value, when IsMap is enabled
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.SetSpecified(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Specifies methods for working with optional data members.
            </summary>
            <param name="getSpecified">Provides a method (null for none) to query whether this member should
            be serialized; it must be of the form "bool {Method}()". The member is only serialized if the
            method returns true.</param>
            <param name="setSpecified">Provides a method (null for none) to indicate that a member was
            deserialized; it must be of the form "void {Method}(bool)", and will be called with "true"
            when data is found.</param>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Name">
            <summary>
            Gets the logical name for this member in the schema (this is not critical for binary serialization, but may be used
            when inferring a schema).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.SupportNull">
            <summary>
            Should lists have extended support for null values? Note this makes the serialization less efficient.
            </summary>
        </member>
        <member name="T:ProtoBuf.PrefixStyle">
            <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.None">
            <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Base128">
            <summary>
            A base-128 length prefix is applied to the data (efficient for short messages).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32">
            <summary>
            A fixed-length (little-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32BigEndian">
            <summary>
            A fixed-length (big-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoContractAttribute">
            <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.Name">
            <summary>
            Gets or sets the defined name of the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFirstTag">
            <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.UseProtoMembersOnly">
            <summary>
            If specified, alternative contract markers (such as markers for XmlSerailizer or DataContractSerializer) are ignored.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.IgnoreListHandling">
            <summary>
            If specified, do NOT treat this type as a list, even if it looks like one.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFields">
            <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromName">
            <summary>
            Enables/disables automatic tag generation based on the existing name / order
            of the defined members. This option is not used for members marked
            with ProtoMemberAttribute, as intended to provide compatibility with
            WCF serialization. WARNING: when adding new fields you must take
            care to increase the Order for new elements, otherwise data corruption
            may occur.
            </summary>
            <remarks>If not explicitly specified, the default is assumed from Serializer.GlobalOptions.InferTagFromName.</remarks>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromNameHasValue">
            <summary>
            Has a InferTagFromName value been explicitly set? if not, the default from the type-model is assumed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.DataMemberOffset">
            <summary>
            Specifies an offset to apply to [DataMember(Order=...)] markers;
            this is useful when working with mex-generated classes that have
            a different origin (usually 1 vs 0) than the original data-contract.
            
            This value is added to the Order of each member.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.SkipConstructor">
            <summary>
            If true, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default? Please also see the implications of this,
            as recorded on ProtoMemberAttribute.AsReference
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.IsGroup">
            <summary>
            Indicates whether this type should always be treated as a "group" (rather than a string-prefixed sub-message)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.EnumPassthru">
            <summary>
            Applies only to enums (not to DTO classes themselves); gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.EnumPassthruHasValue">
            <summary>
            Has a EnumPassthru value been explicitly set?
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoConverterAttribute">
            <summary>
            Indicates that a static member should be considered the same as though
            were an implicit / explicit conversion operator; in particular, this
            is useful for conversions that operator syntax does not allow, such as
            to/from interface types.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoEnumAttribute">
            <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Value">
            <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoEnumAttribute.HasValue">
            <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
            <returns>true if a specific value is set</returns>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Name">
            <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoException">
            <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String,System.Exception)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialIgnoreAttribute.#ctor(System.String)">
            <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
            <param name="memberName">Specifies the member to be ignored.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialIgnoreAttribute.MemberName">
            <summary>
            The name of the member to be ignored.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoIncludeAttribute">
            <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
            <summary>
             Creates a new instance of the ProtoIncludeAttribute.
             </summary>
             <param name="tag">The unique index (within the type) that will identify this data.</param>
             <param name="knownType">The additional type to serialize/deserialize.</param>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
            <param name="tag">The unique index (within the type) that will identify this data.</param>
            <param name="knownTypeName">The additional type to serialize/deserialize.</param>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.Tag">
            <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownTypeName">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownType">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.DataFormat">
            <summary>
            Specifies whether the inherited sype's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoMapAttribute">
            <summary>
            Controls the formatting of elements in a dictionary, and indicates that
            "map" rules should be used: duplicates *replace* earlier values, rather
            than throwing an exception
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMapAttribute.KeyFormat">
            <summary>
            Describes the data-format used to store the key
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMapAttribute.ValueFormat">
            <summary>
            Describes the data-format used to store the value
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMapAttribute.DisableMap">
            <summary>
            Disables "map" handling; dictionaries will use ".Add(key,value)" instead of  "[key] = value",
            which means duplicate keys will cause an exception (instead of retaining the final value); if
            a proto schema is emitted, it will be produced using "repeated" instead of "map"
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(System.Object)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(ProtoBuf.ProtoMemberAttribute)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.#ctor(System.Int32)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Name">
            <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DataFormat">
            <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Tag">
            <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsRequired">
            <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsPacked">
            <summary>
            Gets a value indicating whether this member is packed.
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Options">
            <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
        </member>
        <member name="T:ProtoBuf.MemberSerializationOptions">
            <summary>
            Additional (optional) settings that control serialization of members
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.None">
            <summary>
            Default; no additional options
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Packed">
            <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Required">
            <summary>
            Indicates that the given item is required
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReferenceHasValue">
            <summary>
            Determines whether the types AsReferenceDefault value is used, or whether this member's AsReference should be used
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
            <param name="memberName">Specifies the member to be serialized.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialMemberAttribute.MemberName">
            <summary>
            The name of the member to be serialized.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoReader">
            <summary>
            A stateful reader, used to read a protobuf stream. Typical usage would be (sequentially) to call
            ReadFieldHeader and (after matching the field) an appropriate Read* method.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.FieldNumber">
            <summary>
            Gets the number of the field being processed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.WireType">
            <summary>
            Indicates the underlying proto serialization format on the wire.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="P:ProtoBuf.ProtoReader.InternStrings">
            <summary>
            Gets / sets a flag indicating whether strings should be checked for repetition; if
            true, any repeated UTF-8 byte sequence will result in the same String instance, rather
            than a second instance of the same string. Enabled by default. Note that this uses
            a <i>custom</i> interner - the system-wide string interner is not used.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int32)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int64)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Context">
            <summary>
            Addition information about this deserialization operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Dispose">
            <summary>
            Releases resources used by the reader, but importantly <b>does not</b> Dispose the 
            underlying stream; in many typical use-cases the stream is used for different
            processes, so it is assumed that the consumer will Dispose their stream separately.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt32">
            <summary>
            Reads an unsigned 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Position">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.LongPosition">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt16">
            <summary>
            Reads a signed 16-bit integer from the stream: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt16">
            <summary>
            Reads an unsigned 16-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadByte">
            <summary>
            Reads an unsigned 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSByte">
            <summary>
            Reads a signed 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt32">
            <summary>
            Reads a signed 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt64">
            <summary>
            Reads a signed 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadString">
            <summary>
            Reads a string from the stream (using UTF8); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ThrowEnumException(System.Type,System.Int32)">
            <summary>
            Throws an exception indication that the given value cannot be mapped to an enum.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadDouble">
            <summary>
            Reads a double-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadObject(System.Object,System.Int32,ProtoBuf.ProtoReader)">
            <summary>
            Reads (merges) a sub-message from the stream, internally calling StartSubItem and EndSubItem, and (in between)
            parsing the message in accordance with the model associated with the reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoReader)">
            <summary>
            Makes the end of consuming a nested message in the stream; the stream must be either at the correct EndGroup
            marker, or all fields of the sub-message must have been consumed (in either case, this means ReadFieldHeader
            should return zero)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StartSubItem(ProtoBuf.ProtoReader)">
            <summary>
            Begins consuming a nested message in the stream; supported wire-types: StartGroup, String
            </summary>
            <remarks>The token returned must be help and used when callining EndSubItem</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadFieldHeader">
            <summary>
            Reads a field header from the stream, setting the wire-type and retuning the field number. If no
            more fields are available, then 0 is returned. This methods respects sub-messages.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadFieldHeader(System.Int32)">
            <summary>
            Looks ahead to see whether the next field in the stream is what we expect
            (typically; what we've just finished reading - for example ot read successive list items)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Model">
            <summary>
            Get the TypeModel associated with this reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Hint(ProtoBuf.WireType)">
            <summary>
            Compares the streams current wire-type to the hinted wire-type, updating the reader if necessary; for example,
            a Variant may be updated to SignedVariant. If the hinted wire-type is unrelated then no change is made.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Assert(ProtoBuf.WireType)">
            <summary>
            Verifies that the stream's current wire-type is as expected, or a specialized sub-type (for example,
            SignedVariant) - in which case the current wire-type is updated. Otherwise an exception is thrown.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.SkipField">
            <summary>
            Discards the data for the current field.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt64">
            <summary>
            Reads an unsigned 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSingle">
            <summary>
            Reads a single-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadBoolean">
            <summary>
            Reads a boolean value from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
            <returns></returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendBytes(System.Byte[],ProtoBuf.ProtoReader)">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadLittleEndianInt32(System.IO.Stream)">
            <summary>
            Reads a little-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBigEndianInt32(System.IO.Stream)">
            <summary>
            Reads a big-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadVarintInt32(System.IO.Stream)">
            <summary>
            Reads a varint encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source into a pre-existing buffer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Reads a given number of bytes directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadString(System.IO.Stream,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLongLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadUInt64Variant(System.IO.Stream,System.UInt64@)">
            <returns>The number of bytes consumed; 0 if no data available</returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendExtensionData(ProtoBuf.IExtensible)">
            <summary>
            Copies the current field into the instance as extension data
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.HasSubValue(ProtoBuf.WireType,ProtoBuf.ProtoReader)">
            <summary>
            Indicates whether the reader still has data remaining in the current sub-item,
            additionally setting the wire-type for the next field if there is more data.
            This is used when decoding packed data.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.NoteObject(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Utility method, not intended for public use; this helps maintain the root object is complex scenarios
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadType">
            <summary>
            Reads a Type from the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Merge(ProtoBuf.ProtoReader,System.Object,System.Object)">
            <summary>
            Merge two objects using the details from the current reader; this is used to change the type
            of objects when an inheritance relationship is discovered later than usual during deserilazation.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoWriter">
            <summary>
            Represents an output stream for writing protobuf data.
            
            Why is the API backwards (static methods with writer arguments)?
            See: http://marcgravell.blogspot.com/2010/03/last-will-be-first-and-first-will-be.html
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type).
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteRecursionSafeObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type) - but the
            caller is asserting that this relationship is non-recursive; no recursion check will be
            performed.
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteFieldHeader(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a field-header, indicating the format of the next data we plan to write.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.StartSubItem(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the start of a nested record.
            </summary>
            <param name="instance">The instance to write.</param>
            <param name="writer">The destination.</param>
            <returns>A token representing the state of the stream; this token is given to EndSubItem.</returns>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the end of a nested record.
            </summary>
            <param name="token">The token obtained from StartubItem.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new writer against a stream
            </summary>
            <param name="dest">The destination stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Context">
            <summary>
            Addition information about this serialization operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Close">
            <summary>
            Flushes data to the underlying stream, and releases any resources. The underlying stream is *not* disposed
            by this operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Model">
            <summary>
            Get the TypeModel associated with this writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Flush(ProtoBuf.ProtoWriter)">
            <summary>
            Writes any buffered data (if possible) to the underlying stream.
            </summary>
            <param name="writer">The writer to flush</param>
            <remarks>It is not always possible to fully flush, since some sequences
            may require values to be back-filled into the byte-stream.</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32Variant(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteString(System.String,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a string to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt64(System.UInt64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt64(System.Int64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt16(System.Int16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt16(System.UInt16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteByte(System.Byte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSByte(System.SByte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt32(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteDouble(System.Double,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a double-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSingle(System.Single,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a single-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.ThrowEnumException(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Throws an exception indicating that the given enum cannot be mapped to a serialized value.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBoolean(System.Boolean,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a boolean to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.AppendExtensionData(ProtoBuf.IExtensible,ProtoBuf.ProtoWriter)">
            <summary>
            Copies any extension data stored for the instance to the underlying stream
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetPackedField(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; indicates that the next field should be skipped rather than
            a field header written. Note that the field number must match, else an exception is thrown
            when the attempt is made to write the (incorrect) field. The wire-type is taken from the
            subsequent call to WriteFieldHeader. Only primitive types can be packed.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.ClearPackedField(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; explicitly reset the packed field marker; this is not required
            if using StartSubItem/EndSubItem
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WritePackedPrefix(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; writes the length prefix using fixed sizes rather than using
            buffering. Only valid for fixed-32 and fixed-64 encoding.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetRootObject(System.Object)">
            <summary>
            Specifies a known root object to use during reference-tracked serialization
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteType(System.Type,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Type to the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="T:ProtoBuf.SerializationContext">
            <summary>
            Additional information about a serialization operation
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Context">
            <summary>
            Gets or sets a user-defined object containing additional information about this serialization/deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Default">
            <summary>
            A default SerializationContext, with minimal information.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.State">
            <summary>
            Gets or sets the source or destination of the transmitted data.
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(ProtoBuf.SerializationContext)~System.Runtime.Serialization.StreamingContext">
            <summary>
            Convert a SerializationContext to a StreamingContext
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(System.Runtime.Serialization.StreamingContext)~ProtoBuf.SerializationContext">
            <summary>
            Convert a StreamingContext to a SerializationContext
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer">
            <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. This
            is a *default* model, but custom serializer models are also supported.
            </summary>
            <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
        </member>
        <member name="M:ProtoBuf.Serializer.GetProto``1">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.GetProto``1(ProtoBuf.Meta.ProtoSyntax)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeepClone``1(``0)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.IO.Stream,``0)">
            <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.ChangeType``2(``0)">
            <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
            <remarks>No assumption of compatibility is made between the types.</remarks>
            <typeparam name="TFrom">The type of the object being copied.</typeparam>
            <typeparam name="TTo">The type of the new object to be created.</typeparam>
            <param name="instance">The existing instance to use as a template.</param>
            <returns>A new instane of type TNewType, with the data from TOldType.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Xml.XmlWriter,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied XmlWriter.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="writer">The destination XmlWriter to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Xml.XmlReader,``0)">
            <summary>
            Applies a protocol-buffer from an XmlReader to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="reader">The XmlReader containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.PrepareSerializer``1">
            <summary>
            Precompiles the serializer for a given type.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.CreateFormatter``1">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <typeparam name="T">The type of object to be [de]deserialized by the formatter.</typeparam>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignored for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="fieldNumber">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The expected tag of the item (only used with base-128 prefix style).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="source">The stream containing the data to investigate for a length.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="buffer">The buffer containing the data to investigate for a length.</param>
            <param name="index">The offset of the first byte to read from the buffer.</param>
            <param name="count">The number of bytes to read from the buffer.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="F:ProtoBuf.Serializer.ListItemTag">
            <summary>
            The field number that is used as a default when serializing/deserializing a list of objects.
            The data is treated as repeated message with field number 1.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.NonGeneric">
            <summary>
            Provides non-generic access to the default serializer.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Merge(System.IO.Stream,System.Object)">
            <summary>Applies a protocol-buffer stream to an existing instance.</summary>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,ProtoBuf.Serializer.TypeResolver,System.Object@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.CanSerialize(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.GlobalOptions">
            <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName">
            <summary>
            <see cref="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault"/>
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.TypeResolver">
            <summary>
            Maps a field-number to a type
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.FlushPool">
            <summary>
            Releases any internal buffers that have been reserved for efficiency; this does not affect any serialization
            operations; simply: it can be used (optionally) to release the buffers for garbage collection (at the expense
            of having to re-allocate a new buffer for the next operation, rather than re-use prior buffers).
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ExpectedType">
            <summary>
            The type that this serializer is intended to work for.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Write(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Perform the steps necessary to serialize this data.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="dest">The writer entity that is accumulating the output data.</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Read(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Perform the steps necessary to deserialize this data.
            </summary>
            <param name="value">The current value, if appropriate.</param>
            <param name="source">The reader providing the input data.</param>
            <returns>The updated / replacement value.</returns>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue">
            <summary>
            Indicates whether a Read operation <em>replaces</em> the existing value, or
            <em>extends</em> the value. If false, the "value" parameter to Read is
            discarded, and should be passed in as null.
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ReturnsValue">
            <summary>
            Now all Read operations return a value (although most do); if false no
            value should be expected.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitWrite(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>Emit the IL necessary to perform the given actions
            to serialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="valueFrom">The source of the data to work against;
            If the value is only needed once, then LoadValue is sufficient. If
            the value is needed multiple times, then note that a "null"
            means "the top of the stack", in which case you should create your
            own copy - GetLocalWithValue.</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitRead(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            Emit the IL necessary to perform the given actions to deserialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="entity">For nested values, the instance holding the values; note
            that this is not always provided - a null means not supplied. Since this is always
            a variable or argument, it is not necessary to consume this value.</param>
        </member>
        <member name="T:ProtoBuf.SubItemToken">
            <summary>
            Used to hold particulars relating to nested objects. This is opaque to the caller - simply
            give back the token you are given at the end of an object.
            </summary>
        </member>
        <member name="T:ProtoBuf.WireType">
            <summary>
            Indicates the encoding used to represent an individual value in a protobuf stream
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.None">
            <summary>
            Represents an error condition
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Variant">
            <summary>
            Base-128 variant-length encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed64">
            <summary>
            Fixed-length 8-byte encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.String">
            <summary>
            Length-variant-prefixed encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.StartGroup">
            <summary>
            Indicates the start of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.EndGroup">
            <summary>
            Indicates the end of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed32">
            <summary>
            Fixed-length 4-byte encoding
            </summary>10
        </member>
        <member name="F:ProtoBuf.WireType.SignedVariant">
            <summary>
            This is not a formal wire-type in the "protocol buffers" spec, but
            denotes a variant integer that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
        </member>
    </members>
</doc>
