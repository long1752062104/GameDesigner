<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetty.Common</name>
    </assembly>
    <members>
        <member name="T:DotNetty.Common.Concurrency.AbstractEventExecutor">
            <summary>
                Abstract base class for <see cref="T:DotNetty.Common.Concurrency.IEventExecutor" /> implementations
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.#ctor">
            <summary>Creates an instance of <see cref="T:DotNetty.Common.Concurrency.AbstractEventExecutor"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup)">
            <summary>Creates an instance of <see cref="T:DotNetty.Common.Concurrency.AbstractEventExecutor"/>.</summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.IsShuttingDown">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.TerminationCompletion">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.GetNext">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.Parent">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.InEventLoop">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.IsInEventLoop(DotNetty.Common.Concurrency.XThread)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(System.Action,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(System.Action{System.Object},System.Object,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ShutdownGracefullyAsync">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IScheduledExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.SetCurrentExecutor(DotNetty.Common.Concurrency.IEventExecutor)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractExecutorService.IsShutdown">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractExecutorService.IsTerminated">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{``0})">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object,System.Threading.CancellationToken)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutorService"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(DotNetty.Common.Concurrency.IRunnable)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(System.Action{System.Object},System.Object)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(System.Action{System.Object,System.Object},System.Object,System.Object)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(System.Action)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IExecutor"/>
        </member>
        <member name="T:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor">
            <summary>
                Abstract base class for <see cref="T:DotNetty.Common.Concurrency.IEventExecutor" />s that need to support scheduling.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.CancelScheduledTasks">
            <summary>
                Cancel all scheduled tasks
                This method MUST be called only when <see cref="P:DotNetty.Common.Concurrency.IEventExecutor.InEventLoop" /> is <c>true</c>.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutor.Parent">
            <summary>
            Parent <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutor.InEventLoop">
            <summary>
                Returns <c>true</c> if the current <see cref="T:DotNetty.Common.Concurrency.XThread" /> belongs to this event loop,
                <c>false</c> otherwise.
            </summary>
            <remarks>
                It is a convenient way to determine whether code can be executed directly or if it
                should be posted for execution to this executor instance explicitly to ensure execution in the loop.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutor.IsInEventLoop(DotNetty.Common.Concurrency.XThread)">
            <summary>
                Returns <c>true</c> if the given <see cref="T:DotNetty.Common.Concurrency.XThread" /> belongs to this event loop,
                <c>false></c> otherwise.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.IEventExecutorGroup">
            <summary>
            Provides an access to a set of <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>s it manages.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutorGroup.IsShuttingDown">
            <summary>
                Returns <c>true</c> if and only if this executor is being shut down via <see cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync" />.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync">
            <summary>
            Terminates this <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> and all its <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>s.
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> for completion of termination.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <summary>
            Terminates this <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> and all its <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>s.
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> for completion of termination.</returns>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutorGroup.TerminationCompletion">
            <summary>
            A <see cref="T:System.Threading.Tasks.Task"/> for completion of termination. <see cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorGroup.GetNext">
            <summary>
            Returns <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(DotNetty.Common.Concurrency.IRunnable)">
            <summary>
                Executes the given task.
            </summary>
            <remarks>Threading specifics are determined by <c>IEventExecutor</c> implementation.</remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(System.Action{System.Object},System.Object)">
            <summary>
                Executes the given action.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(System.Action)">
            <summary>
                Executes the given <paramref name="action" />.
            </summary>
            <remarks>Threading specifics are determined by <c>IEventExecutor</c> implementation.</remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(System.Action{System.Object,System.Object},System.Object,System.Object)">
            <summary>
                Executes the given action.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IExecutorService.IsShutdown">
            <summary>
                Returns <c>true</c> if this executor has been shut down, <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IExecutorService.IsTerminated">
            <summary>
                Returns <c>true</c> if all tasks have completed following shut down.
            </summary>
            <remarks>
                Note that <see cref="P:DotNetty.Common.Concurrency.IExecutorService.IsTerminated" /> is never <c>true</c> unless <see cref="!:ShutdownGracefullyAsync()" /> was called first.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{``0})">
            <summary>
                Executes the given function and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of
                execution.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object,System.Threading.CancellationToken)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan)">
            <summary>
                Creates and executes a one-shot action that becomes enabled after the given delay.
            </summary>
            <param name="action">the task to execute</param>
            <param name="delay">the time from now to delay execution</param>
            <returns>an <see cref="T:DotNetty.Common.Concurrency.IScheduledTask" /> representing pending completion of the task.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(System.Action,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(System.Action{System.Object},System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor">
            <summary>
            <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> backed by a single thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.Scheduler">
            <summary>
                Task Scheduler that will post work to this executor's queue.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsShuttingDown">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.TerminationCompletion">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsShutdown">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsTerminated">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsInEventLoop(DotNetty.Common.Concurrency.XThread)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.Execute(DotNetty.Common.Concurrency.IRunnable)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddShutdownHook(System.Action)">
            <summary>
            Adds an <see cref="T:System.Action"/> which will be executed on shutdown of this instance.
            </summary>
            <param name="action">The <see cref="T:System.Action"/> to run on shutdown.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RemoveShutdownHook(System.Action)">
            <summary>
            Removes a previously added <see cref="T:System.Action"/> from the collection of <see cref="T:System.Action"/>s which will be
            executed on shutdown of this instance.
            </summary>
            <param name="action">The <see cref="T:System.Action"/> to remove.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal.RemoveAll">
            <summary>
                Removes all <see cref="T:DotNetty.Common.FastThreadLocal"/> variables bound to the current thread.  This operation is useful when you
                are in a container environment, and you don't want to leave the thread local variables in the threads you do not
                manage.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal.Destroy">
            <summary>
            Destroys the data structure that keeps all <see cref="T:DotNetty.Common.FastThreadLocal"/> variables accessed from
            non-<see cref="T:DotNetty.Common.FastThreadLocal"/>s.  This operation is useful when you are in a container environment, and
            you do not want to leave the thread local variables in the threads you do not manage.  Call this method when
            your application is being unloaded from the container.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal.Remove(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
                Sets the value to uninitialized; a proceeding call to get() will trigger a call to GetInitialValue().
            </summary>
            <param name="threadLocalMap"></param>
        </member>
        <member name="P:DotNetty.Common.FastThreadLocal`1.Count">
            <summary>
                Returns the number of thread local variables bound to the current thread.
            </summary>
        </member>
        <member name="P:DotNetty.Common.FastThreadLocal`1.Value">
            <summary>
                Gets or sets current value for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.Get(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
                Returns the current value for the specified thread local map.
                The specified thread local map must be for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.Set(DotNetty.Common.InternalThreadLocalMap,`0)">
            <summary>
            Set the value for the specified thread local map. The specified thread local map must be for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.IsSet">
            <summary>
            Returns <c>true</c> if and only if this thread-local variable is set.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.IsSet(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
            Returns <c>true</c> if and only if this thread-local variable is set.
            The specified thread local map must be for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.GetInitialValue">
            <summary>
            Returns the initial value for this thread-local variable.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.Remove(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
            Sets the value to uninitialized for the specified thread local map;
            a proceeding call to <see cref="M:DotNetty.Common.FastThreadLocal`1.Get(DotNetty.Common.InternalThreadLocalMap)"/> will trigger a call to <see cref="M:DotNetty.Common.FastThreadLocal`1.GetInitialValue"/>.
            The specified thread local map must be for the current thread.
            </summary>
            <param name="threadLocalMap">
            The <see cref="T:DotNetty.Common.InternalThreadLocalMap"/> from which this <see cref="T:DotNetty.Common.FastThreadLocal"/> should be removed.
            </param>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.OnRemoval(`0)">
            <summary>
            Invoked when this thread local variable is removed by <see cref="M:DotNetty.Common.FastThreadLocal`1.Remove"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.InternalThreadLocalMap">
            <summary>
            The internal data structure that stores the thread-local variables for DotNetty and all
            <see cref="T:DotNetty.Common.FastThreadLocal"/>s. Note that this class is for internal use only and is subject to change at any
            time. Use <see cref="T:DotNetty.Common.FastThreadLocal"/> unless you know what you are doing.
            </summary>
        </member>
        <member name="F:DotNetty.Common.InternalThreadLocalMap.indexedVariables">
            <summary>
            Used by <see cref="T:DotNetty.Common.FastThreadLocal"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.InternalThreadLocalMap.SetIndexedVariable(System.Int32,System.Object)">
            <summary>
            Sets a value at the given index in this <see cref="T:DotNetty.Common.InternalThreadLocalMap"/>.
            </summary>
            <param name="index">The desired index at which a value should be set.</param>
            <param name="value">The value to set at the given index.</param>
            <returns><c>true</c> if and only if a new thread-local variable has been created.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.AppendableCharSequence.Reset">
            <summary>
            Resets the <see cref="T:DotNetty.Common.Internal.AppendableCharSequence"/>. Be aware this will only reset the current internal
            position and not shrink the internal char array.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.AppendableCharSequence.SubStringUnsafe(System.Int32,System.Int32)">
            <summary>
            Create a new ascii string, this method assumes all chars has been sanitized to ascii chars when appending
            to the array.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1">
            Forked from
            <a href="https://github.com/JCTools/JCTools">JCTools</a>
            .
            A concurrent access enabling class used by circular array based queues this class exposes an offset computation
            method along with differently memory fenced load/store methods into the underlying array. The class is pre-padded and
            the array is padded on either side to help with False sharing prvention. It is expected theat subclasses handle post
            padding.
            <p />
            Offset calculation is separate from access to enable the reuse of a give compute offset.
            <p />
            Load/Store methods using a
            <i>buffer</i>
            parameter are provided to allow the prevention of field reload after a
            LoadLoad barrier.
            <p />
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)">
            <summary>
            Calculates an element offset based on a given array index.
            </summary>
            <param name="index">The desirable element index.</param>
            <returns>The offset in bytes within the array for a given index.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.SpElement(System.Int64,`0)">
            <summary>
            A plain store (no ordering/fences) of an element to a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <param name="e">A kitty.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.SoElement(System.Int64,`0)">
            <summary>
            An ordered store(store + StoreStore barrier) of an element to a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <param name="e">An orderly kitty.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.LpElement(System.Int64)">
            <summary>
            A plain load (no ordering/fences) of an element from a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <returns>The element at the offset.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.LvElement(System.Int64)">
            <summary>
            A volatile load (load + LoadLoad barrier) of an element from a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <returns>The element at the offset.</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.AbstractInternalLogger">
            <summary>
            A skeletal implementation of <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/>. This class implements
            all methods that have a <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel"/> parameter by default to call
            specific logger methods such as <see cref="M:DotNetty.Common.Internal.Logging.AbstractInternalLogger.Info(System.String)"/> or <see cref="P:DotNetty.Common.Internal.Logging.AbstractInternalLogger.InfoEnabled"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.AbstractInternalLogger.#ctor(System.String)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="name">A friendly name for the new logger instance.</param>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.FormattingTuple">
            <summary>
            Holds the results of formatting done by <see cref="T:DotNetty.Common.Internal.Logging.MessageFormatter"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.IInternalLogger">
            <summary>
                <em>Internal-use-only</em> logger used by DotNetty. <strong>DO NOT</strong>
                access this class outside of DotNetty.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.Name">
            <summary>
                Return the name of this <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger" /> instance.
            </summary>
            <value>name of this logger instance</value>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.TraceEnabled">
            <summary>
                Is this logger instance enabled for the TRACE level?
            </summary>
            <value>true if this Logger is enabled for level TRACE, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String)">
            <summary>
                Log a message object at level TRACE.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object)">
            <summary>
                Log a message at level TRACE according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level TRACE.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level TRACE according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level TRACE.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object[])">
            <summary>
                Log a message at level TRACE according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level TRACE. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for TRACE. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Exception)">
            <summary>
                Log an exception at level TRACE with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.Exception)">
            <summary>
                Log an exception at level TRACE.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.DebugEnabled">
            <summary>
                Is this logger instance enabled for the DEBUG level?
            </summary>
            <value>true if this Logger is enabled for level DEBUG, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String)">
            <summary>
                Log a message object at level DEBUG.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object)">
            <summary>
                Log a message at level DEBUG according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level DEBUG.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level DEBUG according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level DEBUG.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object[])">
            <summary>
                Log a message at level DEBUG according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level DEBUG. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for DEBUG. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Exception)">
            <summary>
                Log an exception at level DEBUG with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.Exception)">
            <summary>
                Log an exception at level DEBUG.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.InfoEnabled">
            <summary>
                Is this logger instance enabled for the INFO level?
            </summary>
            <value>true if this Logger is enabled for level INFO, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String)">
            <summary>
                Log a message object at level INFO.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object)">
            <summary>
                Log a message at level INFO according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level INFO.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level INFO according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level INFO.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object[])">
            <summary>
                Log a message at level INFO according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level INFO. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for INFO. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Exception)">
            <summary>
                Log an exception at level INFO with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.Exception)">
            <summary>
                Log an exception at level INFO.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.WarnEnabled">
            <summary>
                Is this logger instance enabled for the WARN level?
            </summary>
            <value>true if this Logger is enabled for level WARN, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String)">
            <summary>
                Log a message object at level WARN.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object)">
            <summary>
                Log a message at level WARN according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level WARN.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object[])">
            <summary>
                Log a message at level WARN according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level WARN. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for WARN. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level WARN according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level WARN.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Exception)">
            <summary>
                Log an exception at level WARN with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.Exception)">
            <summary>
                Log an exception at level WARN.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.ErrorEnabled">
            <summary>
                Is this logger instance enabled for the ERROR level?
            </summary>
            <value>true if this Logger is enabled for level ERROR, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String)">
            <summary>
                Log a message object at level ERROR.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object)">
            <summary>
                Log a message at level ERROR according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level ERROR.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level ERROR according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level ERROR.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object[])">
            <summary>
                Log a message at level ERROR according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level ERROR. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for ERROR. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Exception)">
            <summary>
                Log an exception at level ERROR with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.Exception)">
            <summary>
                Log an exception at level ERROR.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.IsEnabled(DotNetty.Common.Internal.Logging.InternalLogLevel)">
            <summary>
                Is the logger instance enabled for the specified <paramref name="level"/>?
            </summary>
            <param name="level">log level</param>
            <returns>true if this Logger is enabled for the specified <paramref name="level"/>, false otherwise.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String)">
            <summary>
                Log a message object at a specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
            </summary>
            <param name="level">log level</param>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object)">
            <summary>
                Log a message at a specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" /> according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
                </para>
            </summary>
            <param name="level">log level</param>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object,System.Object)">
            <summary>
                Log a message at a specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" /> according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
                </para>
            </summary>
            <param name="level">log level</param>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object[])">
            <summary>
                Log a message at the specified <paramref name="level"/> according to the specified format
                and arguments.
                <para>
                    This form avoids superfluous string concatenation when the logger
                    is disabled for the specified <paramref name="level"/>. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c> before invoking the method,
                    even if this logger is disabled for the specified <paramref name="level"/>. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object)" /> and
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object,System.Object)" /> arguments exist solely
                    in order to avoid this hidden cost.
                </para>
            </summary>
            <param name="level">log level</param>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Exception)">
            <summary>
                Log an exception at the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" /> with an
                accompanying message.
            </summary>
            <param name="level">log level</param>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.Exception)">
            <summary>
                Log an exception at the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
            </summary>
            <param name="level">log level</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.InternalLoggerFactory">
            <summary>
                Creates an <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger" /> or changes the default factory
                implementation. This factory allows you to choose what logging framework
                DotNetty should use.  The default factory is own <see cref="T:Microsoft.Extensions.Logging.LoggerFactory"/> with <see cref="T:DotNetty.Common.Internal.Logging.EventSourceLoggerProvider" /> registered.
                You can change it to your preferred logging framework before other DotNetty classes are loaded:
                <pre>
                    <code>InternalLoggerFactory.DefaultFactory = new LoggerFactory();</code>
                </pre>
                Please note that the new default factory is effective only for the classes
                which were loaded after the default factory is changed.  Therefore, <see cref="P:DotNetty.Common.Internal.Logging.InternalLoggerFactory.DefaultFactory"/> should be set as early
                as possible and should not be called more than once.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.InternalLoggerFactory.DefaultFactory">
            <summary>
                Gets or sets the default factory.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.InternalLoggerFactory.GetInstance``1">
            <summary>
                Creates a new logger instance with the name of the specified type.
            </summary>
            <typeparam name="T">type where logger is used</typeparam>
            <returns>logger instance</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.InternalLoggerFactory.GetInstance(System.Type)">
            <summary>
                Creates a new logger instance with the name of the specified type.
            </summary>
            <param name="type">type where logger is used</param>
            <returns>logger instance</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.InternalLoggerFactory.GetInstance(System.String)">
            <summary>
                Creates a new logger instance with the specified name.
            </summary>
            <param name="name">logger name</param>
            <returns>logger instance</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.InternalLogLevel">
            <summary>
            The log level that <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/> can log at.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.TRACE">
            <summary>
                'TRACE' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.DEBUG">
            <summary>
                'DEBUG' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.INFO">
            <summary>
                'INFO' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.WARN">
            <summary>
                'WARN' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.ERROR">
            <summary>
                'ERROR' log level.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.MessageFormatter">
            <summary>
            Formats messages according to very simple substitution rules. Substitutions can be made 1, 2 or more arguments.
            <para>For example,</para>
            <code>
            MessageFormatter.Format(&quot;Hi {}.&quot;, &quot;there&quot;)
            </code>
            <para>
            will return the string "Hi there.".
            </para>
            <para>
            The {} pair is called the <em>formatting anchor</em>. It serves to designate the location where arguments need
            to be substituted within the message pattern.
            </para>
            <para>
            In case your message contains the '{' or the '}' character, you do not have to do anything special unless the
            '}' character immediately follows '{'. For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);
            </code>
            <para>
            will return the string "Set {1,2,3} is not equal to 1,2.".
            </para>
            <para>
            If for whatever reason you need to place the string "{}" in the message without its <em>formatting anchor</em>
            meaning, then you need to escape the '{' character with '\', that is the backslash character. Only the '{'
            character should be escaped. There is no need to escape the '}' character. For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Set \\{} is not equal to {}.&quot;, &quot;1,2&quot;);
            </code>
            <para>
            will return the string "Set {} is not equal to 1,2.".
            </para>
            <para>
            The escaping behavior just described can be overridden by escaping the escape character '\'. Calling
            </para>
            <code>
            MessageFormatter.Format(&quot;File name is C:\\\\{}.&quot;, &quot;file.zip&quot;);
            </code>
            <para>
            will return the string "File name is C:\file.zip".
            </para>
            <seealso cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object)" />
            <seealso cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object,System.Object)" />
            <seealso cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.ArrayFormat(System.String,System.Object[])" />
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object)">
            <summary>
            Performs single argument substitution for the given <paramref name="messagePattern"/>.
            <para>
            For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Hi {}.&quot;, &quot;there&quot;);
            </code>
            <para>
            will return the string "Hi there.".
            </para>
            </summary>
            <param name="messagePattern">The message pattern which will be parsed and formatted</param>
            <param name="arg">The argument to be substituted in place of the formatting anchor</param>
            <returns>The formatted message</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object,System.Object)">
            <summary>
            Performs a two argument substitution for the given <paramref name="messagePattern"/>.
            <para>
            For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);
            </code>
            <para>
            will return the string "Hi Alice. My name is Bob.".
            </para>
            </summary>
            <param name="messagePattern">The message pattern which will be parsed and formatted</param>
            <param name="argA">The argument to be substituted in place of the first formatting anchor</param>
            <param name="argB">The argument to be substituted in place of the second formatting anchor</param>
            <returns>The formatted message</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.MessageFormatter.ArrayFormat(System.String,System.Object[])">
            <summary>
            Same principle as the <see cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object)"/> and <see cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object,System.Object)"/>
            methods, except that any number of arguments can be passed in an array.
            </summary>
            <param name="messagePattern">The message pattern which will be parsed and formatted</param>
            <param name="argArray">An array of arguments to be substituted in place of formatting anchors</param>
            <returns>The formatted message</returns>
        </member>
        <member name="F:DotNetty.Common.Internal.MacAddressUtil.MacAddressLength">
            Length of a valid MAC address.
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.GetBestAvailableMac">
            Obtains the best MAC address found on local network interfaces.
            Generally speaking, an active network interface used on public
            networks is better than a local network interface.
            <returns>byte array containing a MAC. null if no MAC can be found.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.FormatAddress(System.Byte[])">
            <param name="addr">byte array of a MAC address.</param>
            <returns>hex formatted MAC address.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.CompareAddresses(System.Byte[],System.Byte[])">
            <returns>positive - current is better, 0 - cannot tell from MAC addr, negative - candidate is better.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.CompareAddresses(System.Net.IPAddress,System.Net.IPAddress)">
            <returns>positive - current is better, 0 - cannot tell, negative - candidate is better</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.MpscArrayQueue`1">
            <summary>
            Forked from <a href="https://github.com/JCTools/JCTools">JCTools</a>.
            A Multi-Producer-Single-Consumer queue based on a <see cref="T:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1"/>. This implies
            that any thread may call the Enqueue methods, but only a single thread may call poll/peek for correctness to
            maintained.
            <para>
            This implementation follows patterns documented on the package level for False Sharing protection.
            </para>
            <para>
            This implementation is using the <a href="http://sourceforge.net/projects/mc-fastflow/">Fast Flow</a>
            method for polling from the queue (with minor change to correctly publish the index) and an extension of
            the Leslie Lamport concurrent queue algorithm (originated by Martin Thompson) on the producer side.
            </para>
            </summary>
            <typeparam name="T">The type of each item in the queue.</typeparam>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryEnqueue(`0)">
            <summary>
            Lock free Enqueue operation, using a single compare-and-swap. As the class name suggests, access is
            permitted to many threads concurrently.
            </summary>
            <param name="e">The item to enqueue.</param>
            <returns><c>true</c> if the item was added successfully, otherwise <c>false</c>.</returns>
            <seealso cref="M:DotNetty.Common.Internal.IQueue`1.TryEnqueue(`0)"/>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.WeakEnqueue(`0)">
            <summary>
            A wait-free alternative to <see cref="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryEnqueue(`0)"/>, which fails on compare-and-swap failure.
            </summary>
            <param name="e">The item to enqueue.</param>
            <returns><c>1</c> if next element cannot be filled, <c>-1</c> if CAS failed, and <c>0</c> if successful.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryDequeue(`0@)">
            <summary>
            Lock free poll using ordered loads/stores. As class name suggests, access is limited to a single thread.
            </summary>
            <param name="item">The dequeued item.</param>
            <returns><c>true</c> if an item was retrieved, otherwise <c>false</c>.</returns>
            <seealso cref="M:DotNetty.Common.Internal.IQueue`1.TryDequeue(`0@)"/>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryPeek(`0@)">
            <summary>
            Lock free peek using ordered loads. As class name suggests access is limited to a single thread.
            </summary>
            <param name="item">The peeked item.</param>
            <returns><c>true</c> if an item was retrieved, otherwise <c>false</c>.</returns>
            <seealso cref="M:DotNetty.Common.Internal.IQueue`1.TryPeek(`0@)"/>
        </member>
        <member name="P:DotNetty.Common.Internal.MpscArrayQueue`1.Count">
            <summary>
            Returns the number of items in this <see cref="T:DotNetty.Common.Internal.MpscArrayQueue`1"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.SpElement``1(``0[],System.Int64,``0)">
            <summary>
            A plain store (no ordering/fences) of an element to a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <param name="e">An orderly kitty.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.SoElement``1(``0[],System.Int64,``0)">
            <summary>
            An ordered store(store + StoreStore barrier) of an element to a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <param name="e"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.LpElement``1(``0[],System.Int64)">
            <summary>
            A plain load (no ordering/fences) of an element from a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <returns>The element at the given <paramref name="offset"/> in the given <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.LvElement``1(``0[],System.Int64)">
            <summary>
            A volatile load (load + LoadLoad barrier) of an element from a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <returns>The element at the given <paramref name="offset"/> in the given <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.CalcElementOffset(System.Int64,System.Int64)">
            <summary>
            Gets the offset in bytes within the array for a given index.
            </summary>
            <param name="index">The desired element index.</param>
            <param name="mask">Mask for the index.</param>
            <returns>The offset (in bytes) within the array for a given index.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.BaseLinkedQueuePad0`1.Offer(`0)">
            <summary>
            Called from a producer thread subject to the restrictions appropriate to the implementation and
            according to the <see cref="M:DotNetty.Common.Internal.ILinkedQueue`1.Offer(`0)"/> interface.
            </summary>
            <param name="e">The element to enqueue.</param>
            <returns><c>true</c> if the element was inserted, <c>false</c> iff the queue is full.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.BaseLinkedQueuePad0`1.Poll">
            <summary>
            Called from the consumer thread subject to the restrictions appropriate to the implementation and
            according to the <see cref="M:DotNetty.Common.Internal.ILinkedQueue`1.Poll"/> interface.
            </summary>
            <returns>A message from the queue if one is available, <c>null</c> iff the queue is empty.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.BaseLinkedQueuePad0`1.Peek">
            <summary>
            Called from the consumer thread subject to the restrictions appropriate to the implementation and
            according to the <see cref="M:DotNetty.Common.Internal.ILinkedQueue`1.Peek"/> interface.
            </summary>
            <returns>A message from the queue if one is available, <c>null</c> iff the queue is empty.</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.SystemPropertyUtil">
            <summary>
                A collection of utility methods to retrieve and parse the values of the system properties (Environment variables).
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.Contains(System.String)">
            <summary>
                Returns <c>true</c> if and only if the system property with the specified <c>key</c>
                exists.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.Get(System.String)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to <c>null</c> if the property access fails.
            </summary>
            <returns>the property value or <c>null</c></returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.Get(System.String,System.String)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value.
                <c>def</c> if there's no such property or if an access to the
                specified property is not allowed.
            </returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.GetBoolean(System.String,System.Boolean)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value or <c>def</c> if there's no such property or
                if an access to the specified property is not allowed.
            </returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.GetInt(System.String,System.Int32)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value.
                <c>def</c> if there's no such property or if an access to the
                specified property is not allowed.
            </returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.GetLong(System.String,System.Int64)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value.
                <c>def</c> if there's no such property or if an access to the
                specified property is not allowed.
            </returns>
        </member>
        <member name="T:DotNetty.Common.IReferenceCounted">
            <summary>
                Reference counting interface for reusable objects
            </summary>
        </member>
        <member name="P:DotNetty.Common.IReferenceCounted.ReferenceCount">
            <summary>
                Returns the reference count of this object
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Retain">
            <summary>
                Increases the reference count by 1
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Retain(System.Int32)">
            <summary>
                Increases the reference count by <paramref name="increment" />
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Touch">
            <summary>
                Records the current access location of this object for debugging purposes.
                If this object is determined to be leaked, the information recorded by this operation will be provided to you
                via <see cref="T:DotNetty.Common.ResourceLeakDetector" />. This method is a shortcut to <see cref="M:DotNetty.Common.IReferenceCounted.Touch(System.Object)" /> with null as
                an argument.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Touch(System.Object)">
            <summary>
                Records the current access location of this object with an additonal arbitrary information for debugging
                purposes. If this object is determined to be leaked, the information recorded by this operation will be
                provided to you via <see cref="T:DotNetty.Common.ResourceLeakDetector" />.
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Release">
            <summary>
                Decreases the reference count by 1 and deallocates this object if the reference count reaches 0.
            </summary>
            <returns>true if and only if the reference count is 0 and this object has been deallocated</returns>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)">
            <summary>
                Decreases the reference count by <paramref name="decrement" /> and deallocates this object if the reference count
                reaches 0.
            </summary>
            <returns>true if and only if the reference count is 0 and this object has been deallocated</returns>
        </member>
        <member name="T:DotNetty.Common.IResourceLeakHint">
            <summary>
                A hint object that provides human-readable message for easier resource leak tracking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakHint.ToHintString">
            <summary>
                Returns a human-readable message that potentially enables easier resource leak tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakTracker.Record">
            <summary>
                Records the caller's current stack trace so that the <see cref="T:DotNetty.Common.ResourceLeakDetector" /> can tell where the
                leaked
                resource was accessed lastly. This method is a shortcut to <see cref="M:DotNetty.Common.IResourceLeakTracker.Record(System.Object)" /> with <c>null</c> as an
                argument.
            </summary>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakTracker.Record(System.Object)">
            <summary>
                Records the caller's current stack trace and the specified additional arbitrary information
                so that the <see cref="T:DotNetty.Common.ResourceLeakDetector" /> can tell where the leaked resource was accessed lastly.
            </summary>
            <param name="hint"></param>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakTracker.Close(System.Object)">
            <summary>
                Close the leak so that <see cref="T:DotNetty.Common.ResourceLeakDetector" /> does not warn about leaked resources.
            </summary>
            <returns><c>true</c> if called first time, <c>false</c> if called already</returns>
        </member>
        <member name="T:DotNetty.Common.ResourceLeakDetector.DetectionLevel">
            <summary>
               Represents the level of resource leak detection.
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Disabled">
            <summary>
                Disables resource leak detection.
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Simple">
            <summary>
                Enables simplistic sampling resource leak detection which reports there is a leak or not,
                at the cost of small overhead (default).
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Advanced">
            <summary>
                Enables advanced sampling resource leak detection which reports where the leaked object was accessed
                recently at the cost of high overhead.
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Paranoid">
            <summary>
                Enables paranoid resource leak detection which reports where the leaked object was accessed recently,
                at the cost of the highest possible overhead (for testing purposes only).
            </summary>
        </member>
        <member name="P:DotNetty.Common.ResourceLeakDetector.Enabled">
            Returns <c>true</c> if resource leak detection is enabled.
        </member>
        <member name="P:DotNetty.Common.ResourceLeakDetector.Level">
            <summary>
                Gets or sets resource leak detection level
            </summary>
        </member>
        <member name="M:DotNetty.Common.ResourceLeakDetector.Track(System.Object)">
            <summary>
                Creates a new <see cref="T:DotNetty.Common.IResourceLeakTracker" /> which is expected to be closed
                when the
                related resource is deallocated.
            </summary>
            <returns>the <see cref="T:DotNetty.Common.IResourceLeakTracker" /> or <c>null</c></returns>
        </member>
        <member name="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)">
            <summary>
            Schedules the specified <see cref="T:System.Action"/> to run when the specified <see cref="T:DotNetty.Common.Concurrency.XThread"/> dies.
            </summary>
        </member>
        <member name="M:DotNetty.Common.ThreadDeathWatcher.Unwatch(DotNetty.Common.Concurrency.XThread,System.Action)">
            <summary>
            Cancels the task scheduled via <see cref="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.ThreadDeathWatcher.AwaitInactivity(System.TimeSpan)">
            <summary>
            Waits until the thread of this watcher has no threads to watch and terminates itself.
            Because a new watcher thread will be started again on <see cref="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)"/>,
            this operation is only useful when you want to ensure that the watcher thread is terminated
            <strong>after</strong> your application is shut down and there's no chance of calling <see cref="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)"/>
            afterwards.
            </summary>
            <param name="timeout"></param>
            <returns><c>true</c> if and only if the watcher thread has been terminated.</returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.AbstractConstant`1">
            <summary>Base implementation of <see cref="T:DotNetty.Common.Utilities.IConstant" />.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AbstractConstant`1.#ctor(System.Int32,System.String)">
            <summary>Creates a new instance.</summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.ArrayExtensions">
            <summary>
                Extension methods used for slicing byte arrays
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ArrayExtensions.CombineBytes(System.Byte[][])">
            <summary>
                Merge the byte arrays into one byte array.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AsciiString.ArrayChanged">
            <summary>
            During normal use cases the AsciiString should be immutable, but if the
            underlying array is shared, and changes then this needs to be called.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.AtomicReference`1">
            <summary>
                Implementation of the java.concurrent.util AtomicReference type.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.#ctor(`0)">
            <summary>
                Sets the initial value of this <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" /> to <see cref="!:originalValue" />.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.#ctor">
            <summary>
                Default constructor
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.AtomicReference`1.Value">
            <summary>
                The current value of this <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" />
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.CompareAndSet(`0,`0)">
            <summary>
                If <see cref="P:DotNetty.Common.Utilities.AtomicReference`1.Value" /> equals <paramref name="expected"/>, then set the Value to
                <paramref name="newValue"/>
                Returns true if  <paramref name="newValue"/> was set, false otherwise.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.op_Implicit(DotNetty.Common.Utilities.AtomicReference{`0})~`0">
            <summary>
                Implicit conversion operator = automatically casts the <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" /> to an instance of
                <typeparam name="T"></typeparam>
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.op_Implicit(`0)~DotNetty.Common.Utilities.AtomicReference{`0}">
            <summary>
                Implicit conversion operator = allows us to cast any type directly into a <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" />
                instance.
            </summary>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.AttributeKey`1">
            <summary>
                Key which can be used to access <seealso cref="T:System.Attribute" /> out of the <see cref="T:DotNetty.Common.Utilities.IAttributeMap" />. Be aware that
                it is not be possible to have multiple keys with the same name.
            </summary>
            <typeparam name="T">
                the type of the <see cref="T:System.Attribute" /> which can be accessed via this <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" />.
            </typeparam>
        </member>
        <member name="M:DotNetty.Common.Utilities.AttributeKey`1.ValueOf(System.String)">
            <summary>Returns the singleton instance of the {@link AttributeKey} which has the specified <c>name</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AttributeKey`1.Exists(System.String)">
            <summary>Returns <c>true</c> if a <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> exists for the given <c>name</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AttributeKey`1.NewInstance(System.String)">
            <summary>
                Creates a new <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> for the given <c>name</c> or fail with an
                <see cref="T:System.ArgumentException" /> if a <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> for the given <c>name</c> exists.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IByteProcessor">
            <summary>
                Provides a mechanism to iterate over a collection of bytes.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNul">
            <summary>
                Aborts on a <c>NUL (0x00)</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonNul">
            <summary>
                Aborts on a non-<c>NUL (0x00)</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindCR">
            <summary>
                Aborts on a <c>CR ('\r')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonCR">
            <summary>
                Aborts on a non-<c>CR ('\r')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindLF">
            <summary>
                Aborts on a <c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonLF">
            <summary>
                Aborts on a non-<c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindSemicolon">
            <summary>
                Aborts on a <c>CR (';')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindComma">
            <summary>
                Aborts on a comma <c>(',')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindAsciiSpace">
            <summary>
                Aborts on a ascii space character (<c>' '</c>).
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindCrlf">
            <summary>
                Aborts on a <c>CR ('\r')</c> or a <c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonCrlf">
            <summary>
                Aborts on a byte which is neither a <c>CR ('\r')</c> nor a <c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindLinearWhitespace">
            <summary>
                Aborts on a linear whitespace (a <c>' '</c> or a <c>'\t'</c>).
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonLinearWhitespace">
            <summary>
                Aborts on a byte which is not a linear whitespace (neither <c>' '</c> nor <c>'\t'</c>).
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.ConstantPool">
            <summary>
                A pool of <see cref="T:DotNetty.Common.Utilities.IConstant" />s.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.ValueOf``1(System.Type,System.String)">
            <summary>Shortcut of <c>this.ValueOf(firstNameComponent.Name + "#" + secondNameComponent)</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.ValueOf``1(System.String)">
            <summary>
                Returns the <see cref="T:DotNetty.Common.Utilities.IConstant" /> which is assigned to the specified <c>name</c>.
                If there's no such <see cref="T:DotNetty.Common.Utilities.IConstant" />, a new one will be created and returned.
                Once created, the subsequent calls with the same <c>name</c> will always return the previously created one
                (i.e. singleton.)
            </summary>
            <param name="name">the name of the <see cref="T:DotNetty.Common.Utilities.IConstant" /></param>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.Exists(System.String)">
            <summary>Returns <c>true</c> if a <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> exists for the given <c>name</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.NewInstance``1(System.String)">
            <summary>
                Creates a new <see cref="T:DotNetty.Common.Utilities.IConstant" /> for the given <c>name</c> or fail with an
                <see cref="T:System.ArgumentException" /> if a <see cref="T:DotNetty.Common.Utilities.IConstant" /> for the given <c>name</c> exists.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.DefaultAttributeMap">
            <summary>
                Default <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> implementation which use simple synchronization per bucket to keep the memory
                overhead
                as low as possible.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.#ctor(System.TimeSpan,System.Int32,System.Int64)">
            <summary>
            Creates a new timer.
            </summary>
            <param name="tickInterval">the interval between two consecutive ticks</param>
            <param name="ticksPerWheel">the size of the wheel</param>
            <param name="maxPendingTimeouts">The maximum number of pending timeouts after which call to
            <c>newTimeout</c> will result in <see cref="T:DotNetty.Common.Concurrency.RejectedExecutionException"/> being thrown.
            No maximum pending timeouts limit is assumed if this value is 0 or negative.</param>
            <exception cref="T:System.ArgumentException">if either of <c>tickInterval</c> and <c>ticksPerWheel</c> is &lt;= 0</exception>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.Start">
            <summary>
            Starts the background thread explicitly. The background thread will
            start automatically on demand even if you did not call this method.
            </summary>
            <exception cref="T:System.InvalidOperationException">if this timer has been
            stopped already.</exception>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.Worker.WaitForNextTick">
            <summary>
            calculate timer firing time from startTime and current tick number,
            then wait until that goal has been reached.
            </summary>
            <returns>long.MinValue if received a shutdown request,
            current time otherwise (with long.MinValue changed by +1)
            </returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket">
            <summary>
            Bucket that stores HashedWheelTimeouts. These are stored in a linked-list like datastructure to allow easy
            removal of HashedWheelTimeouts in the middle. Also the HashedWheelTimeout act as nodes themself and so no
            extra object creation is needed.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket.AddTimeout(DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelTimeout)">
            <summary>
            Add a <see cref="T:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelTimeout"/> to this bucket.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket.ExpireTimeouts(System.TimeSpan)">
            <summary>
            Expire all <see cref="T:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelTimeout"/>s for the given <c>deadline</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket.ClearTimeouts(System.Collections.Generic.ISet{DotNetty.Common.Utilities.ITimeout})">
            <summary>
            Clear this bucket and return all not expired / cancelled <see cref="T:DotNetty.Common.Utilities.ITimeout"/>s.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IAttribute`1">
            <summary>An attribute which allows to store a value reference. It may be updated atomically and so is thread-safe.</summary>
            <typeparam name="T">the type of the value it holds.</typeparam>
        </member>
        <member name="P:DotNetty.Common.Utilities.IAttribute`1.Key">
            <summary>
                Returns the key of this attribute.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.Get">
            <summary>
                Returns the current value, which may be <c>null</c>
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.Set(`0)">
            <summary>
                Sets the value
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.GetAndSet(`0)">
            <summary>
                Atomically sets to the given value and returns the old value which may be <c>null</c> if non was set before.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.SetIfAbsent(`0)">
            <summary>
                Atomically sets to the given value if this <see cref="T:DotNetty.Common.Utilities.IAttribute`1" />'s value is <c>null</c>.
                If it was not possible to set the value as it contains a value it will just return the current value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.GetAndRemove">
            <summary>
                Removes this attribute from the <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> and returns the old value. Subsequent
                <see cref="M:DotNetty.Common.Utilities.IAttribute`1.Get" />
                calls will return <c>null</c>.
                If you only want to return the old value and clear the <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> while still keep it in
                <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> use <see cref="M:DotNetty.Common.Utilities.IAttribute`1.GetAndSet(`0)" /> with a value of <c>null</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.CompareAndSet(`0,`0)">
            <summary>
                Atomically sets the value to the given updated value if the current value == the expected value.
                If it the set was successful it returns <c>true</c> otherwise <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.Remove">
            <summary>
                Removes this attribute from the <see cref="T:DotNetty.Common.Utilities.IAttributeMap" />. Subsequent <see cref="M:DotNetty.Common.Utilities.IAttribute`1.Get" /> calls will return
                <c>null</c>.
                If you only want to remove the value and clear the <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> while still keep it in
                <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> use <see cref="M:DotNetty.Common.Utilities.IAttribute`1.Set(`0)" /> with a value of <c>null</c>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IAttributeMap">
            <summary>Holds <see cref="T:DotNetty.Common.Utilities.IAttribute`1" />s which can be accessed via <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" />.</summary>
            <remarks>Implementations must be Thread-safe.</remarks>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttributeMap.GetAttribute``1(DotNetty.Common.Utilities.AttributeKey{``0})">
            <summary>
                Get the <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> for the given <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" />. This method will never return
                null, but may return an <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> which does not have a value set yet.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttributeMap.HasAttribute``1(DotNetty.Common.Utilities.AttributeKey{``0})">
            <summary>
                Returns <c>true</c> if and only if the given <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> exists in this
                <see cref="T:DotNetty.Common.Utilities.IAttributeMap" />.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ICharSequence.SubSequence(System.Int32,System.Int32)">
            Start is the inclusive start index to begin the subsequence.
            End is the exclusive end index to end the subsequence.
        </member>
        <member name="T:DotNetty.Common.Utilities.IConstant">
            <summary>
                A singleton which is safe to compare via the <c>==</c> operator. Created and managed by
                <see cref="T:DotNetty.Common.Utilities.ConstantPool" />.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.IConstant.Id">
            <summary>Returns the unique number assigned to this <see cref="T:DotNetty.Common.Utilities.IConstant" />.</summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.IConstant.Name">
            <summary>Returns the name of this <see cref="T:DotNetty.Common.Utilities.IConstant" />.</summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IllegalReferenceCountException">
            <inheritdoc />
            <summary>
                Exception thrown during instances where a reference count is used incorrectly
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.ITimeout">
            <summary>
            A handle associated with a <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> that is returned by a
            <see cref="T:DotNetty.Common.Utilities.ITimer"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Timer">
            <summary>
            Returns the <see cref="T:DotNetty.Common.Utilities.ITimer"/> that created this handle.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Task">
            <summary>
            Returns the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> which is associated with this handle.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Expired">
            <summary>
            Returns <c>true</c> if and only if the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> associated
            with this handle has been expired.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Canceled">
            <summary>
            Returns <c>true</c> if and only if the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> associated
            with this handle has been canceled.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimeout.Cancel">
            <summary>
            Attempts to cancel the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> associated with this handle.
            If the task has been executed or canceled already, it will return with
            no side effect.
            </summary>
            <returns><c>true</c> if the cancellation completed successfully, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.ITimer">
            <summary>
            Schedules <see cref="T:DotNetty.Common.Utilities.ITimerTask"/>s for one-time future execution in a background
            thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimer.NewTimeout(DotNetty.Common.Utilities.ITimerTask,System.TimeSpan)">
            <summary>
            Schedules the specified <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> for one-time execution after the specified delay.
            </summary>
            <returns>a handle which is associated with the specified task</returns>
            <exception cref="T:System.InvalidOperationException">if this timer has been stopped already</exception>
            <exception cref="T:DotNetty.Common.Concurrency.RejectedExecutionException">if the pending timeouts are too many and creating new timeout
            can cause instability in the system.</exception>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimer.StopAsync">
            <summary>
            Releases all resources acquired by this <see cref="T:DotNetty.Common.Utilities.ITimer"/> and cancels all
            tasks which were scheduled but not executed yet.
            </summary>
            <returns>the handles associated with the tasks which were canceled by
            this method</returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.ITimerTask">
            <summary>
            A task which is executed after the delay specified with
            <see cref="M:DotNetty.Common.Utilities.ITimer.NewTimeout(DotNetty.Common.Utilities.ITimerTask,System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimerTask.Run(DotNetty.Common.Utilities.ITimeout)">
            <summary>
            Executed after the delay specified with
            <see cref="M:DotNetty.Common.Utilities.ITimer.NewTimeout(DotNetty.Common.Utilities.ITimerTask,System.TimeSpan)"/>.
            </summary>
            <param name="timeout">a handle which is associated with this task</param>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Retain``1(``0)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Retain"/> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Retain``1(``0,System.Int32)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Retain(System.Int32)"/> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Touch``1(``0)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Touch" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted" />.
            If the specified message doesn't implement <see cref="T:DotNetty.Common.IReferenceCounted" />, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Touch``1(``0,System.Object)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Touch(System.Object)" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted" />. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted" />, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object,System.Int32)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing. Unlike <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)"/>, this
            method catches an exception raised by <see cref="M:DotNetty.Common.IReferenceCounted.Release" /> and logs it, rather than
            rethrowing it to the caller. It is usually recommended to use <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)"/> instead, unless
            you absolutely need to swallow an exception.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object,System.Int32)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing. Unlike <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)"/>, this
            method catches an exception raised by <see cref="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)" /> and logs it, rather
            than rethrowing it to the caller. It is usually recommended to use <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object,System.Int32)"/>
            instead, unless you absolutely need to swallow an exception.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.ReleaseLater``1(``0)">
            <summary>
            Schedules the specified object to be released when the caller thread terminates. Note that this operation
            is intended to simplify reference counting of ephemeral objects during unit tests. Do not use it beyond the
            intended use case.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.ReleaseLater``1(``0,System.Int32)">
            <summary>
            Schedules the specified object to be released when the caller thread terminates. Note that this operation
            is intended to simplify reference counting of ephemeral objects during unit tests. Do not use it beyond the
            intended use case.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.StringUtil">
            <summary>
                String utility class.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.StringUtil.CsvNumberEscapeCharacters">
            2 - Quote character at beginning and end.
            5 - Extra allowance for anticipated escape characters that may be added.
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ByteToHexStringPadded(System.Int32)">
            <summary>
                Converts the specified byte value into a 2-digit hexadecimal integer.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ToHexStringPadded(System.Byte[])">
            <summary>
                Converts the specified byte array into a hexadecimal value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ToHexStringPadded(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Converts the specified byte array into a hexadecimal value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ByteToHexString(System.Byte)">
            <summary>
                Converts the specified byte value into a hexadecimal integer.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Object)">
            <summary>
                The shortcut to <see cref="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Type)">SimpleClassName(o.GetType())</see>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName``1">
            <summary>
                The shortcut to <see cref="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Type)">SimpleClassName(o.GetType())</see>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Type)">
            <summary>
                Generates a simplified name from a <see cref="T:System.Type" />.  Similar to {@link Class#getSimpleName()}, but it works
                fine
                with anonymous classes.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.EscapeCsv(DotNetty.Common.Utilities.ICharSequence,System.Boolean)">
            <summary>
                Escapes the specified value, if necessary according to
                <a href="https://tools.ietf.org/html/rfc4180#section-2">RFC-4180</a>.
            </summary>
            <param name="value">
                The value which will be escaped according to
                <a href="https://tools.ietf.org/html/rfc4180#section-2">RFC-4180</a>
            </param>
            <param name="trimWhiteSpace">
                The value will first be trimmed of its optional white-space characters, according to 
                <a href= "https://tools.ietf.org/html/rfc7230#section-7" >RFC-7230</a>
            </param>
            <returns>the escaped value if necessary, or the value unchanged</returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.TimeUtil">
            <summary>
            Time utility class.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.TimeUtil.Max(System.TimeSpan,System.TimeSpan)">
            <summary>
            Compare two timespan objects
            </summary>
            <param name="t1">first timespan object</param>
            <param name="t2">two timespan object</param>
        </member>
        <member name="M:DotNetty.Common.Utilities.TimeUtil.GetSystemTime">
            <summary>
            Gets the system time.
            </summary>
            <returns>The system time.</returns>
        </member>
        <member name="T:Nito.Deque`1">
            <summary>
                A double-ended queue (deque), which provides O(1) indexed access, O(1) removals from the front and back, amortized
                O(1) insertions to the front and back, and O(N) insertions and removals anywhere else (with the operations getting
                slower as the index approaches the middle).
            </summary>
            <typeparam name="T">The type of elements contained in the deque.</typeparam>
        </member>
        <member name="F:Nito.Deque`1.DefaultCapacity">
            <summary>
                The default capacity.
            </summary>
        </member>
        <member name="F:Nito.Deque`1.buffer">
            <summary>
                The circular buffer that holds the view.
            </summary>
        </member>
        <member name="F:Nito.Deque`1.offset">
            <summary>
                The offset into <see cref="F:Nito.Deque`1.buffer" /> where the view begins.
            </summary>
        </member>
        <member name="M:Nito.Deque`1.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Nito.Deque`1" /> class with the specified capacity.
            </summary>
            <param name="capacity">The initial capacity. Must be greater than <c>0</c>.</param>
        </member>
        <member name="M:Nito.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:Nito.Deque`1" /> class with the elements from the specified
                collection.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="M:Nito.Deque`1.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Nito.Deque`1" /> class.
            </summary>
        </member>
        <member name="P:Nito.Deque`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
                Gets a value indicating whether this list is read-only. This implementation always returns <c>false</c>.
            </summary>
            <returns>true if this list is read-only; otherwise, false.</returns>
        </member>
        <member name="P:Nito.Deque`1.Item(System.Int32)">
            <summary>
                Gets or sets the item at the specified index.
            </summary>
            <param name="index">The index of the item to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not a valid index in this list.</exception>
            <exception cref="T:System.NotSupportedException">This property is set and the list is read-only.</exception>
        </member>
        <member name="M:Nito.Deque`1.Insert(System.Int32,`0)">
            <summary>
                Inserts an item to this list at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into this list.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is not a valid index in this list.
            </exception>
            <exception cref="T:System.NotSupportedException">
                This list is read-only.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.RemoveAt(System.Int32)">
            <summary>
                Removes the item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is not a valid index in this list.
            </exception>
            <exception cref="T:System.NotSupportedException">
                This list is read-only.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.IndexOf(`0)">
            <summary>
                Determines the index of a specific item in this list.
            </summary>
            <param name="item">The object to locate in this list.</param>
            <returns>The index of <paramref name="item" /> if found in this list; otherwise, -1.</returns>
        </member>
        <member name="M:Nito.Deque`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
                Adds an item to the end of this list.
            </summary>
            <param name="item">The object to add to this list.</param>
            <exception cref="T:System.NotSupportedException">
                This list is read-only.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.System#Collections#Generic#ICollection{T}#Contains(`0)">
            <summary>
                Determines whether this list contains a specific value.
            </summary>
            <param name="item">The object to locate in this list.</param>
            <returns>
                true if <paramref name="item" /> is found in this list; otherwise, false.
            </returns>
        </member>
        <member name="M:Nito.Deque`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
                Copies the elements of this list to an <see cref="T:System.Array" />, starting at a particular
                <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">
                The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
                from this slice. The <see cref="T:System.Array" /> must have zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="array" /> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="arrayIndex" /> is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="arrayIndex" /> is equal to or greater than the length of <paramref name="array" />.
                -or-
                The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the
                available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.Remove(`0)">
            <summary>
                Removes the first occurrence of a specific object from this list.
            </summary>
            <param name="item">The object to remove from this list.</param>
            <returns>
                true if <paramref name="item" /> was successfully removed from this list; otherwise, false. This method also
                returns false if <paramref name="item" /> is not found in this list.
            </returns>
            <exception cref="T:System.NotSupportedException">
                This list is read-only.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Nito.Deque`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Nito.Deque`1.ObjectIsT(System.Object)">
            <summary>
                Returns whether or not the type of a given item indicates it is appropriate for storing in this container.
            </summary>
            <param name="item">The item to test.</param>
            <returns><c>true</c> if the item is appropriate to store in this container; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Nito.Deque`1.CheckNewIndexArgument(System.Int32,System.Int32)">
            <summary>
                Checks the <paramref name="index" /> argument to see if it refers to a valid insertion point in a source of a given
                length.
            </summary>
            <param name="sourceLength">The length of the source. This parameter is not checked for validity.</param>
            <param name="index">The index into the source.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is not a valid index to an insertion point for
                the source.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.CheckExistingIndexArgument(System.Int32,System.Int32)">
            <summary>
                Checks the <paramref name="index" /> argument to see if it refers to an existing element in a source of a given
                length.
            </summary>
            <param name="sourceLength">The length of the source. This parameter is not checked for validity.</param>
            <param name="index">The index into the source.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is not a valid index to an existing element for
                the source.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.CheckRangeArguments(System.Int32,System.Int32,System.Int32)">
            <summary>
                Checks the <paramref name="offset" /> and <paramref name="count" /> arguments for validity when applied to a source
                of a given length. Allows 0-element ranges, including a 0-element range at the end of the source.
            </summary>
            <param name="sourceLength">The length of the source. This parameter is not checked for validity.</param>
            <param name="offset">The index into source at which the range begins.</param>
            <param name="count">The number of elements in the range.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                Either <paramref name="offset" /> or <paramref name="count" /> is less
                than 0.
            </exception>
            <exception cref="T:System.ArgumentException">The range [offset, offset + count) is not within the range [0, sourceLength).</exception>
        </member>
        <member name="P:Nito.Deque`1.IsEmpty">
            <summary>
                Gets a value indicating whether this instance is empty.
            </summary>
        </member>
        <member name="P:Nito.Deque`1.IsFull">
            <summary>
                Gets a value indicating whether this instance is at full capacity.
            </summary>
        </member>
        <member name="P:Nito.Deque`1.IsSplit">
            <summary>
                Gets a value indicating whether the buffer is "split" (meaning the beginning of the view is at a later index in
                <see cref="F:Nito.Deque`1.buffer" /> than the end).
            </summary>
        </member>
        <member name="P:Nito.Deque`1.Capacity">
            <summary>
                Gets or sets the capacity for this deque. This value must always be greater than zero, and this property cannot be
                set to a value less than <see cref="P:Nito.Deque`1.Count" />.
            </summary>
            <exception cref="T:System.InvalidOperationException"><c>Capacity</c> cannot be set to a value less than <see cref="P:Nito.Deque`1.Count" />.</exception>
        </member>
        <member name="P:Nito.Deque`1.Count">
            <summary>
                Gets the number of elements contained in this deque.
            </summary>
            <returns>The number of elements contained in this deque.</returns>
        </member>
        <member name="M:Nito.Deque`1.DequeIndexToBufferIndex(System.Int32)">
            <summary>
                Applies the offset to <paramref name="index" />, resulting in a buffer index.
            </summary>
            <param name="index">The deque index.</param>
            <returns>The buffer index.</returns>
        </member>
        <member name="M:Nito.Deque`1.DoGetItem(System.Int32)">
            <summary>
                Gets an element at the specified view index.
            </summary>
            <param name="index">The zero-based view index of the element to get. This index is guaranteed to be valid.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="M:Nito.Deque`1.DoSetItem(System.Int32,`0)">
            <summary>
                Sets an element at the specified view index.
            </summary>
            <param name="index">The zero-based view index of the element to get. This index is guaranteed to be valid.</param>
            <param name="item">The element to store in the list.</param>
        </member>
        <member name="M:Nito.Deque`1.DoInsert(System.Int32,`0)">
            <summary>
                Inserts an element at the specified view index.
            </summary>
            <param name="index">
                The zero-based view index at which the element should be inserted. This index is guaranteed to be
                valid.
            </param>
            <param name="item">The element to store in the list.</param>
        </member>
        <member name="M:Nito.Deque`1.DoRemoveAt(System.Int32)">
            <summary>
                Removes an element at the specified view index.
            </summary>
            <param name="index">The zero-based view index of the element to remove. This index is guaranteed to be valid.</param>
        </member>
        <member name="M:Nito.Deque`1.PostIncrement(System.Int32)">
            <summary>
                Increments <see cref="F:Nito.Deque`1.offset" /> by <paramref name="value" /> using modulo-<see cref="P:Nito.Deque`1.Capacity" /> arithmetic.
            </summary>
            <param name="value">The value by which to increase <see cref="F:Nito.Deque`1.offset" />. May not be negative.</param>
            <returns>The value of <see cref="F:Nito.Deque`1.offset" /> after it was incremented.</returns>
        </member>
        <member name="M:Nito.Deque`1.PreDecrement(System.Int32)">
            <summary>
                Decrements <see cref="F:Nito.Deque`1.offset" /> by <paramref name="value" /> using modulo-<see cref="P:Nito.Deque`1.Capacity" /> arithmetic.
            </summary>
            <param name="value">
                The value by which to reduce <see cref="F:Nito.Deque`1.offset" />. May not be negative or greater than
                <see cref="P:Nito.Deque`1.Capacity" />.
            </param>
            <returns>The value of <see cref="F:Nito.Deque`1.offset" /> before it was decremented.</returns>
        </member>
        <member name="M:Nito.Deque`1.DoAddToBack(`0)">
            <summary>
                Inserts a single element to the back of the view. <see cref="P:Nito.Deque`1.IsFull" /> must be false when this method is called.
            </summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:Nito.Deque`1.DoAddToFront(`0)">
            <summary>
                Inserts a single element to the front of the view. <see cref="P:Nito.Deque`1.IsFull" /> must be false when this method is called.
            </summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:Nito.Deque`1.DoRemoveFromBack">
            <summary>
                Removes and returns the last element in the view. <see cref="P:Nito.Deque`1.IsEmpty" /> must be false when this method is called.
            </summary>
            <returns>The former last element.</returns>
        </member>
        <member name="M:Nito.Deque`1.DoRemoveFromFront">
            <summary>
                Removes and returns the first element in the view. <see cref="P:Nito.Deque`1.IsEmpty" /> must be false when this method is called.
            </summary>
            <returns>The former first element.</returns>
        </member>
        <member name="M:Nito.Deque`1.DoInsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
                Inserts a range of elements into the view.
            </summary>
            <param name="index">The index into the view at which the elements are to be inserted.</param>
            <param name="collection">The elements to insert.</param>
            <param name="collectionCount">
                The number of elements in <paramref name="collection" />. Must be greater than zero, and
                the sum of <paramref name="collectionCount" /> and <see cref="P:Nito.Deque`1.Count" /> must be less than or equal to
                <see cref="P:Nito.Deque`1.Capacity" />.
            </param>
        </member>
        <member name="M:Nito.Deque`1.DoRemoveRange(System.Int32,System.Int32)">
            <summary>
                Removes a range of elements from the view.
            </summary>
            <param name="index">The index into the view at which the range begins.</param>
            <param name="collectionCount">
                The number of elements in the range. This must be greater than 0 and less than or equal
                to <see cref="P:Nito.Deque`1.Count" />.
            </param>
        </member>
        <member name="M:Nito.Deque`1.EnsureCapacityForOneElement">
            <summary>
                Doubles the capacity if necessary to make room for one more element. When this method returns,
                <see cref="P:Nito.Deque`1.IsFull" /> is false.
            </summary>
        </member>
        <member name="M:Nito.Deque`1.AddToBack(`0)">
            <summary>
                Inserts a single element at the back of this deque.
            </summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:Nito.Deque`1.AddToFront(`0)">
            <summary>
                Inserts a single element at the front of this deque.
            </summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:Nito.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Inserts a collection of elements into this deque.
            </summary>
            <param name="index">The index at which the collection is inserted.</param>
            <param name="collection">The collection of elements to insert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is not a valid index to an insertion point for
                the source.
            </exception>
        </member>
        <member name="M:Nito.Deque`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
                Removes a range of elements from this deque.
            </summary>
            <param name="offset">The index into the deque at which the range begins.</param>
            <param name="count">The number of elements to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                Either <paramref name="offset" /> or <paramref name="count" /> is less
                than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
                The range [<paramref name="offset" />, <paramref name="offset" /> +
                <paramref name="count" />) is not within the range [0, <see cref="P:Nito.Deque`1.Count" />).
            </exception>
        </member>
        <member name="M:Nito.Deque`1.RemoveFromBack">
            <summary>
                Removes and returns the last element of this deque.
            </summary>
            <returns>The former last element.</returns>
            <exception cref="T:System.InvalidOperationException">The deque is empty.</exception>
        </member>
        <member name="M:Nito.Deque`1.RemoveFromFront">
            <summary>
                Removes and returns the first element of this deque.
            </summary>
            <returns>The former first element.</returns>
            <exception cref="T:System.InvalidOperationException">The deque is empty.</exception>
        </member>
        <member name="M:Nito.Deque`1.Clear">
            <summary>
                Removes all items from this deque.
            </summary>
        </member>
    </members>
</doc>
